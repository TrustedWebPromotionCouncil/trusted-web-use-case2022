"use strict";
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames2(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS2({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS2({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream4) {
      return typeof stream4 !== "function" && typeof stream4 !== "string" && typeof stream4 !== "boolean" && typeof stream4 !== "number" && !Buffer.isBuffer(stream4);
    };
    CombinedStream.prototype.append = function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream4.on("data", this._checkDataSize.bind(this));
          stream4 = newStream;
        }
        this._handleErrors(stream4);
        if (this.pauseStreams) {
          stream4.pause();
        }
      }
      this._streams.push(stream4);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream4 = this._streams.shift();
      if (typeof stream4 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream4 !== "function") {
        this._pipeNext(stream4);
        return;
      }
      var getStream2 = stream4;
      getStream2(function(stream5) {
        var isStreamLike = CombinedStream.isStreamLike(stream5);
        if (isStreamLike) {
          stream5.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream5);
        }
        this._pipeNext(stream5);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("end", this._getNext.bind(this));
        stream4.pipe(this, { end: false });
        return;
      }
      var value = stream4;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream4) {
      var self2 = this;
      stream4.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream4) {
        if (!stream4.dataSize) {
          return;
        }
        self2.dataSize += stream4.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS2({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS2({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS2({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types2[extension2]) {
            var from = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS2({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS2({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS2({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS2({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error2, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error2) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error2, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS2({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS2({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS2({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error2, result) {
          if (error2) {
            callback(error2, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS2({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error2, result) {
        if (error2) {
          callback(error2, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS2({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS2({
  "node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS2({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS2({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path2 = require("path");
    var http4 = require("http");
    var https3 = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData4;
    util.inherits(FormData4, CombinedStream);
    function FormData4(options) {
      if (!(this instanceof FormData4)) {
        return new FormData4(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData4.LINE_BREAK = "\r\n";
    FormData4.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData4.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append2(header);
      append2(value);
      append2(footer);
      this._trackLength(header, value, options);
    };
    FormData4.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData4.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData4.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData4.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData4.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData4.LINE_BREAK + contents + FormData4.LINE_BREAK;
    };
    FormData4.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path2.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path2.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path2.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData4.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData4.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData4.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData4.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData4.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData4.LINE_BREAK;
    };
    FormData4.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData4.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData4.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData4.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData4.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData4.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData4.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData4.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData4.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData4.prototype.submit = function(params, cb) {
      var request2, options, defaults3 = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults3);
      } else {
        options = populate(params, defaults3);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request2 = https3.request(options);
      } else {
        request2 = http4.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request2.setHeader("Content-Length", length);
        }
        this.pipe(request2);
        if (cb) {
          var onResponse;
          var callback = function(error2, responce) {
            request2.removeListener("error", callback);
            request2.removeListener("response", onResponse);
            return cb.call(this, error2, responce);
          };
          onResponse = callback.bind(this, null);
          request2.on("error", callback);
          request2.on("response", onResponse);
        }
      }.bind(this));
      return request2;
    };
    FormData4.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData4.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS2({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl2(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv2("npm_config_" + proto + "_proxy") || getEnv2(proto + "_proxy") || getEnv2("npm_config_proxy") || getEnv2("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv2("npm_config_no_proxy") || getEnv2("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv2(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl2;
  }
});

// node_modules/debug/node_modules/ms/index.js
var require_ms2 = __commonJS2({
  "node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS2({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms2();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS2({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag2 = __commonJS2({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color2 = __commonJS2({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os4 = require("os");
    var hasFlag = require_has_flag2();
    var env2 = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env2) {
      forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream4) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream4 && !stream4.isTTY && forceColor !== true) {
        return 0;
      }
      const min2 = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os4.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign2) => sign2 in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min2;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      if (env2.TERM === "dumb") {
        return min2;
      }
      return min2;
    }
    function getSupportLevel(stream4) {
      const level = supportsColor(stream4);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS2({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init2;
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color2();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log3(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys2 = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS2({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS2({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src2()("follow-redirects");
        } catch (error2) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS2({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url2 = require("url");
    var URL4 = url2.URL;
    var http4 = require("http");
    var https3 = require("https");
    var Writable = require("stream").Writable;
    var assert2 = require("assert");
    var debug = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer2(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction4(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction4(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction4(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request2._redirectable = this;
      for (var event of events) {
        request2.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error2) {
          if (request2 === self2._currentRequest) {
            if (error2) {
              self2.emit("error", error2);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request2.finished) {
                request2.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request2.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url2.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url2.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url2.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction4(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request2(input, options, callback) {
          if (isString2(input)) {
            var parsed;
            try {
              parsed = urlToOptions2(new URL4(input));
            } catch (err) {
              parsed = url2.parse(input);
            }
            if (!isString2(parsed.protocol)) {
              throw new InvalidUrlError({ input });
            }
            input = parsed;
          } else if (URL4 && input instanceof URL4) {
            input = urlToOptions2(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (isFunction4(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = "::1";
          }
          assert2.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request2, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop4() {
    }
    function urlToOptions2(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      return CustomError;
    }
    function abortRequest(request2) {
      for (var event of events) {
        request2.removeListener(event, eventHandlers[event]);
      }
      request2.on("error", noop4);
      request2.abort();
    }
    function isSubdomain(subdomain, domain) {
      assert2(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction4(value) {
      return typeof value === "function";
    }
    function isBuffer2(value) {
      return typeof value === "object" && "length" in value;
    }
    module2.exports = wrap({ http: http4, https: https3 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/defer-to-connect/dist/source/index.js
var require_source2 = __commonJS2({
  "node_modules/defer-to-connect/dist/source/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isTLSSocket(socket) {
      return socket.encrypted;
    }
    var deferToConnect2 = (socket, fn) => {
      let listeners;
      if (typeof fn === "function") {
        const connect = fn;
        listeners = { connect };
      } else {
        listeners = fn;
      }
      const hasConnectListener = typeof listeners.connect === "function";
      const hasSecureConnectListener = typeof listeners.secureConnect === "function";
      const hasCloseListener = typeof listeners.close === "function";
      const onConnect = () => {
        if (hasConnectListener) {
          listeners.connect();
        }
        if (isTLSSocket(socket) && hasSecureConnectListener) {
          if (socket.authorized) {
            listeners.secureConnect();
          } else if (!socket.authorizationError) {
            socket.once("secureConnect", listeners.secureConnect);
          }
        }
        if (hasCloseListener) {
          socket.once("close", listeners.close);
        }
      };
      if (socket.writable && !socket.connecting) {
        onConnect();
      } else if (socket.connecting) {
        socket.once("connect", onConnect);
      } else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
      }
    };
    exports2.default = deferToConnect2;
    module2.exports = deferToConnect2;
    module2.exports.default = deferToConnect2;
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream2 = __commonJS2({
  "node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream2 } = require("stream");
    module2.exports = (options) => {
      options = { ...options };
      const { array } = options;
      let { encoding } = options;
      const isBuffer2 = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer2);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer2) {
        encoding = null;
      }
      const stream4 = new PassThroughStream2({ objectMode });
      if (encoding) {
        stream4.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream4.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream4.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer2 ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream4.getBufferedLength = () => length;
      return stream4;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream2 = __commonJS2({
  "node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var stream4 = require("stream");
    var { promisify: promisify4 } = require("util");
    var bufferStream = require_buffer_stream2();
    var streamPipelinePromisified = promisify4(stream4.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream2(inputStream, options) {
      if (!inputStream) {
        throw new Error("Expected a stream");
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const { maxBuffer } = options;
      const stream5 = bufferStream(options);
      await new Promise((resolve, reject) => {
        const rejectPromise = (error2) => {
          if (error2 && stream5.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error2.bufferedData = stream5.getBufferedValue();
          }
          reject(error2);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream5);
            resolve();
          } catch (error2) {
            rejectPromise(error2);
          }
        })();
        stream5.on("data", () => {
          if (stream5.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream5.getBufferedValue();
    }
    module2.exports = getStream2;
    module2.exports.buffer = (stream5, options) => getStream2(stream5, { ...options, encoding: "buffer" });
    module2.exports.array = (stream5, options) => getStream2(stream5, { ...options, array: true });
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS2({
  "node_modules/http-cache-semantics/index.js"(exports2, module2) {
    "use strict";
    var statusCodeCacheableByDefault = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      206,
      300,
      301,
      404,
      405,
      410,
      414,
      501
    ]);
    var understoodStatuses = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      300,
      301,
      302,
      303,
      307,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var errorStatusCodes = /* @__PURE__ */ new Set([
      500,
      502,
      503,
      504
    ]);
    var hopByHopHeaders = {
      date: true,
      // included, because we add Age update Date
      connection: true,
      "keep-alive": true,
      "proxy-authenticate": true,
      "proxy-authorization": true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true
    };
    var excludedFromRevalidationUpdate = {
      // Since the old body is reused, it doesn't make sense to change properties of the body
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function toNumberOrZero(s) {
      const n = parseInt(s, 10);
      return isFinite(n) ? n : 0;
    }
    function isErrorResponse(response) {
      if (!response) {
        return true;
      }
      return errorStatusCodes.has(response.status);
    }
    function parseCacheControl(header) {
      const cc = {};
      if (!header)
        return cc;
      const parts = header.trim().split(/\s*,\s*/);
      for (const part of parts) {
        const [k, v] = part.split(/\s*=\s*/, 2);
        cc[k] = v === void 0 ? true : v.replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      let parts = [];
      for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    module2.exports = class CachePolicy {
      constructor(req, res, {
        shared,
        cacheHeuristic,
        immutableMinTimeToLive,
        ignoreCargoCult,
        _fromObject
      } = {}) {
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic = void 0 !== cacheHeuristic ? cacheHeuristic : 0.1;
        this._immutableMinTtl = void 0 !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, {
            "cache-control": formatCacheControl(this._rescc)
          });
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      now() {
        return Date.now();
      }
      storable() {
        return !!(!this._reqcc["no-store"] && // A cache MUST NOT store a response to any request, unless:
        // The request method is understood by the cache and defined as being cacheable, and
        ("GET" === this._method || "HEAD" === this._method || "POST" === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
        understoodStatuses.has(this._status) && // the "no-store" cache directive does not appear in request or response header fields, and
        !this._rescc["no-store"] && // the "private" response directive does not appear in the response, if the cache is shared, and
        (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,
        (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:
        // contains an Expires header field, or
        (this._resHeaders.expires || // contains a max-age response directive, or
        // contains a s-maxage response directive and the cache is shared, or
        // contains a public response directive.
        this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || // has a status code that is defined as cacheable by default
        statusCodeCacheableByDefault.has(this._status)));
      }
      _hasExplicitExpiration() {
        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
      }
      _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      }
      satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);
        const requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return false;
        }
        if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
          return false;
        }
        if (requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"]) {
          return false;
        }
        if (this.stale()) {
          const allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (true === requestCC["max-stale"] || requestCC["max-stale"] > this.age() - this.maxAge());
          if (!allowsStale) {
            return false;
          }
        }
        return this._requestMatches(req, false);
      }
      _requestMatches(req, allowHeadMethod) {
        return (!this._url || this._url === req.url) && this._host === req.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and
        (!req.method || this._method === req.method || allowHeadMethod && "HEAD" === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and
        this._varyMatches(req);
      }
      _allowsStoringAuthenticated() {
        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
      }
      _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of fields) {
          if (req.headers[name] !== this._reqHeaders[name])
            return false;
        }
        return true;
      }
      _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
          if (hopByHopHeaders[name])
            continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (const name of tokens) {
            delete headers[name];
          }
        }
        if (headers.warning) {
          const warnings = headers.warning.split(/,/).filter((warning) => {
            return !/^\s*1[0-9][0-9]/.test(warning);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      }
      responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
      }
      /**
       * Value of the Date response header or current time if Date was invalid
       * @return timestamp
       */
      date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
          return serverDate;
        }
        return this._responseTime;
      }
      /**
       * Value of the Age header, in seconds, updated for the current time.
       * May be fractional.
       *
       * @return Number
       */
      age() {
        let age = this._ageValue();
        const residentTime = (this.now() - this._responseTime) / 1e3;
        return age + residentTime;
      }
      _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
      }
      /**
       * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
       *
       * For an up-to-date value, see `timeToLive()`.
       *
       * @return Number
       */
      maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return toNumberOrZero(this._rescc["s-maxage"]);
          }
        }
        if (this._rescc["max-age"]) {
          return toNumberOrZero(this._rescc["max-age"]);
        }
        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        const serverDate = this.date();
        if (this._resHeaders.expires) {
          const expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < serverDate) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          const lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && serverDate > lastModified) {
            return Math.max(
              defaultMinTtl,
              (serverDate - lastModified) / 1e3 * this._cacheHeuristic
            );
          }
        }
        return defaultMinTtl;
      }
      timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3;
      }
      stale() {
        return this.maxAge() <= this.age();
      }
      _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
      }
      useStaleWhileRevalidate() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
      }
      static fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      }
      _fromObject(obj) {
        if (this._responseTime)
          throw Error("Reinitialized");
        if (!obj || obj.v !== 1)
          throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      }
      toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      }
      /**
       * Headers for sending to the origin server to revalidate stale response.
       * Allows server to return 304 to allow reuse of the previous response.
       *
       * Hop by hop headers are always stripped.
       * Revalidation headers may be added or removed, depending on request.
       */
      revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            const etags = headers["if-none-match"].split(/,/).filter((etag) => {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      }
      /**
       * Creates new CachePolicy with information combined from the previews response,
       * and the new revalidation response.
       *
       * Returns {policy, modified} where modified is a boolean indicating
       * whether the response body has been modified, and old cached body can't be used.
       *
       * @return {Object} {policy: CachePolicy, modified: Boolean}
       */
      revalidatedPolicy(request2, response) {
        this._assertRequestHasHeaders(request2);
        if (this._useStaleIfError() && isErrorResponse(response)) {
          return {
            modified: false,
            matches: false,
            policy: this
          };
        }
        if (!response || !response.headers) {
          throw Error("Response headers missing");
        }
        let matches = false;
        if (response.status !== void 0 && response.status != 304) {
          matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
          matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
          matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
            matches = true;
          }
        }
        if (!matches) {
          return {
            policy: new this.constructor(request2, response),
            // Client receiving 304 without body, even if it's invalid/mismatched has no option
            // but to reuse a cached body. We don't have a good way to tell clients to do
            // error recovery in such case.
            modified: response.status != 304,
            matches: false
          };
        }
        const headers = {};
        for (const k in this._resHeaders) {
          headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }
        const newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request2, newResponse, {
            shared: this._isShared,
            cacheHeuristic: this._cacheHeuristic,
            immutableMinTimeToLive: this._immutableMinTtl
          }),
          modified: false,
          matches: true
        };
      }
    };
  }
});

// node_modules/json-buffer/index.js
var require_json_buffer = __commonJS2({
  "node_modules/json-buffer/index.js"(exports2) {
    exports2.stringify = function stringify2(o) {
      if ("undefined" == typeof o)
        return o;
      if (o && Buffer.isBuffer(o))
        return JSON.stringify(":base64:" + o.toString("base64"));
      if (o && o.toJSON)
        o = o.toJSON();
      if (o && "object" === typeof o) {
        var s = "";
        var array = Array.isArray(o);
        s = array ? "[" : "{";
        var first = true;
        for (var k in o) {
          var ignore = "function" == typeof o[k] || !array && "undefined" === typeof o[k];
          if (Object.hasOwnProperty.call(o, k) && !ignore) {
            if (!first)
              s += ",";
            first = false;
            if (array) {
              if (o[k] == void 0)
                s += "null";
              else
                s += stringify2(o[k]);
            } else if (o[k] !== void 0) {
              s += stringify2(k) + ":" + stringify2(o[k]);
            }
          }
        }
        s += array ? "]" : "}";
        return s;
      } else if ("string" === typeof o) {
        return JSON.stringify(/^:/.test(o) ? ":" + o : o);
      } else if ("undefined" === typeof o) {
        return "null";
      } else
        return JSON.stringify(o);
    };
    exports2.parse = function(s) {
      return JSON.parse(s, function(key, value) {
        if ("string" === typeof value) {
          if (/^:base64:/.test(value))
            return Buffer.from(value.substring(8), "base64");
          else
            return /^:/.test(value) ? value.substring(1) : value;
        }
        return value;
      });
    };
  }
});

// node_modules/keyv/src/index.js
var require_src3 = __commonJS2({
  "node_modules/keyv/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter4 = require("events");
    var JSONB = require_json_buffer();
    var loadStore = (options) => {
      const adapters = {
        redis: "@keyv/redis",
        rediss: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql",
        etcd: "@keyv/etcd",
        offline: "@keyv/offline",
        tiered: "@keyv/tiered"
      };
      if (options.adapter || options.uri) {
        const adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];
        return new (require(adapters[adapter]))(options);
      }
      return /* @__PURE__ */ new Map();
    };
    var iterableAdapters = [
      "sqlite",
      "postgres",
      "mysql",
      "mongo",
      "redis",
      "tiered"
    ];
    var Keyv2 = class extends EventEmitter4 {
      constructor(uri, { emitErrors = true, ...options } = {}) {
        super();
        this.opts = {
          namespace: "keyv",
          serialize: JSONB.stringify,
          deserialize: JSONB.parse,
          ...typeof uri === "string" ? { uri } : uri,
          ...options
        };
        if (!this.opts.store) {
          const adapterOptions = { ...this.opts };
          this.opts.store = loadStore(adapterOptions);
        }
        if (this.opts.compression) {
          const compression = this.opts.compression;
          this.opts.serialize = compression.serialize.bind(compression);
          this.opts.deserialize = compression.deserialize.bind(compression);
        }
        if (typeof this.opts.store.on === "function" && emitErrors) {
          this.opts.store.on("error", (error2) => this.emit("error", error2));
        }
        this.opts.store.namespace = this.opts.namespace;
        const generateIterator = (iterator) => async function* () {
          for await (const [key, raw2] of typeof iterator === "function" ? iterator(this.opts.store.namespace) : iterator) {
            const data = this.opts.deserialize(raw2);
            if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {
              continue;
            }
            if (typeof data.expires === "number" && Date.now() > data.expires) {
              this.delete(key);
              continue;
            }
            yield [this._getKeyUnprefix(key), data.value];
          }
        };
        if (typeof this.opts.store[Symbol.iterator] === "function" && this.opts.store instanceof Map) {
          this.iterator = generateIterator(this.opts.store);
        } else if (typeof this.opts.store.iterator === "function" && this.opts.store.opts && this._checkIterableAdaptar()) {
          this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
        }
      }
      _checkIterableAdaptar() {
        return iterableAdapters.includes(this.opts.store.opts.dialect) || iterableAdapters.findIndex((element) => this.opts.store.opts.url.includes(element)) >= 0;
      }
      _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
      }
      _getKeyPrefixArray(keys2) {
        return keys2.map((key) => `${this.opts.namespace}:${key}`);
      }
      _getKeyUnprefix(key) {
        return key.split(":").splice(1).join(":");
      }
      get(key, options) {
        const { store } = this.opts;
        const isArray3 = Array.isArray(key);
        const keyPrefixed = isArray3 ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
        if (isArray3 && store.getMany === void 0) {
          const promises = [];
          for (const key2 of keyPrefixed) {
            promises.push(
              Promise.resolve().then(() => store.get(key2)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
                if (data === void 0 || data === null) {
                  return void 0;
                }
                if (typeof data.expires === "number" && Date.now() > data.expires) {
                  return this.delete(key2).then(() => void 0);
                }
                return options && options.raw ? data : data.value;
              })
            );
          }
          return Promise.allSettled(promises).then((values) => {
            const data = [];
            for (const value of values) {
              data.push(value.value);
            }
            return data;
          });
        }
        return Promise.resolve().then(() => isArray3 ? store.getMany(keyPrefixed) : store.get(keyPrefixed)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
          if (data === void 0 || data === null) {
            return void 0;
          }
          if (isArray3) {
            const result = [];
            for (let row of data) {
              if (typeof row === "string") {
                row = this.opts.deserialize(row);
              }
              if (row === void 0 || row === null) {
                result.push(void 0);
                continue;
              }
              if (typeof row.expires === "number" && Date.now() > row.expires) {
                this.delete(key).then(() => void 0);
                result.push(void 0);
              } else {
                result.push(options && options.raw ? row : row.value);
              }
            }
            return result;
          }
          if (typeof data.expires === "number" && Date.now() > data.expires) {
            return this.delete(key).then(() => void 0);
          }
          return options && options.raw ? data : data.value;
        });
      }
      set(key, value, ttl2) {
        const keyPrefixed = this._getKeyPrefix(key);
        if (typeof ttl2 === "undefined") {
          ttl2 = this.opts.ttl;
        }
        if (ttl2 === 0) {
          ttl2 = void 0;
        }
        const { store } = this.opts;
        return Promise.resolve().then(() => {
          const expires = typeof ttl2 === "number" ? Date.now() + ttl2 : null;
          if (typeof value === "symbol") {
            this.emit("error", "symbol cannot be serialized");
          }
          value = { value, expires };
          return this.opts.serialize(value);
        }).then((value2) => store.set(keyPrefixed, value2, ttl2)).then(() => true);
      }
      delete(key) {
        const { store } = this.opts;
        if (Array.isArray(key)) {
          const keyPrefixed2 = this._getKeyPrefixArray(key);
          if (store.deleteMany === void 0) {
            const promises = [];
            for (const key2 of keyPrefixed2) {
              promises.push(store.delete(key2));
            }
            return Promise.allSettled(promises).then((values) => values.every((x) => x.value === true));
          }
          return Promise.resolve().then(() => store.deleteMany(keyPrefixed2));
        }
        const keyPrefixed = this._getKeyPrefix(key);
        return Promise.resolve().then(() => store.delete(keyPrefixed));
      }
      clear() {
        const { store } = this.opts;
        return Promise.resolve().then(() => store.clear());
      }
      has(key) {
        const keyPrefixed = this._getKeyPrefix(key);
        const { store } = this.opts;
        return Promise.resolve().then(async () => {
          if (typeof store.has === "function") {
            return store.has(keyPrefixed);
          }
          const value = await store.get(keyPrefixed);
          return value !== void 0;
        });
      }
      disconnect() {
        const { store } = this.opts;
        if (typeof store.disconnect === "function") {
          return store.disconnect();
        }
      }
    };
    module2.exports = Keyv2;
  }
});

// node_modules/mimic-response/index.js
var require_mimic_response = __commonJS2({
  "node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProperties3 = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module2.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties3));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value = fromStream[property];
            const isFunction4 = typeof value === "function";
            return isFunction4 ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  }
});

// node_modules/decompress-response/index.js
var require_decompress_response = __commonJS2({
  "node_modules/decompress-response/index.js"(exports2, module2) {
    "use strict";
    var { Transform, PassThrough } = require("stream");
    var zlib2 = require("zlib");
    var mimicResponse2 = require_mimic_response();
    module2.exports = (response) => {
      const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib2.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
      }
      let isEmpty = true;
      const checker = new Transform({
        transform(data, _encoding, callback) {
          isEmpty = false;
          callback(null, data);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough({
        autoDestroy: false,
        destroy(error2, callback) {
          response.destroy();
          callback(error2);
        }
      });
      const decompressStream = isBrotli ? zlib2.createBrotliDecompress() : zlib2.createUnzip();
      decompressStream.once("error", (error2) => {
        if (isEmpty && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error2);
      });
      mimicResponse2(response, finalStream);
      response.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  }
});

// node_modules/quick-lru/index.js
var require_quick_lru = __commonJS2({
  "node_modules/quick-lru/index.js"(exports2, module2) {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value2] of this.oldCache.entries()) {
              this.onEviction(key2, value2);
            }
          }
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module2.exports = QuickLRU;
  }
});

// node_modules/http2-wrapper/source/utils/delay-async-destroy.js
var require_delay_async_destroy = __commonJS2({
  "node_modules/http2-wrapper/source/utils/delay-async-destroy.js"(exports2, module2) {
    "use strict";
    module2.exports = (stream4) => {
      if (stream4.listenerCount("error") !== 0) {
        return stream4;
      }
      stream4.__destroy = stream4._destroy;
      stream4._destroy = (...args) => {
        const callback = args.pop();
        stream4.__destroy(...args, async (error2) => {
          await Promise.resolve();
          callback(error2);
        });
      };
      const onError = (error2) => {
        Promise.resolve().then(() => {
          stream4.emit("error", error2);
        });
      };
      stream4.once("error", onError);
      Promise.resolve().then(() => {
        stream4.off("error", onError);
      });
      return stream4;
    };
  }
});

// node_modules/http2-wrapper/source/agent.js
var require_agent2 = __commonJS2({
  "node_modules/http2-wrapper/source/agent.js"(exports2, module2) {
    "use strict";
    var { URL: URL4 } = require("url");
    var EventEmitter4 = require("events");
    var tls = require("tls");
    var http22 = require("http2");
    var QuickLRU = require_quick_lru();
    var delayAsyncDestroy = require_delay_async_destroy();
    var kCurrentStreamCount = Symbol("currentStreamCount");
    var kRequest = Symbol("request");
    var kOriginSet = Symbol("cachedOriginSet");
    var kGracefullyClosing = Symbol("gracefullyClosing");
    var kLength = Symbol("length");
    var nameKeys = [
      // Not an Agent option actually
      "createConnection",
      // `http2.connect()` options
      "maxDeflateDynamicTableSize",
      "maxSettings",
      "maxSessionMemory",
      "maxHeaderListPairs",
      "maxOutstandingPings",
      "maxReservedRemoteStreams",
      "maxSendHeaderBlockLength",
      "paddingStrategy",
      "peerMaxConcurrentStreams",
      "settings",
      // `tls.connect()` source options
      "family",
      "localAddress",
      "rejectUnauthorized",
      // `tls.connect()` secure context options
      "pskCallback",
      "minDHSize",
      // `tls.connect()` destination options
      // - `servername` is automatically validated, skip it
      // - `host` and `port` just describe the destination server,
      "path",
      "socket",
      // `tls.createSecureContext()` options
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "ticketKeys"
    ];
    var getSortedIndex = (array, value, compare) => {
      let low = 0;
      let high = array.length;
      while (low < high) {
        const mid = low + high >>> 1;
        if (compare(array[mid], value)) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    };
    var compareSessions = (a, b) => a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
    var closeCoveredSessions = (where, session) => {
      for (let index = 0; index < where.length; index++) {
        const coveredSession = where[index];
        if (
          // Unfortunately `.every()` returns true for an empty array
          coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams
        ) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var closeSessionIfCovered = (where, coveredSession) => {
      for (let index = 0; index < where.length; index++) {
        const session = where[index];
        if (coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
          return true;
        }
      }
      return false;
    };
    var gracefullyClose = (session) => {
      session[kGracefullyClosing] = true;
      if (session[kCurrentStreamCount] === 0) {
        session.close();
      }
    };
    var Agent = class extends EventEmitter4 {
      constructor({ timeout = 0, maxSessions = Number.POSITIVE_INFINITY, maxEmptySessions = 10, maxCachedTlsSessions = 100 } = {}) {
        super();
        this.sessions = {};
        this.queue = {};
        this.timeout = timeout;
        this.maxSessions = maxSessions;
        this.maxEmptySessions = maxEmptySessions;
        this._emptySessionCount = 0;
        this._sessionCount = 0;
        this.settings = {
          enablePush: false,
          initialWindowSize: 1024 * 1024 * 32
          // 32MB, see https://github.com/nodejs/node/issues/38426
        };
        this.tlsSessionCache = new QuickLRU({ maxSize: maxCachedTlsSessions });
      }
      get protocol() {
        return "https:";
      }
      normalizeOptions(options) {
        let normalized = "";
        for (let index = 0; index < nameKeys.length; index++) {
          const key = nameKeys[index];
          normalized += ":";
          if (options && options[key] !== void 0) {
            normalized += options[key];
          }
        }
        return normalized;
      }
      _processQueue() {
        if (this._sessionCount >= this.maxSessions) {
          this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);
          return;
        }
        for (const normalizedOptions in this.queue) {
          for (const normalizedOrigin in this.queue[normalizedOptions]) {
            const item = this.queue[normalizedOptions][normalizedOrigin];
            if (!item.completed) {
              item.completed = true;
              item();
            }
          }
        }
      }
      _isBetterSession(thisStreamCount, thatStreamCount) {
        return thisStreamCount > thatStreamCount;
      }
      _accept(session, listeners, normalizedOrigin, options) {
        let index = 0;
        while (index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams) {
          listeners[index].resolve(session);
          index++;
        }
        listeners.splice(0, index);
        if (listeners.length > 0) {
          this.getSession(normalizedOrigin, options, listeners);
          listeners.length = 0;
        }
      }
      getSession(origin, options, listeners) {
        return new Promise((resolve, reject) => {
          if (Array.isArray(listeners) && listeners.length > 0) {
            listeners = [...listeners];
            resolve();
          } else {
            listeners = [{ resolve, reject }];
          }
          try {
            if (typeof origin === "string") {
              origin = new URL4(origin);
            } else if (!(origin instanceof URL4)) {
              throw new TypeError("The `origin` argument needs to be a string or an URL object");
            }
            if (options) {
              const { servername } = options;
              const { hostname } = origin;
              if (servername && hostname !== servername) {
                throw new Error(`Origin ${hostname} differs from servername ${servername}`);
              }
            }
          } catch (error2) {
            for (let index = 0; index < listeners.length; index++) {
              listeners[index].reject(error2);
            }
            return;
          }
          const normalizedOptions = this.normalizeOptions(options);
          const normalizedOrigin = origin.origin;
          if (normalizedOptions in this.sessions) {
            const sessions = this.sessions[normalizedOptions];
            let maxConcurrentStreams = -1;
            let currentStreamsCount = -1;
            let optimalSession;
            for (let index = 0; index < sessions.length; index++) {
              const session = sessions[index];
              const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
              if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
                break;
              }
              if (!session[kOriginSet].includes(normalizedOrigin)) {
                continue;
              }
              const sessionCurrentStreamsCount = session[kCurrentStreamCount];
              if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || session.destroyed) {
                continue;
              }
              if (!optimalSession) {
                maxConcurrentStreams = sessionMaxConcurrentStreams;
              }
              if (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {
                optimalSession = session;
                currentStreamsCount = sessionCurrentStreamsCount;
              }
            }
            if (optimalSession) {
              this._accept(optimalSession, listeners, normalizedOrigin, options);
              return;
            }
          }
          if (normalizedOptions in this.queue) {
            if (normalizedOrigin in this.queue[normalizedOptions]) {
              this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
              return;
            }
          } else {
            this.queue[normalizedOptions] = {
              [kLength]: 0
            };
          }
          const removeFromQueue = () => {
            if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
              delete this.queue[normalizedOptions][normalizedOrigin];
              if (--this.queue[normalizedOptions][kLength] === 0) {
                delete this.queue[normalizedOptions];
              }
            }
          };
          const entry = async () => {
            this._sessionCount++;
            const name = `${normalizedOrigin}:${normalizedOptions}`;
            let receivedSettings = false;
            let socket;
            try {
              const computedOptions = { ...options };
              if (computedOptions.settings === void 0) {
                computedOptions.settings = this.settings;
              }
              if (computedOptions.session === void 0) {
                computedOptions.session = this.tlsSessionCache.get(name);
              }
              const createConnection = computedOptions.createConnection || this.createConnection;
              socket = await createConnection.call(this, origin, computedOptions);
              computedOptions.createConnection = () => socket;
              const session = http22.connect(origin, computedOptions);
              session[kCurrentStreamCount] = 0;
              session[kGracefullyClosing] = false;
              const getOriginSet = () => {
                const { socket: socket2 } = session;
                let originSet;
                if (socket2.servername === false) {
                  socket2.servername = socket2.remoteAddress;
                  originSet = session.originSet;
                  socket2.servername = false;
                } else {
                  originSet = session.originSet;
                }
                return originSet;
              };
              const isFree = () => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;
              session.socket.once("session", (tlsSession) => {
                this.tlsSessionCache.set(name, tlsSession);
              });
              session.once("error", (error2) => {
                for (let index = 0; index < listeners.length; index++) {
                  listeners[index].reject(error2);
                }
                this.tlsSessionCache.delete(name);
              });
              session.setTimeout(this.timeout, () => {
                session.destroy();
              });
              session.once("close", () => {
                this._sessionCount--;
                if (receivedSettings) {
                  this._emptySessionCount--;
                  const where = this.sessions[normalizedOptions];
                  if (where.length === 1) {
                    delete this.sessions[normalizedOptions];
                  } else {
                    where.splice(where.indexOf(session), 1);
                  }
                } else {
                  removeFromQueue();
                  const error2 = new Error("Session closed without receiving a SETTINGS frame");
                  error2.code = "HTTP2WRAPPER_NOSETTINGS";
                  for (let index = 0; index < listeners.length; index++) {
                    listeners[index].reject(error2);
                  }
                }
                this._processQueue();
              });
              const processListeners = () => {
                const queue = this.queue[normalizedOptions];
                if (!queue) {
                  return;
                }
                const originSet = session[kOriginSet];
                for (let index = 0; index < originSet.length; index++) {
                  const origin2 = originSet[index];
                  if (origin2 in queue) {
                    const { listeners: listeners2, completed } = queue[origin2];
                    let index2 = 0;
                    while (index2 < listeners2.length && isFree()) {
                      listeners2[index2].resolve(session);
                      index2++;
                    }
                    queue[origin2].listeners.splice(0, index2);
                    if (queue[origin2].listeners.length === 0 && !completed) {
                      delete queue[origin2];
                      if (--queue[kLength] === 0) {
                        delete this.queue[normalizedOptions];
                        break;
                      }
                    }
                    if (!isFree()) {
                      break;
                    }
                  }
                }
              };
              session.on("origin", () => {
                session[kOriginSet] = getOriginSet() || [];
                session[kGracefullyClosing] = false;
                closeSessionIfCovered(this.sessions[normalizedOptions], session);
                if (session[kGracefullyClosing] || !isFree()) {
                  return;
                }
                processListeners();
                if (!isFree()) {
                  return;
                }
                closeCoveredSessions(this.sessions[normalizedOptions], session);
              });
              session.once("remoteSettings", () => {
                if (entry.destroyed) {
                  const error2 = new Error("Agent has been destroyed");
                  for (let index = 0; index < listeners.length; index++) {
                    listeners[index].reject(error2);
                  }
                  session.destroy();
                  return;
                }
                if (session.setLocalWindowSize) {
                  session.setLocalWindowSize(1024 * 1024 * 4);
                }
                session[kOriginSet] = getOriginSet() || [];
                if (session.socket.encrypted) {
                  const mainOrigin = session[kOriginSet][0];
                  if (mainOrigin !== normalizedOrigin) {
                    const error2 = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);
                    for (let index = 0; index < listeners.length; index++) {
                      listeners[index].reject(error2);
                    }
                    session.destroy();
                    return;
                  }
                }
                removeFromQueue();
                {
                  const where = this.sessions;
                  if (normalizedOptions in where) {
                    const sessions = where[normalizedOptions];
                    sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
                  } else {
                    where[normalizedOptions] = [session];
                  }
                }
                receivedSettings = true;
                this._emptySessionCount++;
                this.emit("session", session);
                this._accept(session, listeners, normalizedOrigin, options);
                if (session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) {
                  this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);
                }
                session.on("remoteSettings", () => {
                  if (!isFree()) {
                    return;
                  }
                  processListeners();
                  if (!isFree()) {
                    return;
                  }
                  closeCoveredSessions(this.sessions[normalizedOptions], session);
                });
              });
              session[kRequest] = session.request;
              session.request = (headers, streamOptions) => {
                if (session[kGracefullyClosing]) {
                  throw new Error("The session is gracefully closing. No new streams are allowed.");
                }
                const stream4 = session[kRequest](headers, streamOptions);
                session.ref();
                if (session[kCurrentStreamCount]++ === 0) {
                  this._emptySessionCount--;
                }
                stream4.once("close", () => {
                  if (--session[kCurrentStreamCount] === 0) {
                    this._emptySessionCount++;
                    session.unref();
                    if (this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing]) {
                      session.close();
                      return;
                    }
                  }
                  if (session.destroyed || session.closed) {
                    return;
                  }
                  if (isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session)) {
                    closeCoveredSessions(this.sessions[normalizedOptions], session);
                    processListeners();
                    if (session[kCurrentStreamCount] === 0) {
                      this._processQueue();
                    }
                  }
                });
                return stream4;
              };
            } catch (error2) {
              removeFromQueue();
              this._sessionCount--;
              for (let index = 0; index < listeners.length; index++) {
                listeners[index].reject(error2);
              }
            }
          };
          entry.listeners = listeners;
          entry.completed = false;
          entry.destroyed = false;
          this.queue[normalizedOptions][normalizedOrigin] = entry;
          this.queue[normalizedOptions][kLength]++;
          this._processQueue();
        });
      }
      request(origin, options, headers, streamOptions) {
        return new Promise((resolve, reject) => {
          this.getSession(origin, options, [{
            reject,
            resolve: (session) => {
              try {
                const stream4 = session.request(headers, streamOptions);
                delayAsyncDestroy(stream4);
                resolve(stream4);
              } catch (error2) {
                reject(error2);
              }
            }
          }]);
        });
      }
      async createConnection(origin, options) {
        return Agent.connect(origin, options);
      }
      static connect(origin, options) {
        options.ALPNProtocols = ["h2"];
        const port = origin.port || 443;
        const host = origin.hostname;
        if (typeof options.servername === "undefined") {
          options.servername = host;
        }
        const socket = tls.connect(port, host, options);
        if (options.socket) {
          socket._peername = {
            family: void 0,
            address: void 0,
            port
          };
        }
        return socket;
      }
      closeEmptySessions(maxCount = Number.POSITIVE_INFINITY) {
        let closedCount = 0;
        const { sessions } = this;
        for (const key in sessions) {
          const thisSessions = sessions[key];
          for (let index = 0; index < thisSessions.length; index++) {
            const session = thisSessions[index];
            if (session[kCurrentStreamCount] === 0) {
              closedCount++;
              session.close();
              if (closedCount >= maxCount) {
                return closedCount;
              }
            }
          }
        }
        return closedCount;
      }
      destroy(reason) {
        const { sessions, queue } = this;
        for (const key in sessions) {
          const thisSessions = sessions[key];
          for (let index = 0; index < thisSessions.length; index++) {
            thisSessions[index].destroy(reason);
          }
        }
        for (const normalizedOptions in queue) {
          const entries2 = queue[normalizedOptions];
          for (const normalizedOrigin in entries2) {
            entries2[normalizedOrigin].destroyed = true;
          }
        }
        this.queue = {};
        this.tlsSessionCache.clear();
      }
      get emptySessionCount() {
        return this._emptySessionCount;
      }
      get pendingSessionCount() {
        return this._sessionCount - this._emptySessionCount;
      }
      get sessionCount() {
        return this._sessionCount;
      }
    };
    Agent.kCurrentStreamCount = kCurrentStreamCount;
    Agent.kGracefullyClosing = kGracefullyClosing;
    module2.exports = {
      Agent,
      globalAgent: new Agent()
    };
  }
});

// node_modules/http2-wrapper/source/incoming-message.js
var require_incoming_message = __commonJS2({
  "node_modules/http2-wrapper/source/incoming-message.js"(exports2, module2) {
    "use strict";
    var { Readable } = require("stream");
    var IncomingMessage = class extends Readable {
      constructor(socket, highWaterMark) {
        super({
          emitClose: false,
          autoDestroy: true,
          highWaterMark
        });
        this.statusCode = null;
        this.statusMessage = "";
        this.httpVersion = "2.0";
        this.httpVersionMajor = 2;
        this.httpVersionMinor = 0;
        this.headers = {};
        this.trailers = {};
        this.req = null;
        this.aborted = false;
        this.complete = false;
        this.upgrade = null;
        this.rawHeaders = [];
        this.rawTrailers = [];
        this.socket = socket;
        this._dumped = false;
      }
      get connection() {
        return this.socket;
      }
      set connection(value) {
        this.socket = value;
      }
      _destroy(error2, callback) {
        if (!this.readableEnded) {
          this.aborted = true;
        }
        callback();
        this.req._request.destroy(error2);
      }
      setTimeout(ms, callback) {
        this.req.setTimeout(ms, callback);
        return this;
      }
      _dump() {
        if (!this._dumped) {
          this._dumped = true;
          this.removeAllListeners("data");
          this.resume();
        }
      }
      _read() {
        if (this.req) {
          this.req._request.resume();
        }
      }
    };
    module2.exports = IncomingMessage;
  }
});

// node_modules/http2-wrapper/source/utils/proxy-events.js
var require_proxy_events = __commonJS2({
  "node_modules/http2-wrapper/source/utils/proxy-events.js"(exports2, module2) {
    "use strict";
    module2.exports = (from, to, events) => {
      for (const event of events) {
        from.on(event, (...args) => to.emit(event, ...args));
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/errors.js
var require_errors2 = __commonJS2({
  "node_modules/http2-wrapper/source/utils/errors.js"(exports2, module2) {
    "use strict";
    var makeError = (Base, key, getMessage2) => {
      module2.exports[key] = class NodeError extends Base {
        constructor(...args) {
          super(typeof getMessage2 === "string" ? getMessage2 : getMessage2(args));
          this.name = `${super.name} [${key}]`;
          this.code = key;
        }
      };
    };
    makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
      const type = args[0].includes(".") ? "property" : "argument";
      let valid = args[1];
      const isManyTypes = Array.isArray(valid);
      if (isManyTypes) {
        valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
      }
      return `The "${args[0]}" ${type} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
    });
    makeError(
      TypeError,
      "ERR_INVALID_PROTOCOL",
      (args) => `Protocol "${args[0]}" not supported. Expected "${args[1]}"`
    );
    makeError(
      Error,
      "ERR_HTTP_HEADERS_SENT",
      (args) => `Cannot ${args[0]} headers after they are sent to the client`
    );
    makeError(
      TypeError,
      "ERR_INVALID_HTTP_TOKEN",
      (args) => `${args[0]} must be a valid HTTP token [${args[1]}]`
    );
    makeError(
      TypeError,
      "ERR_HTTP_INVALID_HEADER_VALUE",
      (args) => `Invalid value "${args[0]} for header "${args[1]}"`
    );
    makeError(
      TypeError,
      "ERR_INVALID_CHAR",
      (args) => `Invalid character in ${args[0]} [${args[1]}]`
    );
    makeError(
      Error,
      "ERR_HTTP2_NO_SOCKET_MANIPULATION",
      "HTTP/2 sockets should not be directly manipulated (e.g. read and written)"
    );
  }
});

// node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js
var require_is_request_pseudo_header = __commonJS2({
  "node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js"(exports2, module2) {
    "use strict";
    module2.exports = (header) => {
      switch (header) {
        case ":method":
        case ":scheme":
        case ":authority":
        case ":path":
          return true;
        default:
          return false;
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/validate-header-name.js
var require_validate_header_name = __commonJS2({
  "node_modules/http2-wrapper/source/utils/validate-header-name.js"(exports2, module2) {
    "use strict";
    var { ERR_INVALID_HTTP_TOKEN } = require_errors2();
    var isRequestPseudoHeader = require_is_request_pseudo_header();
    var isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
    module2.exports = (name) => {
      if (typeof name !== "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
        throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/validate-header-value.js
var require_validate_header_value = __commonJS2({
  "node_modules/http2-wrapper/source/utils/validate-header-value.js"(exports2, module2) {
    "use strict";
    var {
      ERR_HTTP_INVALID_HEADER_VALUE,
      ERR_INVALID_CHAR
    } = require_errors2();
    var isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
    module2.exports = (name, value) => {
      if (typeof value === "undefined") {
        throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
      }
      if (isInvalidHeaderValue.test(value)) {
        throw new ERR_INVALID_CHAR("header content", name);
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/proxy-socket-handler.js
var require_proxy_socket_handler = __commonJS2({
  "node_modules/http2-wrapper/source/utils/proxy-socket-handler.js"(exports2, module2) {
    "use strict";
    var { ERR_HTTP2_NO_SOCKET_MANIPULATION } = require_errors2();
    var proxySocketHandler = {
      has(stream4, property) {
        const reference = stream4.session === void 0 ? stream4 : stream4.session.socket;
        return property in stream4 || property in reference;
      },
      get(stream4, property) {
        switch (property) {
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            return stream4[property].bind(stream4);
          case "writable":
          case "destroyed":
            return stream4[property];
          case "readable":
            if (stream4.destroyed) {
              return false;
            }
            return stream4.readable;
          case "setTimeout": {
            const { session } = stream4;
            if (session !== void 0) {
              return session.setTimeout.bind(session);
            }
            return stream4.setTimeout.bind(stream4);
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
          default: {
            const reference = stream4.session === void 0 ? stream4 : stream4.session.socket;
            const value = reference[property];
            return typeof value === "function" ? value.bind(reference) : value;
          }
        }
      },
      getPrototypeOf(stream4) {
        if (stream4.session !== void 0) {
          return Reflect.getPrototypeOf(stream4.session.socket);
        }
        return Reflect.getPrototypeOf(stream4);
      },
      set(stream4, property, value) {
        switch (property) {
          case "writable":
          case "readable":
          case "destroyed":
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            stream4[property] = value;
            return true;
          case "setTimeout": {
            const { session } = stream4;
            if (session === void 0) {
              stream4.setTimeout = value;
            } else {
              session.setTimeout = value;
            }
            return true;
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
          default: {
            const reference = stream4.session === void 0 ? stream4 : stream4.session.socket;
            reference[property] = value;
            return true;
          }
        }
      }
    };
    module2.exports = proxySocketHandler;
  }
});

// node_modules/http2-wrapper/source/client-request.js
var require_client_request = __commonJS2({
  "node_modules/http2-wrapper/source/client-request.js"(exports2, module2) {
    "use strict";
    var { URL: URL4, urlToHttpOptions } = require("url");
    var http22 = require("http2");
    var { Writable } = require("stream");
    var { Agent, globalAgent } = require_agent2();
    var IncomingMessage = require_incoming_message();
    var proxyEvents2 = require_proxy_events();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_PROTOCOL,
      ERR_HTTP_HEADERS_SENT
    } = require_errors2();
    var validateHeaderName = require_validate_header_name();
    var validateHeaderValue = require_validate_header_value();
    var proxySocketHandler = require_proxy_socket_handler();
    var {
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_AUTHORITY,
      HTTP2_METHOD_CONNECT
    } = http22.constants;
    var kHeaders = Symbol("headers");
    var kOrigin = Symbol("origin");
    var kSession = Symbol("session");
    var kOptions = Symbol("options");
    var kFlushedHeaders = Symbol("flushedHeaders");
    var kJobs = Symbol("jobs");
    var kPendingAgentPromise = Symbol("pendingAgentPromise");
    var ClientRequest = class extends Writable {
      constructor(input, options, callback) {
        super({
          autoDestroy: false,
          emitClose: false
        });
        if (typeof input === "string") {
          input = urlToHttpOptions(new URL4(input));
        } else if (input instanceof URL4) {
          input = urlToHttpOptions(input);
        } else {
          input = { ...input };
        }
        if (typeof options === "function" || options === void 0) {
          callback = options;
          options = input;
        } else {
          options = Object.assign(input, options);
        }
        if (options.h2session) {
          this[kSession] = options.h2session;
          if (this[kSession].destroyed) {
            throw new Error("The session has been closed already");
          }
          this.protocol = this[kSession].socket.encrypted ? "https:" : "http:";
        } else if (options.agent === false) {
          this.agent = new Agent({ maxEmptySessions: 0 });
        } else if (typeof options.agent === "undefined" || options.agent === null) {
          this.agent = globalAgent;
        } else if (typeof options.agent.request === "function") {
          this.agent = options.agent;
        } else {
          throw new ERR_INVALID_ARG_TYPE("options.agent", ["http2wrapper.Agent-like Object", "undefined", "false"], options.agent);
        }
        if (this.agent) {
          this.protocol = this.agent.protocol;
        }
        if (options.protocol && options.protocol !== this.protocol) {
          throw new ERR_INVALID_PROTOCOL(options.protocol, this.protocol);
        }
        if (!options.port) {
          options.port = options.defaultPort || this.agent && this.agent.defaultPort || 443;
        }
        options.host = options.hostname || options.host || "localhost";
        delete options.hostname;
        const { timeout } = options;
        options.timeout = void 0;
        this[kHeaders] = /* @__PURE__ */ Object.create(null);
        this[kJobs] = [];
        this[kPendingAgentPromise] = void 0;
        this.socket = null;
        this.connection = null;
        this.method = options.method || "GET";
        if (!(this.method === "CONNECT" && (options.path === "/" || options.path === void 0))) {
          this.path = options.path;
        }
        this.res = null;
        this.aborted = false;
        this.reusedSocket = false;
        const { headers } = options;
        if (headers) {
          for (const header in headers) {
            this.setHeader(header, headers[header]);
          }
        }
        if (options.auth && !("authorization" in this[kHeaders])) {
          this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
        }
        options.session = options.tlsSession;
        options.path = options.socketPath;
        this[kOptions] = options;
        this[kOrigin] = new URL4(`${this.protocol}//${options.servername || options.host}:${options.port}`);
        const reuseSocket = options._reuseSocket;
        if (reuseSocket) {
          options.createConnection = (...args) => {
            if (reuseSocket.destroyed) {
              return this.agent.createConnection(...args);
            }
            return reuseSocket;
          };
          this.agent.getSession(this[kOrigin], this[kOptions]).catch(() => {
          });
        }
        if (timeout) {
          this.setTimeout(timeout);
        }
        if (callback) {
          this.once("response", callback);
        }
        this[kFlushedHeaders] = false;
      }
      get method() {
        return this[kHeaders][HTTP2_HEADER_METHOD];
      }
      set method(value) {
        if (value) {
          this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
        }
      }
      get path() {
        const header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
        return this[kHeaders][header];
      }
      set path(value) {
        if (value) {
          const header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
          this[kHeaders][header] = value;
        }
      }
      get host() {
        return this[kOrigin].hostname;
      }
      set host(_value) {
      }
      get _mustNotHaveABody() {
        return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
      }
      _write(chunk, encoding, callback) {
        if (this._mustNotHaveABody) {
          callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
          return;
        }
        this.flushHeaders();
        const callWrite = () => this._request.write(chunk, encoding, callback);
        if (this._request) {
          callWrite();
        } else {
          this[kJobs].push(callWrite);
        }
      }
      _final(callback) {
        this.flushHeaders();
        const callEnd = () => {
          if (this._mustNotHaveABody || this.method === "CONNECT") {
            callback();
            return;
          }
          this._request.end(callback);
        };
        if (this._request) {
          callEnd();
        } else {
          this[kJobs].push(callEnd);
        }
      }
      abort() {
        if (this.res && this.res.complete) {
          return;
        }
        if (!this.aborted) {
          process.nextTick(() => this.emit("abort"));
        }
        this.aborted = true;
        this.destroy();
      }
      async _destroy(error2, callback) {
        if (this.res) {
          this.res._dump();
        }
        if (this._request) {
          this._request.destroy();
        } else {
          process.nextTick(() => {
            this.emit("close");
          });
        }
        try {
          await this[kPendingAgentPromise];
        } catch (internalError) {
          if (this.aborted) {
            error2 = internalError;
          }
        }
        callback(error2);
      }
      async flushHeaders() {
        if (this[kFlushedHeaders] || this.destroyed) {
          return;
        }
        this[kFlushedHeaders] = true;
        const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;
        const onStream = (stream4) => {
          this._request = stream4;
          if (this.destroyed) {
            stream4.destroy();
            return;
          }
          if (!isConnectMethod) {
            proxyEvents2(stream4, this, ["timeout", "continue"]);
          }
          stream4.once("error", (error2) => {
            this.destroy(error2);
          });
          stream4.once("aborted", () => {
            const { res } = this;
            if (res) {
              res.aborted = true;
              res.emit("aborted");
              res.destroy();
            } else {
              this.destroy(new Error("The server aborted the HTTP/2 stream"));
            }
          });
          const onResponse = (headers, flags, rawHeaders) => {
            const response = new IncomingMessage(this.socket, stream4.readableHighWaterMark);
            this.res = response;
            response.url = `${this[kOrigin].origin}${this.path}`;
            response.req = this;
            response.statusCode = headers[HTTP2_HEADER_STATUS];
            response.headers = headers;
            response.rawHeaders = rawHeaders;
            response.once("end", () => {
              response.complete = true;
              response.socket = null;
              response.connection = null;
            });
            if (isConnectMethod) {
              response.upgrade = true;
              if (this.emit("connect", response, stream4, Buffer.alloc(0))) {
                this.emit("close");
              } else {
                stream4.destroy();
              }
            } else {
              stream4.on("data", (chunk) => {
                if (!response._dumped && !response.push(chunk)) {
                  stream4.pause();
                }
              });
              stream4.once("end", () => {
                if (!this.aborted) {
                  response.push(null);
                }
              });
              if (!this.emit("response", response)) {
                response._dump();
              }
            }
          };
          stream4.once("response", onResponse);
          stream4.once("headers", (headers) => this.emit("information", { statusCode: headers[HTTP2_HEADER_STATUS] }));
          stream4.once("trailers", (trailers, flags, rawTrailers) => {
            const { res } = this;
            if (res === null) {
              onResponse(trailers, flags, rawTrailers);
              return;
            }
            res.trailers = trailers;
            res.rawTrailers = rawTrailers;
          });
          stream4.once("close", () => {
            const { aborted, res } = this;
            if (res) {
              if (aborted) {
                res.aborted = true;
                res.emit("aborted");
                res.destroy();
              }
              const finish = () => {
                res.emit("close");
                this.destroy();
                this.emit("close");
              };
              if (res.readable) {
                res.once("end", finish);
              } else {
                finish();
              }
              return;
            }
            if (!this.destroyed) {
              this.destroy(new Error("The HTTP/2 stream has been early terminated"));
              this.emit("close");
              return;
            }
            this.destroy();
            this.emit("close");
          });
          this.socket = new Proxy(stream4, proxySocketHandler);
          for (const job of this[kJobs]) {
            job();
          }
          this[kJobs].length = 0;
          this.emit("socket", this.socket);
        };
        if (!(HTTP2_HEADER_AUTHORITY in this[kHeaders]) && !isConnectMethod) {
          this[kHeaders][HTTP2_HEADER_AUTHORITY] = this[kOrigin].host;
        }
        if (this[kSession]) {
          try {
            onStream(this[kSession].request(this[kHeaders]));
          } catch (error2) {
            this.destroy(error2);
          }
        } else {
          this.reusedSocket = true;
          try {
            const promise = this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]);
            this[kPendingAgentPromise] = promise;
            onStream(await promise);
            this[kPendingAgentPromise] = false;
          } catch (error2) {
            this[kPendingAgentPromise] = false;
            this.destroy(error2);
          }
        }
      }
      get connection() {
        return this.socket;
      }
      set connection(value) {
        this.socket = value;
      }
      getHeaderNames() {
        return Object.keys(this[kHeaders]);
      }
      hasHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return Boolean(this[kHeaders][name.toLowerCase()]);
      }
      getHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return this[kHeaders][name.toLowerCase()];
      }
      get headersSent() {
        return this[kFlushedHeaders];
      }
      removeHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("remove");
        }
        delete this[kHeaders][name.toLowerCase()];
      }
      setHeader(name, value) {
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("set");
        }
        validateHeaderName(name);
        validateHeaderValue(name, value);
        const lowercased = name.toLowerCase();
        if (lowercased === "connection") {
          if (value.toLowerCase() === "keep-alive") {
            return;
          }
          throw new Error(`Invalid 'connection' header: ${value}`);
        }
        if (lowercased === "host" && this.method === "CONNECT") {
          this[kHeaders][HTTP2_HEADER_AUTHORITY] = value;
        } else {
          this[kHeaders][lowercased] = value;
        }
      }
      setNoDelay() {
      }
      setSocketKeepAlive() {
      }
      setTimeout(ms, callback) {
        const applyTimeout = () => this._request.setTimeout(ms, callback);
        if (this._request) {
          applyTimeout();
        } else {
          this[kJobs].push(applyTimeout);
        }
        return this;
      }
      get maxHeadersCount() {
        if (!this.destroyed && this._request) {
          return this._request.session.localSettings.maxHeaderListSize;
        }
        return void 0;
      }
      set maxHeadersCount(_value) {
      }
    };
    module2.exports = ClientRequest;
  }
});

// node_modules/resolve-alpn/index.js
var require_resolve_alpn = __commonJS2({
  "node_modules/resolve-alpn/index.js"(exports2, module2) {
    "use strict";
    var tls = require("tls");
    module2.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
      let timeout = false;
      let socket;
      const callback = async () => {
        await socketPromise;
        socket.off("timeout", onTimeout);
        socket.off("error", reject);
        if (options.resolveSocket) {
          resolve({ alpnProtocol: socket.alpnProtocol, socket, timeout });
          if (timeout) {
            await Promise.resolve();
            socket.emit("timeout");
          }
        } else {
          socket.destroy();
          resolve({ alpnProtocol: socket.alpnProtocol, timeout });
        }
      };
      const onTimeout = async () => {
        timeout = true;
        callback();
      };
      const socketPromise = (async () => {
        try {
          socket = await connect(options, callback);
          socket.on("error", reject);
          socket.once("timeout", onTimeout);
        } catch (error2) {
          reject(error2);
        }
      })();
    });
  }
});

// node_modules/http2-wrapper/source/utils/calculate-server-name.js
var require_calculate_server_name = __commonJS2({
  "node_modules/http2-wrapper/source/utils/calculate-server-name.js"(exports2, module2) {
    "use strict";
    var { isIP } = require("net");
    var assert2 = require("assert");
    var getHost = (host) => {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert2(idx2 !== -1);
        return host.slice(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) {
        return host;
      }
      return host.slice(0, idx);
    };
    module2.exports = (host) => {
      const servername = getHost(host);
      if (isIP(servername)) {
        return "";
      }
      return servername;
    };
  }
});

// node_modules/http2-wrapper/source/auto.js
var require_auto = __commonJS2({
  "node_modules/http2-wrapper/source/auto.js"(exports2, module2) {
    "use strict";
    var { URL: URL4, urlToHttpOptions } = require("url");
    var http4 = require("http");
    var https3 = require("https");
    var resolveALPN = require_resolve_alpn();
    var QuickLRU = require_quick_lru();
    var { Agent, globalAgent } = require_agent2();
    var Http2ClientRequest = require_client_request();
    var calculateServerName = require_calculate_server_name();
    var delayAsyncDestroy = require_delay_async_destroy();
    var cache = new QuickLRU({ maxSize: 100 });
    var queue = /* @__PURE__ */ new Map();
    var installSocket = (agent, socket, options) => {
      socket._httpMessage = { shouldKeepAlive: true };
      const onFree = () => {
        agent.emit("free", socket, options);
      };
      socket.on("free", onFree);
      const onClose = () => {
        agent.removeSocket(socket, options);
      };
      socket.on("close", onClose);
      const onTimeout = () => {
        const { freeSockets } = agent;
        for (const sockets of Object.values(freeSockets)) {
          if (sockets.includes(socket)) {
            socket.destroy();
            return;
          }
        }
      };
      socket.on("timeout", onTimeout);
      const onRemove = () => {
        agent.removeSocket(socket, options);
        socket.off("close", onClose);
        socket.off("free", onFree);
        socket.off("timeout", onTimeout);
        socket.off("agentRemove", onRemove);
      };
      socket.on("agentRemove", onRemove);
      agent.emit("free", socket, options);
    };
    var createResolveProtocol = (cache2, queue2 = /* @__PURE__ */ new Map(), connect = void 0) => {
      return async (options) => {
        const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
        if (!cache2.has(name)) {
          if (queue2.has(name)) {
            const result = await queue2.get(name);
            return { alpnProtocol: result.alpnProtocol };
          }
          const { path: path2 } = options;
          options.path = options.socketPath;
          const resultPromise = resolveALPN(options, connect);
          queue2.set(name, resultPromise);
          try {
            const result = await resultPromise;
            cache2.set(name, result.alpnProtocol);
            queue2.delete(name);
            options.path = path2;
            return result;
          } catch (error2) {
            queue2.delete(name);
            options.path = path2;
            throw error2;
          }
        }
        return { alpnProtocol: cache2.get(name) };
      };
    };
    var defaultResolveProtocol = createResolveProtocol(cache, queue);
    module2.exports = async (input, options, callback) => {
      if (typeof input === "string") {
        input = urlToHttpOptions(new URL4(input));
      } else if (input instanceof URL4) {
        input = urlToHttpOptions(input);
      } else {
        input = { ...input };
      }
      if (typeof options === "function" || options === void 0) {
        callback = options;
        options = input;
      } else {
        options = Object.assign(input, options);
      }
      options.ALPNProtocols = options.ALPNProtocols || ["h2", "http/1.1"];
      if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
        throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
      }
      options.protocol = options.protocol || "https:";
      const isHttps2 = options.protocol === "https:";
      options.host = options.hostname || options.host || "localhost";
      options.session = options.tlsSession;
      options.servername = options.servername || calculateServerName(options.headers && options.headers.host || options.host);
      options.port = options.port || (isHttps2 ? 443 : 80);
      options._defaultAgent = isHttps2 ? https3.globalAgent : http4.globalAgent;
      const resolveProtocol = options.resolveProtocol || defaultResolveProtocol;
      let { agent } = options;
      if (agent !== void 0 && agent !== false && agent.constructor.name !== "Object") {
        throw new Error("The `options.agent` can be only an object `http`, `https` or `http2` properties");
      }
      if (isHttps2) {
        options.resolveSocket = true;
        let { socket, alpnProtocol, timeout } = await resolveProtocol(options);
        if (timeout) {
          if (socket) {
            socket.destroy();
          }
          const error2 = new Error(`Timed out resolving ALPN: ${options.timeout} ms`);
          error2.code = "ETIMEDOUT";
          error2.ms = options.timeout;
          throw error2;
        }
        if (socket && options.createConnection) {
          socket.destroy();
          socket = void 0;
        }
        delete options.resolveSocket;
        const isHttp2 = alpnProtocol === "h2";
        if (agent) {
          agent = isHttp2 ? agent.http2 : agent.https;
          options.agent = agent;
        }
        if (agent === void 0) {
          agent = isHttp2 ? globalAgent : https3.globalAgent;
        }
        if (socket) {
          if (agent === false) {
            socket.destroy();
          } else {
            const defaultCreateConnection = (isHttp2 ? Agent : https3.Agent).prototype.createConnection;
            if (agent.createConnection === defaultCreateConnection) {
              if (isHttp2) {
                options._reuseSocket = socket;
              } else {
                installSocket(agent, socket, options);
              }
            } else {
              socket.destroy();
            }
          }
        }
        if (isHttp2) {
          return delayAsyncDestroy(new Http2ClientRequest(options, callback));
        }
      } else if (agent) {
        options.agent = agent.http;
      }
      return delayAsyncDestroy(http4.request(options, callback));
    };
    module2.exports.protocolCache = cache;
    module2.exports.resolveProtocol = defaultResolveProtocol;
    module2.exports.createResolveProtocol = createResolveProtocol;
  }
});

// node_modules/http2-wrapper/source/utils/js-stream-socket.js
var require_js_stream_socket = __commonJS2({
  "node_modules/http2-wrapper/source/utils/js-stream-socket.js"(exports2, module2) {
    "use strict";
    var stream4 = require("stream");
    var tls = require("tls");
    var JSStreamSocket = new tls.TLSSocket(new stream4.PassThrough())._handle._parentWrap.constructor;
    module2.exports = JSStreamSocket;
  }
});

// node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js
var require_unexpected_status_code_error = __commonJS2({
  "node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js"(exports2, module2) {
    "use strict";
    var UnexpectedStatusCodeError = class extends Error {
      constructor(statusCode, statusMessage = "") {
        super(`The proxy server rejected the request with status code ${statusCode} (${statusMessage || "empty status message"})`);
        this.statusCode = statusCode;
        this.statusMessage = statusMessage;
      }
    };
    module2.exports = UnexpectedStatusCodeError;
  }
});

// node_modules/http2-wrapper/source/utils/check-type.js
var require_check_type = __commonJS2({
  "node_modules/http2-wrapper/source/utils/check-type.js"(exports2, module2) {
    "use strict";
    var checkType = (name, value, types2) => {
      const valid = types2.some((type) => {
        const typeofType = typeof type;
        if (typeofType === "string") {
          return typeof value === type;
        }
        return value instanceof type;
      });
      if (!valid) {
        const names = types2.map((type) => typeof type === "string" ? type : type.name);
        throw new TypeError(`Expected '${name}' to be a type of ${names.join(" or ")}, got ${typeof value}`);
      }
    };
    module2.exports = checkType;
  }
});

// node_modules/http2-wrapper/source/proxies/initialize.js
var require_initialize = __commonJS2({
  "node_modules/http2-wrapper/source/proxies/initialize.js"(exports2, module2) {
    "use strict";
    var { URL: URL4 } = require("url");
    var checkType = require_check_type();
    module2.exports = (self2, proxyOptions) => {
      checkType("proxyOptions", proxyOptions, ["object"]);
      checkType("proxyOptions.headers", proxyOptions.headers, ["object", "undefined"]);
      checkType("proxyOptions.raw", proxyOptions.raw, ["boolean", "undefined"]);
      checkType("proxyOptions.url", proxyOptions.url, [URL4, "string"]);
      const url2 = new URL4(proxyOptions.url);
      self2.proxyOptions = {
        raw: true,
        ...proxyOptions,
        headers: { ...proxyOptions.headers },
        url: url2
      };
    };
  }
});

// node_modules/http2-wrapper/source/proxies/get-auth-headers.js
var require_get_auth_headers = __commonJS2({
  "node_modules/http2-wrapper/source/proxies/get-auth-headers.js"(exports2, module2) {
    "use strict";
    module2.exports = (self2) => {
      const { username, password } = self2.proxyOptions.url;
      if (username || password) {
        const data = `${username}:${password}`;
        const authorization = `Basic ${Buffer.from(data).toString("base64")}`;
        return {
          "proxy-authorization": authorization,
          authorization
        };
      }
      return {};
    };
  }
});

// node_modules/http2-wrapper/source/proxies/h1-over-h2.js
var require_h1_over_h2 = __commonJS2({
  "node_modules/http2-wrapper/source/proxies/h1-over-h2.js"(exports2, module2) {
    "use strict";
    var tls = require("tls");
    var http4 = require("http");
    var https3 = require("https");
    var JSStreamSocket = require_js_stream_socket();
    var { globalAgent } = require_agent2();
    var UnexpectedStatusCodeError = require_unexpected_status_code_error();
    var initialize = require_initialize();
    var getAuthorizationHeaders = require_get_auth_headers();
    var createConnection = (self2, options, callback) => {
      (async () => {
        try {
          const { proxyOptions } = self2;
          const { url: url2, headers, raw: raw2 } = proxyOptions;
          const stream4 = await globalAgent.request(url2, proxyOptions, {
            ...getAuthorizationHeaders(self2),
            ...headers,
            ":method": "CONNECT",
            ":authority": `${options.host}:${options.port}`
          });
          stream4.once("error", callback);
          stream4.once("response", (headers2) => {
            const statusCode = headers2[":status"];
            if (statusCode !== 200) {
              callback(new UnexpectedStatusCodeError(statusCode, ""));
              return;
            }
            const encrypted = self2 instanceof https3.Agent;
            if (raw2 && encrypted) {
              options.socket = stream4;
              const secureStream = tls.connect(options);
              secureStream.once("close", () => {
                stream4.destroy();
              });
              callback(null, secureStream);
              return;
            }
            const socket = new JSStreamSocket(stream4);
            socket.encrypted = false;
            socket._handle.getpeername = (out) => {
              out.family = void 0;
              out.address = void 0;
              out.port = void 0;
            };
            callback(null, socket);
          });
        } catch (error2) {
          callback(error2);
        }
      })();
    };
    var HttpOverHttp2 = class extends http4.Agent {
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      createConnection(options, callback) {
        createConnection(this, options, callback);
      }
    };
    var HttpsOverHttp2 = class extends https3.Agent {
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      createConnection(options, callback) {
        createConnection(this, options, callback);
      }
    };
    module2.exports = {
      HttpOverHttp2,
      HttpsOverHttp2
    };
  }
});

// node_modules/http2-wrapper/source/proxies/h2-over-hx.js
var require_h2_over_hx = __commonJS2({
  "node_modules/http2-wrapper/source/proxies/h2-over-hx.js"(exports2, module2) {
    "use strict";
    var { Agent } = require_agent2();
    var JSStreamSocket = require_js_stream_socket();
    var UnexpectedStatusCodeError = require_unexpected_status_code_error();
    var initialize = require_initialize();
    var Http2OverHttpX = class extends Agent {
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      async createConnection(origin, options) {
        const authority = `${origin.hostname}:${origin.port || 443}`;
        const [stream4, statusCode, statusMessage] = await this._getProxyStream(authority);
        if (statusCode !== 200) {
          throw new UnexpectedStatusCodeError(statusCode, statusMessage);
        }
        if (this.proxyOptions.raw) {
          options.socket = stream4;
        } else {
          const socket = new JSStreamSocket(stream4);
          socket.encrypted = false;
          socket._handle.getpeername = (out) => {
            out.family = void 0;
            out.address = void 0;
            out.port = void 0;
          };
          return socket;
        }
        return super.createConnection(origin, options);
      }
    };
    module2.exports = Http2OverHttpX;
  }
});

// node_modules/http2-wrapper/source/proxies/h2-over-h2.js
var require_h2_over_h2 = __commonJS2({
  "node_modules/http2-wrapper/source/proxies/h2-over-h2.js"(exports2, module2) {
    "use strict";
    var { globalAgent } = require_agent2();
    var Http2OverHttpX = require_h2_over_hx();
    var getAuthorizationHeaders = require_get_auth_headers();
    var getStatusCode = (stream4) => new Promise((resolve, reject) => {
      stream4.once("error", reject);
      stream4.once("response", (headers) => {
        stream4.off("error", reject);
        resolve(headers[":status"]);
      });
    });
    var Http2OverHttp2 = class extends Http2OverHttpX {
      async _getProxyStream(authority) {
        const { proxyOptions } = this;
        const headers = {
          ...getAuthorizationHeaders(this),
          ...proxyOptions.headers,
          ":method": "CONNECT",
          ":authority": authority
        };
        const stream4 = await globalAgent.request(proxyOptions.url, proxyOptions, headers);
        const statusCode = await getStatusCode(stream4);
        return [stream4, statusCode, ""];
      }
    };
    module2.exports = Http2OverHttp2;
  }
});

// node_modules/http2-wrapper/source/proxies/h2-over-h1.js
var require_h2_over_h1 = __commonJS2({
  "node_modules/http2-wrapper/source/proxies/h2-over-h1.js"(exports2, module2) {
    "use strict";
    var http4 = require("http");
    var https3 = require("https");
    var Http2OverHttpX = require_h2_over_hx();
    var getAuthorizationHeaders = require_get_auth_headers();
    var getStream2 = (request2) => new Promise((resolve, reject) => {
      const onConnect = (response, socket, head) => {
        socket.unshift(head);
        request2.off("error", reject);
        resolve([socket, response.statusCode, response.statusMessage]);
      };
      request2.once("error", reject);
      request2.once("connect", onConnect);
    });
    var Http2OverHttp = class extends Http2OverHttpX {
      async _getProxyStream(authority) {
        const { proxyOptions } = this;
        const { url: url2, headers } = this.proxyOptions;
        const network = url2.protocol === "https:" ? https3 : http4;
        const request2 = network.request({
          ...proxyOptions,
          hostname: url2.hostname,
          port: url2.port,
          path: authority,
          headers: {
            ...getAuthorizationHeaders(this),
            ...headers,
            host: authority
          },
          method: "CONNECT"
        }).end();
        return getStream2(request2);
      }
    };
    module2.exports = {
      Http2OverHttp,
      Http2OverHttps: Http2OverHttp
    };
  }
});

// node_modules/http2-wrapper/source/index.js
var require_source3 = __commonJS2({
  "node_modules/http2-wrapper/source/index.js"(exports2, module2) {
    "use strict";
    var http22 = require("http2");
    var {
      Agent,
      globalAgent
    } = require_agent2();
    var ClientRequest = require_client_request();
    var IncomingMessage = require_incoming_message();
    var auto = require_auto();
    var {
      HttpOverHttp2,
      HttpsOverHttp2
    } = require_h1_over_h2();
    var Http2OverHttp2 = require_h2_over_h2();
    var {
      Http2OverHttp,
      Http2OverHttps
    } = require_h2_over_h1();
    var validateHeaderName = require_validate_header_name();
    var validateHeaderValue = require_validate_header_value();
    var request2 = (url2, options, callback) => new ClientRequest(url2, options, callback);
    var get = (url2, options, callback) => {
      const req = new ClientRequest(url2, options, callback);
      req.end();
      return req;
    };
    module2.exports = {
      ...http22,
      ClientRequest,
      IncomingMessage,
      Agent,
      globalAgent,
      request: request2,
      get,
      auto,
      proxies: {
        HttpOverHttp2,
        HttpsOverHttp2,
        Http2OverHttp2,
        Http2OverHttp,
        Http2OverHttps
      },
      validateHeaderName,
      validateHeaderValue
    };
  }
});

// node_modules/@prisma/client/runtime/index.js
var require_runtime = __commonJS2({
  "node_modules/@prisma/client/runtime/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __commonJS = (cb, mod2) => function __require() {
      return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
    };
    var __export = (target, all5) => {
      for (var name in all5)
        __defProp(target, name, { get: all5[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
      isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
      mod2
    ));
    var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
    var __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var require_lz_string = __commonJS({
      "../../node_modules/.pnpm/lz-string@1.4.4/node_modules/lz-string/libs/lz-string.js"(exports2, module2) {
        var LZString = function() {
          var f = String.fromCharCode;
          var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
          var baseReverseDic = {};
          function getBaseValue(alphabet2, character) {
            if (!baseReverseDic[alphabet2]) {
              baseReverseDic[alphabet2] = {};
              for (var i = 0; i < alphabet2.length; i++) {
                baseReverseDic[alphabet2][alphabet2.charAt(i)] = i;
              }
            }
            return baseReverseDic[alphabet2][character];
          }
          __name(getBaseValue, "getBaseValue");
          var LZString2 = {
            compressToBase64: function(input) {
              if (input == null)
                return "";
              var res = LZString2._compress(input, 6, function(a) {
                return keyStrBase64.charAt(a);
              });
              switch (res.length % 4) {
                default:
                case 0:
                  return res;
                case 1:
                  return res + "===";
                case 2:
                  return res + "==";
                case 3:
                  return res + "=";
              }
            },
            decompressFromBase64: function(input) {
              if (input == null)
                return "";
              if (input == "")
                return null;
              return LZString2._decompress(input.length, 32, function(index) {
                return getBaseValue(keyStrBase64, input.charAt(index));
              });
            },
            compressToUTF16: function(input) {
              if (input == null)
                return "";
              return LZString2._compress(input, 15, function(a) {
                return f(a + 32);
              }) + " ";
            },
            decompressFromUTF16: function(compressed) {
              if (compressed == null)
                return "";
              if (compressed == "")
                return null;
              return LZString2._decompress(compressed.length, 16384, function(index) {
                return compressed.charCodeAt(index) - 32;
              });
            },
            compressToUint8Array: function(uncompressed) {
              var compressed = LZString2.compress(uncompressed);
              var buf = new Uint8Array(compressed.length * 2);
              for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
                var current_value = compressed.charCodeAt(i);
                buf[i * 2] = current_value >>> 8;
                buf[i * 2 + 1] = current_value % 256;
              }
              return buf;
            },
            decompressFromUint8Array: function(compressed) {
              if (compressed === null || compressed === void 0) {
                return LZString2.decompress(compressed);
              } else {
                var buf = new Array(compressed.length / 2);
                for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
                  buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
                }
                var result = [];
                buf.forEach(function(c) {
                  result.push(f(c));
                });
                return LZString2.decompress(result.join(""));
              }
            },
            compressToEncodedURIComponent: function(input) {
              if (input == null)
                return "";
              return LZString2._compress(input, 6, function(a) {
                return keyStrUriSafe.charAt(a);
              });
            },
            decompressFromEncodedURIComponent: function(input) {
              if (input == null)
                return "";
              if (input == "")
                return null;
              input = input.replace(/ /g, "+");
              return LZString2._decompress(input.length, 32, function(index) {
                return getBaseValue(keyStrUriSafe, input.charAt(index));
              });
            },
            compress: function(uncompressed) {
              return LZString2._compress(uncompressed, 16, function(a) {
                return f(a);
              });
            },
            _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
              if (uncompressed == null)
                return "";
              var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
              for (ii = 0; ii < uncompressed.length; ii += 1) {
                context_c = uncompressed.charAt(ii);
                if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
                  context_dictionary[context_c] = context_dictSize++;
                  context_dictionaryToCreate[context_c] = true;
                }
                context_wc = context_w + context_c;
                if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
                  context_w = context_wc;
                } else {
                  if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                    if (context_w.charCodeAt(0) < 256) {
                      for (i = 0; i < context_numBits; i++) {
                        context_data_val = context_data_val << 1;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                      }
                      value = context_w.charCodeAt(0);
                      for (i = 0; i < 8; i++) {
                        context_data_val = context_data_val << 1 | value & 1;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                        value = value >> 1;
                      }
                    } else {
                      value = 1;
                      for (i = 0; i < context_numBits; i++) {
                        context_data_val = context_data_val << 1 | value;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                        value = 0;
                      }
                      value = context_w.charCodeAt(0);
                      for (i = 0; i < 16; i++) {
                        context_data_val = context_data_val << 1 | value & 1;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                        value = value >> 1;
                      }
                    }
                    context_enlargeIn--;
                    if (context_enlargeIn == 0) {
                      context_enlargeIn = Math.pow(2, context_numBits);
                      context_numBits++;
                    }
                    delete context_dictionaryToCreate[context_w];
                  } else {
                    value = context_dictionary[context_w];
                    for (i = 0; i < context_numBits; i++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  }
                  context_enlargeIn--;
                  if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                  }
                  context_dictionary[context_wc] = context_dictSize++;
                  context_w = String(context_c);
                }
              }
              if (context_w !== "") {
                if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                  if (context_w.charCodeAt(0) < 256) {
                    for (i = 0; i < context_numBits; i++) {
                      context_data_val = context_data_val << 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                    }
                    value = context_w.charCodeAt(0);
                    for (i = 0; i < 8; i++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  } else {
                    value = 1;
                    for (i = 0; i < context_numBits; i++) {
                      context_data_val = context_data_val << 1 | value;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = 0;
                    }
                    value = context_w.charCodeAt(0);
                    for (i = 0; i < 16; i++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  }
                  context_enlargeIn--;
                  if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                  }
                  delete context_dictionaryToCreate[context_w];
                } else {
                  value = context_dictionary[context_w];
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
              }
              value = 2;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
              while (true) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data.push(getCharFromInt(context_data_val));
                  break;
                } else
                  context_data_position++;
              }
              return context_data.join("");
            },
            decompress: function(compressed) {
              if (compressed == null)
                return "";
              if (compressed == "")
                return null;
              return LZString2._decompress(compressed.length, 32768, function(index) {
                return compressed.charCodeAt(index);
              });
            },
            _decompress: function(length, resetValue, getNextValue) {
              var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
              for (i = 0; i < 3; i += 1) {
                dictionary[i] = i;
              }
              bits = 0;
              maxpower = Math.pow(2, 2);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              switch (next = bits) {
                case 0:
                  bits = 0;
                  maxpower = Math.pow(2, 8);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  c = f(bits);
                  break;
                case 1:
                  bits = 0;
                  maxpower = Math.pow(2, 16);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  c = f(bits);
                  break;
                case 2:
                  return "";
              }
              dictionary[3] = c;
              w = c;
              result.push(c);
              while (true) {
                if (data.index > length) {
                  return "";
                }
                bits = 0;
                maxpower = Math.pow(2, numBits);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                switch (c = bits) {
                  case 0:
                    bits = 0;
                    maxpower = Math.pow(2, 8);
                    power = 1;
                    while (power != maxpower) {
                      resb = data.val & data.position;
                      data.position >>= 1;
                      if (data.position == 0) {
                        data.position = resetValue;
                        data.val = getNextValue(data.index++);
                      }
                      bits |= (resb > 0 ? 1 : 0) * power;
                      power <<= 1;
                    }
                    dictionary[dictSize++] = f(bits);
                    c = dictSize - 1;
                    enlargeIn--;
                    break;
                  case 1:
                    bits = 0;
                    maxpower = Math.pow(2, 16);
                    power = 1;
                    while (power != maxpower) {
                      resb = data.val & data.position;
                      data.position >>= 1;
                      if (data.position == 0) {
                        data.position = resetValue;
                        data.val = getNextValue(data.index++);
                      }
                      bits |= (resb > 0 ? 1 : 0) * power;
                      power <<= 1;
                    }
                    dictionary[dictSize++] = f(bits);
                    c = dictSize - 1;
                    enlargeIn--;
                    break;
                  case 2:
                    return result.join("");
                }
                if (enlargeIn == 0) {
                  enlargeIn = Math.pow(2, numBits);
                  numBits++;
                }
                if (dictionary[c]) {
                  entry = dictionary[c];
                } else {
                  if (c === dictSize) {
                    entry = w + w.charAt(0);
                  } else {
                    return null;
                  }
                }
                result.push(entry);
                dictionary[dictSize++] = w + entry.charAt(0);
                enlargeIn--;
                w = entry;
                if (enlargeIn == 0) {
                  enlargeIn = Math.pow(2, numBits);
                  numBits++;
                }
              }
            }
          };
          return LZString2;
        }();
        if (typeof define === "function" && false) {
          define(function() {
            return LZString;
          });
        } else if (typeof module2 !== "undefined" && module2 != null) {
          module2.exports = LZString;
        }
      }
    });
    var require_color_name = __commonJS({
      "../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports2, module2) {
        "use strict";
        module2.exports = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
      }
    });
    var require_conversions = __commonJS({
      "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports2, module2) {
        var cssKeywords = require_color_name();
        var reverseKeywords = {};
        for (const key of Object.keys(cssKeywords)) {
          reverseKeywords[cssKeywords[key]] = key;
        }
        var convert = {
          rgb: { channels: 3, labels: "rgb" },
          hsl: { channels: 3, labels: "hsl" },
          hsv: { channels: 3, labels: "hsv" },
          hwb: { channels: 3, labels: "hwb" },
          cmyk: { channels: 4, labels: "cmyk" },
          xyz: { channels: 3, labels: "xyz" },
          lab: { channels: 3, labels: "lab" },
          lch: { channels: 3, labels: "lch" },
          hex: { channels: 1, labels: ["hex"] },
          keyword: { channels: 1, labels: ["keyword"] },
          ansi16: { channels: 1, labels: ["ansi16"] },
          ansi256: { channels: 1, labels: ["ansi256"] },
          hcg: { channels: 3, labels: ["h", "c", "g"] },
          apple: { channels: 3, labels: ["r16", "g16", "b16"] },
          gray: { channels: 1, labels: ["gray"] }
        };
        module2.exports = convert;
        for (const model of Object.keys(convert)) {
          if (!("channels" in convert[model])) {
            throw new Error("missing channels property: " + model);
          }
          if (!("labels" in convert[model])) {
            throw new Error("missing channel labels property: " + model);
          }
          if (convert[model].labels.length !== convert[model].channels) {
            throw new Error("channel and label counts mismatch: " + model);
          }
          const { channels, labels } = convert[model];
          delete convert[model].channels;
          delete convert[model].labels;
          Object.defineProperty(convert[model], "channels", { value: channels });
          Object.defineProperty(convert[model], "labels", { value: labels });
        }
        convert.rgb.hsl = function(rgb) {
          const r = rgb[0] / 255;
          const g = rgb[1] / 255;
          const b = rgb[2] / 255;
          const min2 = Math.min(r, g, b);
          const max2 = Math.max(r, g, b);
          const delta = max2 - min2;
          let h;
          let s;
          if (max2 === min2) {
            h = 0;
          } else if (r === max2) {
            h = (g - b) / delta;
          } else if (g === max2) {
            h = 2 + (b - r) / delta;
          } else if (b === max2) {
            h = 4 + (r - g) / delta;
          }
          h = Math.min(h * 60, 360);
          if (h < 0) {
            h += 360;
          }
          const l = (min2 + max2) / 2;
          if (max2 === min2) {
            s = 0;
          } else if (l <= 0.5) {
            s = delta / (max2 + min2);
          } else {
            s = delta / (2 - max2 - min2);
          }
          return [h, s * 100, l * 100];
        };
        convert.rgb.hsv = function(rgb) {
          let rdif;
          let gdif;
          let bdif;
          let h;
          let s;
          const r = rgb[0] / 255;
          const g = rgb[1] / 255;
          const b = rgb[2] / 255;
          const v = Math.max(r, g, b);
          const diff = v - Math.min(r, g, b);
          const diffc = /* @__PURE__ */ __name(function(c) {
            return (v - c) / 6 / diff + 1 / 2;
          }, "diffc");
          if (diff === 0) {
            h = 0;
            s = 0;
          } else {
            s = diff / v;
            rdif = diffc(r);
            gdif = diffc(g);
            bdif = diffc(b);
            if (r === v) {
              h = bdif - gdif;
            } else if (g === v) {
              h = 1 / 3 + rdif - bdif;
            } else if (b === v) {
              h = 2 / 3 + gdif - rdif;
            }
            if (h < 0) {
              h += 1;
            } else if (h > 1) {
              h -= 1;
            }
          }
          return [
            h * 360,
            s * 100,
            v * 100
          ];
        };
        convert.rgb.hwb = function(rgb) {
          const r = rgb[0];
          const g = rgb[1];
          let b = rgb[2];
          const h = convert.rgb.hsl(rgb)[0];
          const w = 1 / 255 * Math.min(r, Math.min(g, b));
          b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
          return [h, w * 100, b * 100];
        };
        convert.rgb.cmyk = function(rgb) {
          const r = rgb[0] / 255;
          const g = rgb[1] / 255;
          const b = rgb[2] / 255;
          const k = Math.min(1 - r, 1 - g, 1 - b);
          const c = (1 - r - k) / (1 - k) || 0;
          const m = (1 - g - k) / (1 - k) || 0;
          const y = (1 - b - k) / (1 - k) || 0;
          return [c * 100, m * 100, y * 100, k * 100];
        };
        function comparativeDistance(x, y) {
          return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
        }
        __name(comparativeDistance, "comparativeDistance");
        convert.rgb.keyword = function(rgb) {
          const reversed = reverseKeywords[rgb];
          if (reversed) {
            return reversed;
          }
          let currentClosestDistance = Infinity;
          let currentClosestKeyword;
          for (const keyword of Object.keys(cssKeywords)) {
            const value = cssKeywords[keyword];
            const distance = comparativeDistance(rgb, value);
            if (distance < currentClosestDistance) {
              currentClosestDistance = distance;
              currentClosestKeyword = keyword;
            }
          }
          return currentClosestKeyword;
        };
        convert.keyword.rgb = function(keyword) {
          return cssKeywords[keyword];
        };
        convert.rgb.xyz = function(rgb) {
          let r = rgb[0] / 255;
          let g = rgb[1] / 255;
          let b = rgb[2] / 255;
          r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
          g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
          b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
          const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
          const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
          const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
          return [x * 100, y * 100, z * 100];
        };
        convert.rgb.lab = function(rgb) {
          const xyz = convert.rgb.xyz(rgb);
          let x = xyz[0];
          let y = xyz[1];
          let z = xyz[2];
          x /= 95.047;
          y /= 100;
          z /= 108.883;
          x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
          y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
          z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
          const l = 116 * y - 16;
          const a = 500 * (x - y);
          const b = 200 * (y - z);
          return [l, a, b];
        };
        convert.hsl.rgb = function(hsl) {
          const h = hsl[0] / 360;
          const s = hsl[1] / 100;
          const l = hsl[2] / 100;
          let t2;
          let t3;
          let val;
          if (s === 0) {
            val = l * 255;
            return [val, val, val];
          }
          if (l < 0.5) {
            t2 = l * (1 + s);
          } else {
            t2 = l + s - l * s;
          }
          const t1 = 2 * l - t2;
          const rgb = [0, 0, 0];
          for (let i = 0; i < 3; i++) {
            t3 = h + 1 / 3 * -(i - 1);
            if (t3 < 0) {
              t3++;
            }
            if (t3 > 1) {
              t3--;
            }
            if (6 * t3 < 1) {
              val = t1 + (t2 - t1) * 6 * t3;
            } else if (2 * t3 < 1) {
              val = t2;
            } else if (3 * t3 < 2) {
              val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
            } else {
              val = t1;
            }
            rgb[i] = val * 255;
          }
          return rgb;
        };
        convert.hsl.hsv = function(hsl) {
          const h = hsl[0];
          let s = hsl[1] / 100;
          let l = hsl[2] / 100;
          let smin = s;
          const lmin = Math.max(l, 0.01);
          l *= 2;
          s *= l <= 1 ? l : 2 - l;
          smin *= lmin <= 1 ? lmin : 2 - lmin;
          const v = (l + s) / 2;
          const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
          return [h, sv * 100, v * 100];
        };
        convert.hsv.rgb = function(hsv) {
          const h = hsv[0] / 60;
          const s = hsv[1] / 100;
          let v = hsv[2] / 100;
          const hi = Math.floor(h) % 6;
          const f = h - Math.floor(h);
          const p = 255 * v * (1 - s);
          const q = 255 * v * (1 - s * f);
          const t = 255 * v * (1 - s * (1 - f));
          v *= 255;
          switch (hi) {
            case 0:
              return [v, t, p];
            case 1:
              return [q, v, p];
            case 2:
              return [p, v, t];
            case 3:
              return [p, q, v];
            case 4:
              return [t, p, v];
            case 5:
              return [v, p, q];
          }
        };
        convert.hsv.hsl = function(hsv) {
          const h = hsv[0];
          const s = hsv[1] / 100;
          const v = hsv[2] / 100;
          const vmin = Math.max(v, 0.01);
          let sl;
          let l;
          l = (2 - s) * v;
          const lmin = (2 - s) * vmin;
          sl = s * vmin;
          sl /= lmin <= 1 ? lmin : 2 - lmin;
          sl = sl || 0;
          l /= 2;
          return [h, sl * 100, l * 100];
        };
        convert.hwb.rgb = function(hwb) {
          const h = hwb[0] / 360;
          let wh = hwb[1] / 100;
          let bl = hwb[2] / 100;
          const ratio = wh + bl;
          let f;
          if (ratio > 1) {
            wh /= ratio;
            bl /= ratio;
          }
          const i = Math.floor(6 * h);
          const v = 1 - bl;
          f = 6 * h - i;
          if ((i & 1) !== 0) {
            f = 1 - f;
          }
          const n = wh + f * (v - wh);
          let r;
          let g;
          let b;
          switch (i) {
            default:
            case 6:
            case 0:
              r = v;
              g = n;
              b = wh;
              break;
            case 1:
              r = n;
              g = v;
              b = wh;
              break;
            case 2:
              r = wh;
              g = v;
              b = n;
              break;
            case 3:
              r = wh;
              g = n;
              b = v;
              break;
            case 4:
              r = n;
              g = wh;
              b = v;
              break;
            case 5:
              r = v;
              g = wh;
              b = n;
              break;
          }
          return [r * 255, g * 255, b * 255];
        };
        convert.cmyk.rgb = function(cmyk) {
          const c = cmyk[0] / 100;
          const m = cmyk[1] / 100;
          const y = cmyk[2] / 100;
          const k = cmyk[3] / 100;
          const r = 1 - Math.min(1, c * (1 - k) + k);
          const g = 1 - Math.min(1, m * (1 - k) + k);
          const b = 1 - Math.min(1, y * (1 - k) + k);
          return [r * 255, g * 255, b * 255];
        };
        convert.xyz.rgb = function(xyz) {
          const x = xyz[0] / 100;
          const y = xyz[1] / 100;
          const z = xyz[2] / 100;
          let r;
          let g;
          let b;
          r = x * 3.2406 + y * -1.5372 + z * -0.4986;
          g = x * -0.9689 + y * 1.8758 + z * 0.0415;
          b = x * 0.0557 + y * -0.204 + z * 1.057;
          r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
          g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
          b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
          r = Math.min(Math.max(0, r), 1);
          g = Math.min(Math.max(0, g), 1);
          b = Math.min(Math.max(0, b), 1);
          return [r * 255, g * 255, b * 255];
        };
        convert.xyz.lab = function(xyz) {
          let x = xyz[0];
          let y = xyz[1];
          let z = xyz[2];
          x /= 95.047;
          y /= 100;
          z /= 108.883;
          x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
          y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
          z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
          const l = 116 * y - 16;
          const a = 500 * (x - y);
          const b = 200 * (y - z);
          return [l, a, b];
        };
        convert.lab.xyz = function(lab) {
          const l = lab[0];
          const a = lab[1];
          const b = lab[2];
          let x;
          let y;
          let z;
          y = (l + 16) / 116;
          x = a / 500 + y;
          z = y - b / 200;
          const y2 = y ** 3;
          const x2 = x ** 3;
          const z2 = z ** 3;
          y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
          x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
          z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
          x *= 95.047;
          y *= 100;
          z *= 108.883;
          return [x, y, z];
        };
        convert.lab.lch = function(lab) {
          const l = lab[0];
          const a = lab[1];
          const b = lab[2];
          let h;
          const hr = Math.atan2(b, a);
          h = hr * 360 / 2 / Math.PI;
          if (h < 0) {
            h += 360;
          }
          const c = Math.sqrt(a * a + b * b);
          return [l, c, h];
        };
        convert.lch.lab = function(lch) {
          const l = lch[0];
          const c = lch[1];
          const h = lch[2];
          const hr = h / 360 * 2 * Math.PI;
          const a = c * Math.cos(hr);
          const b = c * Math.sin(hr);
          return [l, a, b];
        };
        convert.rgb.ansi16 = function(args, saturation = null) {
          const [r, g, b] = args;
          let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
          value = Math.round(value / 50);
          if (value === 0) {
            return 30;
          }
          let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
          if (value === 2) {
            ansi += 60;
          }
          return ansi;
        };
        convert.hsv.ansi16 = function(args) {
          return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
        };
        convert.rgb.ansi256 = function(args) {
          const r = args[0];
          const g = args[1];
          const b = args[2];
          if (r === g && g === b) {
            if (r < 8) {
              return 16;
            }
            if (r > 248) {
              return 231;
            }
            return Math.round((r - 8) / 247 * 24) + 232;
          }
          const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
          return ansi;
        };
        convert.ansi16.rgb = function(args) {
          let color = args % 10;
          if (color === 0 || color === 7) {
            if (args > 50) {
              color += 3.5;
            }
            color = color / 10.5 * 255;
            return [color, color, color];
          }
          const mult = (~~(args > 50) + 1) * 0.5;
          const r = (color & 1) * mult * 255;
          const g = (color >> 1 & 1) * mult * 255;
          const b = (color >> 2 & 1) * mult * 255;
          return [r, g, b];
        };
        convert.ansi256.rgb = function(args) {
          if (args >= 232) {
            const c = (args - 232) * 10 + 8;
            return [c, c, c];
          }
          args -= 16;
          let rem;
          const r = Math.floor(args / 36) / 5 * 255;
          const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
          const b = rem % 6 / 5 * 255;
          return [r, g, b];
        };
        convert.rgb.hex = function(args) {
          const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
          const string = integer.toString(16).toUpperCase();
          return "000000".substring(string.length) + string;
        };
        convert.hex.rgb = function(args) {
          const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!match) {
            return [0, 0, 0];
          }
          let colorString = match[0];
          if (match[0].length === 3) {
            colorString = colorString.split("").map((char) => {
              return char + char;
            }).join("");
          }
          const integer = parseInt(colorString, 16);
          const r = integer >> 16 & 255;
          const g = integer >> 8 & 255;
          const b = integer & 255;
          return [r, g, b];
        };
        convert.rgb.hcg = function(rgb) {
          const r = rgb[0] / 255;
          const g = rgb[1] / 255;
          const b = rgb[2] / 255;
          const max2 = Math.max(Math.max(r, g), b);
          const min2 = Math.min(Math.min(r, g), b);
          const chroma = max2 - min2;
          let grayscale;
          let hue;
          if (chroma < 1) {
            grayscale = min2 / (1 - chroma);
          } else {
            grayscale = 0;
          }
          if (chroma <= 0) {
            hue = 0;
          } else if (max2 === r) {
            hue = (g - b) / chroma % 6;
          } else if (max2 === g) {
            hue = 2 + (b - r) / chroma;
          } else {
            hue = 4 + (r - g) / chroma;
          }
          hue /= 6;
          hue %= 1;
          return [hue * 360, chroma * 100, grayscale * 100];
        };
        convert.hsl.hcg = function(hsl) {
          const s = hsl[1] / 100;
          const l = hsl[2] / 100;
          const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
          let f = 0;
          if (c < 1) {
            f = (l - 0.5 * c) / (1 - c);
          }
          return [hsl[0], c * 100, f * 100];
        };
        convert.hsv.hcg = function(hsv) {
          const s = hsv[1] / 100;
          const v = hsv[2] / 100;
          const c = s * v;
          let f = 0;
          if (c < 1) {
            f = (v - c) / (1 - c);
          }
          return [hsv[0], c * 100, f * 100];
        };
        convert.hcg.rgb = function(hcg) {
          const h = hcg[0] / 360;
          const c = hcg[1] / 100;
          const g = hcg[2] / 100;
          if (c === 0) {
            return [g * 255, g * 255, g * 255];
          }
          const pure = [0, 0, 0];
          const hi = h % 1 * 6;
          const v = hi % 1;
          const w = 1 - v;
          let mg = 0;
          switch (Math.floor(hi)) {
            case 0:
              pure[0] = 1;
              pure[1] = v;
              pure[2] = 0;
              break;
            case 1:
              pure[0] = w;
              pure[1] = 1;
              pure[2] = 0;
              break;
            case 2:
              pure[0] = 0;
              pure[1] = 1;
              pure[2] = v;
              break;
            case 3:
              pure[0] = 0;
              pure[1] = w;
              pure[2] = 1;
              break;
            case 4:
              pure[0] = v;
              pure[1] = 0;
              pure[2] = 1;
              break;
            default:
              pure[0] = 1;
              pure[1] = 0;
              pure[2] = w;
          }
          mg = (1 - c) * g;
          return [
            (c * pure[0] + mg) * 255,
            (c * pure[1] + mg) * 255,
            (c * pure[2] + mg) * 255
          ];
        };
        convert.hcg.hsv = function(hcg) {
          const c = hcg[1] / 100;
          const g = hcg[2] / 100;
          const v = c + g * (1 - c);
          let f = 0;
          if (v > 0) {
            f = c / v;
          }
          return [hcg[0], f * 100, v * 100];
        };
        convert.hcg.hsl = function(hcg) {
          const c = hcg[1] / 100;
          const g = hcg[2] / 100;
          const l = g * (1 - c) + 0.5 * c;
          let s = 0;
          if (l > 0 && l < 0.5) {
            s = c / (2 * l);
          } else if (l >= 0.5 && l < 1) {
            s = c / (2 * (1 - l));
          }
          return [hcg[0], s * 100, l * 100];
        };
        convert.hcg.hwb = function(hcg) {
          const c = hcg[1] / 100;
          const g = hcg[2] / 100;
          const v = c + g * (1 - c);
          return [hcg[0], (v - c) * 100, (1 - v) * 100];
        };
        convert.hwb.hcg = function(hwb) {
          const w = hwb[1] / 100;
          const b = hwb[2] / 100;
          const v = 1 - b;
          const c = v - w;
          let g = 0;
          if (c < 1) {
            g = (v - c) / (1 - c);
          }
          return [hwb[0], c * 100, g * 100];
        };
        convert.apple.rgb = function(apple) {
          return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
        };
        convert.rgb.apple = function(rgb) {
          return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
        };
        convert.gray.rgb = function(args) {
          return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
        };
        convert.gray.hsl = function(args) {
          return [0, 0, args[0]];
        };
        convert.gray.hsv = convert.gray.hsl;
        convert.gray.hwb = function(gray) {
          return [0, 100, gray[0]];
        };
        convert.gray.cmyk = function(gray) {
          return [0, 0, 0, gray[0]];
        };
        convert.gray.lab = function(gray) {
          return [gray[0], 0, 0];
        };
        convert.gray.hex = function(gray) {
          const val = Math.round(gray[0] / 100 * 255) & 255;
          const integer = (val << 16) + (val << 8) + val;
          const string = integer.toString(16).toUpperCase();
          return "000000".substring(string.length) + string;
        };
        convert.rgb.gray = function(rgb) {
          const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
          return [val / 255 * 100];
        };
      }
    });
    var require_route = __commonJS({
      "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports2, module2) {
        var conversions = require_conversions();
        function buildGraph() {
          const graph = {};
          const models = Object.keys(conversions);
          for (let len = models.length, i = 0; i < len; i++) {
            graph[models[i]] = {
              distance: -1,
              parent: null
            };
          }
          return graph;
        }
        __name(buildGraph, "buildGraph");
        function deriveBFS(fromModel) {
          const graph = buildGraph();
          const queue = [fromModel];
          graph[fromModel].distance = 0;
          while (queue.length) {
            const current = queue.pop();
            const adjacents = Object.keys(conversions[current]);
            for (let len = adjacents.length, i = 0; i < len; i++) {
              const adjacent = adjacents[i];
              const node = graph[adjacent];
              if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
              }
            }
          }
          return graph;
        }
        __name(deriveBFS, "deriveBFS");
        function link(from, to) {
          return function(args) {
            return to(from(args));
          };
        }
        __name(link, "link");
        function wrapConversion(toModel, graph) {
          const path7 = [graph[toModel].parent, toModel];
          let fn = conversions[graph[toModel].parent][toModel];
          let cur = graph[toModel].parent;
          while (graph[cur].parent) {
            path7.unshift(graph[cur].parent);
            fn = link(conversions[graph[cur].parent][cur], fn);
            cur = graph[cur].parent;
          }
          fn.conversion = path7;
          return fn;
        }
        __name(wrapConversion, "wrapConversion");
        module2.exports = function(fromModel) {
          const graph = deriveBFS(fromModel);
          const conversion = {};
          const models = Object.keys(graph);
          for (let len = models.length, i = 0; i < len; i++) {
            const toModel = models[i];
            const node = graph[toModel];
            if (node.parent === null) {
              continue;
            }
            conversion[toModel] = wrapConversion(toModel, graph);
          }
          return conversion;
        };
      }
    });
    var require_color_convert = __commonJS({
      "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports2, module2) {
        var conversions = require_conversions();
        var route = require_route();
        var convert = {};
        var models = Object.keys(conversions);
        function wrapRaw(fn) {
          const wrappedFn = /* @__PURE__ */ __name(function(...args) {
            const arg0 = args[0];
            if (arg0 === void 0 || arg0 === null) {
              return arg0;
            }
            if (arg0.length > 1) {
              args = arg0;
            }
            return fn(args);
          }, "wrappedFn");
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        __name(wrapRaw, "wrapRaw");
        function wrapRounded(fn) {
          const wrappedFn = /* @__PURE__ */ __name(function(...args) {
            const arg0 = args[0];
            if (arg0 === void 0 || arg0 === null) {
              return arg0;
            }
            if (arg0.length > 1) {
              args = arg0;
            }
            const result = fn(args);
            if (typeof result === "object") {
              for (let len = result.length, i = 0; i < len; i++) {
                result[i] = Math.round(result[i]);
              }
            }
            return result;
          }, "wrappedFn");
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        __name(wrapRounded, "wrapRounded");
        models.forEach((fromModel) => {
          convert[fromModel] = {};
          Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
          Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
          const routes = route(fromModel);
          const routeModels = Object.keys(routes);
          routeModels.forEach((toModel) => {
            const fn = routes[toModel];
            convert[fromModel][toModel] = wrapRounded(fn);
            convert[fromModel][toModel].raw = wrapRaw(fn);
          });
        });
        module2.exports = convert;
      }
    });
    var require_ansi_styles = __commonJS({
      "../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports2, module2) {
        "use strict";
        var wrapAnsi16 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
          const code = fn(...args);
          return `\x1B[${code + offset}m`;
        }, "wrapAnsi16");
        var wrapAnsi256 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
          const code = fn(...args);
          return `\x1B[${38 + offset};5;${code}m`;
        }, "wrapAnsi256");
        var wrapAnsi16m = /* @__PURE__ */ __name((fn, offset) => (...args) => {
          const rgb = fn(...args);
          return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
        }, "wrapAnsi16m");
        var ansi2ansi = /* @__PURE__ */ __name((n) => n, "ansi2ansi");
        var rgb2rgb = /* @__PURE__ */ __name((r, g, b) => [r, g, b], "rgb2rgb");
        var setLazyProperty = /* @__PURE__ */ __name((object, property, get) => {
          Object.defineProperty(object, property, {
            get: () => {
              const value = get();
              Object.defineProperty(object, property, {
                value,
                enumerable: true,
                configurable: true
              });
              return value;
            },
            enumerable: true,
            configurable: true
          });
        }, "setLazyProperty");
        var colorConvert;
        var makeDynamicStyles = /* @__PURE__ */ __name((wrap, targetSpace, identity2, isBackground) => {
          if (colorConvert === void 0) {
            colorConvert = require_color_convert();
          }
          const offset = isBackground ? 10 : 0;
          const styles = {};
          for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
            const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
            if (sourceSpace === targetSpace) {
              styles[name] = wrap(identity2, offset);
            } else if (typeof suite === "object") {
              styles[name] = wrap(suite[targetSpace], offset);
            }
          }
          return styles;
        }, "makeDynamicStyles");
        function assembleStyles() {
          const codes = /* @__PURE__ */ new Map();
          const styles = {
            modifier: {
              reset: [0, 0],
              bold: [1, 22],
              dim: [2, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              hidden: [8, 28],
              strikethrough: [9, 29]
            },
            color: {
              black: [30, 39],
              red: [31, 39],
              green: [32, 39],
              yellow: [33, 39],
              blue: [34, 39],
              magenta: [35, 39],
              cyan: [36, 39],
              white: [37, 39],
              blackBright: [90, 39],
              redBright: [91, 39],
              greenBright: [92, 39],
              yellowBright: [93, 39],
              blueBright: [94, 39],
              magentaBright: [95, 39],
              cyanBright: [96, 39],
              whiteBright: [97, 39]
            },
            bgColor: {
              bgBlack: [40, 49],
              bgRed: [41, 49],
              bgGreen: [42, 49],
              bgYellow: [43, 49],
              bgBlue: [44, 49],
              bgMagenta: [45, 49],
              bgCyan: [46, 49],
              bgWhite: [47, 49],
              bgBlackBright: [100, 49],
              bgRedBright: [101, 49],
              bgGreenBright: [102, 49],
              bgYellowBright: [103, 49],
              bgBlueBright: [104, 49],
              bgMagentaBright: [105, 49],
              bgCyanBright: [106, 49],
              bgWhiteBright: [107, 49]
            }
          };
          styles.color.gray = styles.color.blackBright;
          styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
          styles.color.grey = styles.color.blackBright;
          styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
          for (const [groupName, group] of Object.entries(styles)) {
            for (const [styleName, style] of Object.entries(group)) {
              styles[styleName] = {
                open: `\x1B[${style[0]}m`,
                close: `\x1B[${style[1]}m`
              };
              group[styleName] = styles[styleName];
              codes.set(style[0], style[1]);
            }
            Object.defineProperty(styles, groupName, {
              value: group,
              enumerable: false
            });
          }
          Object.defineProperty(styles, "codes", {
            value: codes,
            enumerable: false
          });
          styles.color.close = "\x1B[39m";
          styles.bgColor.close = "\x1B[49m";
          setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
          setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
          setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
          setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
          setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
          setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
          return styles;
        }
        __name(assembleStyles, "assembleStyles");
        Object.defineProperty(module2, "exports", {
          enumerable: true,
          get: assembleStyles
        });
      }
    });
    var require_has_flag = __commonJS({
      "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (flag, argv = process.argv) => {
          const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
          const position = argv.indexOf(prefix + flag);
          const terminatorPosition = argv.indexOf("--");
          return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
        };
      }
    });
    var require_supports_color = __commonJS({
      "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
        "use strict";
        var os32 = require("os");
        var tty = require("tty");
        var hasFlag = require_has_flag();
        var { env: env2 } = process;
        var forceColor;
        if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
          forceColor = 0;
        } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
          forceColor = 1;
        }
        if ("FORCE_COLOR" in env2) {
          if (env2.FORCE_COLOR === "true") {
            forceColor = 1;
          } else if (env2.FORCE_COLOR === "false") {
            forceColor = 0;
          } else {
            forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
          }
        }
        function translateLevel(level) {
          if (level === 0) {
            return false;
          }
          return {
            level,
            hasBasic: true,
            has256: level >= 2,
            has16m: level >= 3
          };
        }
        __name(translateLevel, "translateLevel");
        function supportsColor(haveStream, streamIsTTY) {
          if (forceColor === 0) {
            return 0;
          }
          if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
            return 3;
          }
          if (hasFlag("color=256")) {
            return 2;
          }
          if (haveStream && !streamIsTTY && forceColor === void 0) {
            return 0;
          }
          const min2 = forceColor || 0;
          if (env2.TERM === "dumb") {
            return min2;
          }
          if (process.platform === "win32") {
            const osRelease = os32.release().split(".");
            if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
              return Number(osRelease[2]) >= 14931 ? 3 : 2;
            }
            return 1;
          }
          if ("CI" in env2) {
            if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env2) || env2.CI_NAME === "codeship") {
              return 1;
            }
            return min2;
          }
          if ("TEAMCITY_VERSION" in env2) {
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
          }
          if (env2.COLORTERM === "truecolor") {
            return 3;
          }
          if ("TERM_PROGRAM" in env2) {
            const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (env2.TERM_PROGRAM) {
              case "iTerm.app":
                return version >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          if (/-256(color)?$/i.test(env2.TERM)) {
            return 2;
          }
          if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
            return 1;
          }
          if ("COLORTERM" in env2) {
            return 1;
          }
          return min2;
        }
        __name(supportsColor, "supportsColor");
        function getSupportLevel(stream22) {
          const level = supportsColor(stream22, stream22 && stream22.isTTY);
          return translateLevel(level);
        }
        __name(getSupportLevel, "getSupportLevel");
        module2.exports = {
          supportsColor: getSupportLevel,
          stdout: translateLevel(supportsColor(true, tty.isatty(1))),
          stderr: translateLevel(supportsColor(true, tty.isatty(2)))
        };
      }
    });
    var require_util = __commonJS({
      "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js"(exports2, module2) {
        "use strict";
        var stringReplaceAll = /* @__PURE__ */ __name((string, substring, replacer) => {
          let index = string.indexOf(substring);
          if (index === -1) {
            return string;
          }
          const substringLength = substring.length;
          let endIndex = 0;
          let returnValue = "";
          do {
            returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
            endIndex = index + substringLength;
            index = string.indexOf(substring, endIndex);
          } while (index !== -1);
          returnValue += string.substr(endIndex);
          return returnValue;
        }, "stringReplaceAll");
        var stringEncaseCRLFWithFirstIndex = /* @__PURE__ */ __name((string, prefix, postfix, index) => {
          let endIndex = 0;
          let returnValue = "";
          do {
            const gotCR = string[index - 1] === "\r";
            returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
            endIndex = index + 1;
            index = string.indexOf("\n", endIndex);
          } while (index !== -1);
          returnValue += string.substr(endIndex);
          return returnValue;
        }, "stringEncaseCRLFWithFirstIndex");
        module2.exports = {
          stringReplaceAll,
          stringEncaseCRLFWithFirstIndex
        };
      }
    });
    var require_templates = __commonJS({
      "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js"(exports2, module2) {
        "use strict";
        var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
        var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
        var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
        var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
        var ESCAPES = /* @__PURE__ */ new Map([
          ["n", "\n"],
          ["r", "\r"],
          ["t", "	"],
          ["b", "\b"],
          ["f", "\f"],
          ["v", "\v"],
          ["0", "\0"],
          ["\\", "\\"],
          ["e", "\x1B"],
          ["a", "\x07"]
        ]);
        function unescape2(c) {
          const u = c[0] === "u";
          const bracket = c[1] === "{";
          if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
            return String.fromCharCode(parseInt(c.slice(1), 16));
          }
          if (u && bracket) {
            return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
          }
          return ESCAPES.get(c) || c;
        }
        __name(unescape2, "unescape");
        function parseArguments(name, arguments_) {
          const results = [];
          const chunks = arguments_.trim().split(/\s*,\s*/g);
          let matches;
          for (const chunk of chunks) {
            const number = Number(chunk);
            if (!Number.isNaN(number)) {
              results.push(number);
            } else if (matches = chunk.match(STRING_REGEX)) {
              results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape2(escape) : character));
            } else {
              throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
            }
          }
          return results;
        }
        __name(parseArguments, "parseArguments");
        function parseStyle(style) {
          STYLE_REGEX.lastIndex = 0;
          const results = [];
          let matches;
          while ((matches = STYLE_REGEX.exec(style)) !== null) {
            const name = matches[1];
            if (matches[2]) {
              const args = parseArguments(name, matches[2]);
              results.push([name].concat(args));
            } else {
              results.push([name]);
            }
          }
          return results;
        }
        __name(parseStyle, "parseStyle");
        function buildStyle(chalk12, styles) {
          const enabled = {};
          for (const layer of styles) {
            for (const style of layer.styles) {
              enabled[style[0]] = layer.inverse ? null : style.slice(1);
            }
          }
          let current = chalk12;
          for (const [styleName, styles2] of Object.entries(enabled)) {
            if (!Array.isArray(styles2)) {
              continue;
            }
            if (!(styleName in current)) {
              throw new Error(`Unknown Chalk style: ${styleName}`);
            }
            current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
          }
          return current;
        }
        __name(buildStyle, "buildStyle");
        module2.exports = (chalk12, temporary) => {
          const styles = [];
          const chunks = [];
          let chunk = [];
          temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
            if (escapeCharacter) {
              chunk.push(unescape2(escapeCharacter));
            } else if (style) {
              const string = chunk.join("");
              chunk = [];
              chunks.push(styles.length === 0 ? string : buildStyle(chalk12, styles)(string));
              styles.push({ inverse, styles: parseStyle(style) });
            } else if (close) {
              if (styles.length === 0) {
                throw new Error("Found extraneous } in Chalk template literal");
              }
              chunks.push(buildStyle(chalk12, styles)(chunk.join("")));
              chunk = [];
              styles.pop();
            } else {
              chunk.push(character);
            }
          });
          chunks.push(chunk.join(""));
          if (styles.length > 0) {
            const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
            throw new Error(errMessage);
          }
          return chunks.join("");
        };
      }
    });
    var require_source = __commonJS({
      "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js"(exports2, module2) {
        "use strict";
        var ansiStyles = require_ansi_styles();
        var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
        var {
          stringReplaceAll,
          stringEncaseCRLFWithFirstIndex
        } = require_util();
        var { isArray: isArray22 } = Array;
        var levelMapping = [
          "ansi",
          "ansi",
          "ansi256",
          "ansi16m"
        ];
        var styles = /* @__PURE__ */ Object.create(null);
        var applyOptions = /* @__PURE__ */ __name((object, options = {}) => {
          if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
            throw new Error("The `level` option should be an integer from 0 to 3");
          }
          const colorLevel = stdoutColor ? stdoutColor.level : 0;
          object.level = options.level === void 0 ? colorLevel : options.level;
        }, "applyOptions");
        var ChalkClass = class {
          constructor(options) {
            return chalkFactory(options);
          }
        };
        __name(ChalkClass, "ChalkClass");
        var chalkFactory = /* @__PURE__ */ __name((options) => {
          const chalk13 = {};
          applyOptions(chalk13, options);
          chalk13.template = (...arguments_) => chalkTag(chalk13.template, ...arguments_);
          Object.setPrototypeOf(chalk13, Chalk.prototype);
          Object.setPrototypeOf(chalk13.template, chalk13);
          chalk13.template.constructor = () => {
            throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
          };
          chalk13.template.Instance = ChalkClass;
          return chalk13.template;
        }, "chalkFactory");
        function Chalk(options) {
          return chalkFactory(options);
        }
        __name(Chalk, "Chalk");
        for (const [styleName, style] of Object.entries(ansiStyles)) {
          styles[styleName] = {
            get() {
              const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
              Object.defineProperty(this, styleName, { value: builder });
              return builder;
            }
          };
        }
        styles.visible = {
          get() {
            const builder = createBuilder(this, this._styler, true);
            Object.defineProperty(this, "visible", { value: builder });
            return builder;
          }
        };
        var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
        for (const model of usedModels) {
          styles[model] = {
            get() {
              const { level } = this;
              return function(...arguments_) {
                const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
                return createBuilder(this, styler, this._isEmpty);
              };
            }
          };
        }
        for (const model of usedModels) {
          const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
          styles[bgModel] = {
            get() {
              const { level } = this;
              return function(...arguments_) {
                const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
                return createBuilder(this, styler, this._isEmpty);
              };
            }
          };
        }
        var proto = Object.defineProperties(() => {
        }, {
          ...styles,
          level: {
            enumerable: true,
            get() {
              return this._generator.level;
            },
            set(level) {
              this._generator.level = level;
            }
          }
        });
        var createStyler = /* @__PURE__ */ __name((open, close, parent) => {
          let openAll;
          let closeAll;
          if (parent === void 0) {
            openAll = open;
            closeAll = close;
          } else {
            openAll = parent.openAll + open;
            closeAll = close + parent.closeAll;
          }
          return {
            open,
            close,
            openAll,
            closeAll,
            parent
          };
        }, "createStyler");
        var createBuilder = /* @__PURE__ */ __name((self2, _styler, _isEmpty) => {
          const builder = /* @__PURE__ */ __name((...arguments_) => {
            if (isArray22(arguments_[0]) && isArray22(arguments_[0].raw)) {
              return applyStyle(builder, chalkTag(builder, ...arguments_));
            }
            return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
          }, "builder");
          Object.setPrototypeOf(builder, proto);
          builder._generator = self2;
          builder._styler = _styler;
          builder._isEmpty = _isEmpty;
          return builder;
        }, "createBuilder");
        var applyStyle = /* @__PURE__ */ __name((self2, string) => {
          if (self2.level <= 0 || !string) {
            return self2._isEmpty ? "" : string;
          }
          let styler = self2._styler;
          if (styler === void 0) {
            return string;
          }
          const { openAll, closeAll } = styler;
          if (string.indexOf("\x1B") !== -1) {
            while (styler !== void 0) {
              string = stringReplaceAll(string, styler.close, styler.open);
              styler = styler.parent;
            }
          }
          const lfIndex = string.indexOf("\n");
          if (lfIndex !== -1) {
            string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
          }
          return openAll + string + closeAll;
        }, "applyStyle");
        var template;
        var chalkTag = /* @__PURE__ */ __name((chalk13, ...strings) => {
          const [firstString] = strings;
          if (!isArray22(firstString) || !isArray22(firstString.raw)) {
            return strings.join(" ");
          }
          const arguments_ = strings.slice(1);
          const parts = [firstString.raw[0]];
          for (let i = 1; i < firstString.length; i++) {
            parts.push(
              String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
              String(firstString.raw[i])
            );
          }
          if (template === void 0) {
            template = require_templates();
          }
          return template(chalk13, parts.join(""));
        }, "chalkTag");
        Object.defineProperties(Chalk.prototype, styles);
        var chalk12 = Chalk();
        chalk12.supportsColor = stdoutColor;
        chalk12.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
        chalk12.stderr.supportsColor = stderrColor;
        module2.exports = chalk12;
      }
    });
    var require_ms = __commonJS({
      "../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports2, module2) {
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module2.exports = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse2(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse2(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return void 0;
          }
        }
        __name(parse2, "parse");
        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return Math.round(ms / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms / s) + "s";
          }
          return ms + "ms";
        }
        __name(fmtShort, "fmtShort");
        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return plural(ms, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms, msAbs, s, "second");
          }
          return ms + " ms";
        }
        __name(fmtLong, "fmtLong");
        function plural(ms, msAbs, n, name) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
        __name(plural, "plural");
      }
    });
    var require_common = __commonJS({
      "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js"(exports2, module2) {
        function setup(env2) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = require_ms();
          createDebug.destroy = destroy;
          Object.keys(env2).forEach((key) => {
            createDebug[key] = env2[key];
          });
          createDebug.names = [];
          createDebug.skips = [];
          createDebug.formatters = {};
          function selectColor(namespace) {
            let hash = 0;
            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          __name(selectColor, "selectColor");
          createDebug.selectColor = selectColor;
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;
            function debug13(...args) {
              if (!debug13.enabled) {
                return;
              }
              const self2 = debug13;
              const curr = Number(/* @__PURE__ */ new Date());
              const ms = curr - (prevTime || curr);
              self2.diff = ms;
              self2.prev = prevTime;
              self2.curr = curr;
              prevTime = curr;
              args[0] = createDebug.coerce(args[0]);
              if (typeof args[0] !== "string") {
                args.unshift("%O");
              }
              let index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
                if (match === "%%") {
                  return "%";
                }
                index++;
                const formatter = createDebug.formatters[format2];
                if (typeof formatter === "function") {
                  const val = args[index];
                  match = formatter.call(self2, val);
                  args.splice(index, 1);
                  index--;
                }
                return match;
              });
              createDebug.formatArgs.call(self2, args);
              const logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
            __name(debug13, "debug");
            debug13.namespace = namespace;
            debug13.useColors = createDebug.useColors();
            debug13.color = createDebug.selectColor(namespace);
            debug13.extend = extend2;
            debug13.destroy = createDebug.destroy;
            Object.defineProperty(debug13, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
              },
              set: (v) => {
                enableOverride = v;
              }
            });
            if (typeof createDebug.init === "function") {
              createDebug.init(debug13);
            }
            return debug13;
          }
          __name(createDebug, "createDebug");
          function extend2(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }
          __name(extend2, "extend");
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            let i;
            const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
            const len = split.length;
            for (i = 0; i < len; i++) {
              if (!split[i]) {
                continue;
              }
              namespaces = split[i].replace(/\*/g, ".*?");
              if (namespaces[0] === "-") {
                createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
              } else {
                createDebug.names.push(new RegExp("^" + namespaces + "$"));
              }
            }
          }
          __name(enable, "enable");
          function disable() {
            const namespaces = [
              ...createDebug.names.map(toNamespace),
              ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }
          __name(disable, "disable");
          function enabled(name) {
            if (name[name.length - 1] === "*") {
              return true;
            }
            let i;
            let len;
            for (i = 0, len = createDebug.skips.length; i < len; i++) {
              if (createDebug.skips[i].test(name)) {
                return false;
              }
            }
            for (i = 0, len = createDebug.names.length; i < len; i++) {
              if (createDebug.names[i].test(name)) {
                return true;
              }
            }
            return false;
          }
          __name(enabled, "enabled");
          function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          __name(toNamespace, "toNamespace");
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }
          __name(coerce, "coerce");
          function destroy() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          __name(destroy, "destroy");
          createDebug.enable(createDebug.load());
          return createDebug;
        }
        __name(setup, "setup");
        module2.exports = setup;
      }
    });
    var require_browser = __commonJS({
      "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js"(exports2, module2) {
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.storage = localstorage();
        exports2.destroy = (() => {
          let warned = false;
          return () => {
            if (!warned) {
              warned = true;
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
          };
        })();
        exports2.colors = [
          "#0000CC",
          "#0000FF",
          "#0033CC",
          "#0033FF",
          "#0066CC",
          "#0066FF",
          "#0099CC",
          "#0099FF",
          "#00CC00",
          "#00CC33",
          "#00CC66",
          "#00CC99",
          "#00CCCC",
          "#00CCFF",
          "#3300CC",
          "#3300FF",
          "#3333CC",
          "#3333FF",
          "#3366CC",
          "#3366FF",
          "#3399CC",
          "#3399FF",
          "#33CC00",
          "#33CC33",
          "#33CC66",
          "#33CC99",
          "#33CCCC",
          "#33CCFF",
          "#6600CC",
          "#6600FF",
          "#6633CC",
          "#6633FF",
          "#66CC00",
          "#66CC33",
          "#9900CC",
          "#9900FF",
          "#9933CC",
          "#9933FF",
          "#99CC00",
          "#99CC33",
          "#CC0000",
          "#CC0033",
          "#CC0066",
          "#CC0099",
          "#CC00CC",
          "#CC00FF",
          "#CC3300",
          "#CC3333",
          "#CC3366",
          "#CC3399",
          "#CC33CC",
          "#CC33FF",
          "#CC6600",
          "#CC6633",
          "#CC9900",
          "#CC9933",
          "#CCCC00",
          "#CCCC33",
          "#FF0000",
          "#FF0033",
          "#FF0066",
          "#FF0099",
          "#FF00CC",
          "#FF00FF",
          "#FF3300",
          "#FF3333",
          "#FF3366",
          "#FF3399",
          "#FF33CC",
          "#FF33FF",
          "#FF6600",
          "#FF6633",
          "#FF9900",
          "#FF9933",
          "#FFCC00",
          "#FFCC33"
        ];
        function useColors() {
          if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
            return true;
          }
          if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
          }
          return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        __name(useColors, "useColors");
        function formatArgs(args) {
          args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
          if (!this.useColors) {
            return;
          }
          const c = "color: " + this.color;
          args.splice(1, 0, c, "color: inherit");
          let index = 0;
          let lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, (match) => {
            if (match === "%%") {
              return;
            }
            index++;
            if (match === "%c") {
              lastC = index;
            }
          });
          args.splice(lastC, 0, c);
        }
        __name(formatArgs, "formatArgs");
        exports2.log = console.debug || console.log || (() => {
        });
        function save(namespaces) {
          try {
            if (namespaces) {
              exports2.storage.setItem("debug", namespaces);
            } else {
              exports2.storage.removeItem("debug");
            }
          } catch (error2) {
          }
        }
        __name(save, "save");
        function load() {
          let r;
          try {
            r = exports2.storage.getItem("debug");
          } catch (error2) {
          }
          if (!r && typeof process !== "undefined" && "env" in process) {
            r = process.env.DEBUG;
          }
          return r;
        }
        __name(load, "load");
        function localstorage() {
          try {
            return localStorage;
          } catch (error2) {
          }
        }
        __name(localstorage, "localstorage");
        module2.exports = require_common()(exports2);
        var { formatters } = module2.exports;
        formatters.j = function(v) {
          try {
            return JSON.stringify(v);
          } catch (error2) {
            return "[UnexpectedJSONParseError]: " + error2.message;
          }
        };
      }
    });
    var require_node = __commonJS({
      "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js"(exports2, module2) {
        var tty = require("tty");
        var util2 = require("util");
        exports2.init = init2;
        exports2.log = log3;
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.destroy = util2.deprecate(
          () => {
          },
          "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
        );
        exports2.colors = [6, 2, 3, 4, 5, 1];
        try {
          const supportsColor = require_supports_color();
          if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
            exports2.colors = [
              20,
              21,
              26,
              27,
              32,
              33,
              38,
              39,
              40,
              41,
              42,
              43,
              44,
              45,
              56,
              57,
              62,
              63,
              68,
              69,
              74,
              75,
              76,
              77,
              78,
              79,
              80,
              81,
              92,
              93,
              98,
              99,
              112,
              113,
              128,
              129,
              134,
              135,
              148,
              149,
              160,
              161,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              171,
              172,
              173,
              178,
              179,
              184,
              185,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              203,
              204,
              205,
              206,
              207,
              208,
              209,
              214,
              215,
              220,
              221
            ];
          }
        } catch (error2) {
        }
        exports2.inspectOpts = Object.keys(process.env).filter((key) => {
          return /^debug_/i.test(key);
        }).reduce((obj, key) => {
          const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
            return k.toUpperCase();
          });
          let val = process.env[key];
          if (/^(yes|on|true|enabled)$/i.test(val)) {
            val = true;
          } else if (/^(no|off|false|disabled)$/i.test(val)) {
            val = false;
          } else if (val === "null") {
            val = null;
          } else {
            val = Number(val);
          }
          obj[prop] = val;
          return obj;
        }, {});
        function useColors() {
          return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
        }
        __name(useColors, "useColors");
        function formatArgs(args) {
          const { namespace: name, useColors: useColors2 } = this;
          if (useColors2) {
            const c = this.color;
            const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
            const prefix = `  ${colorCode};1m${name} \x1B[0m`;
            args[0] = prefix + args[0].split("\n").join("\n" + prefix);
            args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
          } else {
            args[0] = getDate() + name + " " + args[0];
          }
        }
        __name(formatArgs, "formatArgs");
        function getDate() {
          if (exports2.inspectOpts.hideDate) {
            return "";
          }
          return (/* @__PURE__ */ new Date()).toISOString() + " ";
        }
        __name(getDate, "getDate");
        function log3(...args) {
          return process.stderr.write(util2.format(...args) + "\n");
        }
        __name(log3, "log");
        function save(namespaces) {
          if (namespaces) {
            process.env.DEBUG = namespaces;
          } else {
            delete process.env.DEBUG;
          }
        }
        __name(save, "save");
        function load() {
          return process.env.DEBUG;
        }
        __name(load, "load");
        function init2(debug13) {
          debug13.inspectOpts = {};
          const keys2 = Object.keys(exports2.inspectOpts);
          for (let i = 0; i < keys2.length; i++) {
            debug13.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
          }
        }
        __name(init2, "init");
        module2.exports = require_common()(exports2);
        var { formatters } = module2.exports;
        formatters.o = function(v) {
          this.inspectOpts.colors = this.useColors;
          return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
        };
        formatters.O = function(v) {
          this.inspectOpts.colors = this.useColors;
          return util2.inspect(v, this.inspectOpts);
        };
      }
    });
    var require_src = __commonJS({
      "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js"(exports2, module2) {
        if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
          module2.exports = require_browser();
        } else {
          module2.exports = require_node();
        }
      }
    });
    var require_windows = __commonJS({
      "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports2, module2) {
        module2.exports = isexe;
        isexe.sync = sync;
        var fs11 = require("fs");
        function checkPathExt(path7, options) {
          var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
          if (!pathext) {
            return true;
          }
          pathext = pathext.split(";");
          if (pathext.indexOf("") !== -1) {
            return true;
          }
          for (var i = 0; i < pathext.length; i++) {
            var p = pathext[i].toLowerCase();
            if (p && path7.substr(-p.length).toLowerCase() === p) {
              return true;
            }
          }
          return false;
        }
        __name(checkPathExt, "checkPathExt");
        function checkStat(stat, path7, options) {
          if (!stat.isSymbolicLink() && !stat.isFile()) {
            return false;
          }
          return checkPathExt(path7, options);
        }
        __name(checkStat, "checkStat");
        function isexe(path7, options, cb) {
          fs11.stat(path7, function(er, stat) {
            cb(er, er ? false : checkStat(stat, path7, options));
          });
        }
        __name(isexe, "isexe");
        function sync(path7, options) {
          return checkStat(fs11.statSync(path7), path7, options);
        }
        __name(sync, "sync");
      }
    });
    var require_mode = __commonJS({
      "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports2, module2) {
        module2.exports = isexe;
        isexe.sync = sync;
        var fs11 = require("fs");
        function isexe(path7, options, cb) {
          fs11.stat(path7, function(er, stat) {
            cb(er, er ? false : checkStat(stat, options));
          });
        }
        __name(isexe, "isexe");
        function sync(path7, options) {
          return checkStat(fs11.statSync(path7), options);
        }
        __name(sync, "sync");
        function checkStat(stat, options) {
          return stat.isFile() && checkMode(stat, options);
        }
        __name(checkStat, "checkStat");
        function checkMode(stat, options) {
          var mod2 = stat.mode;
          var uid = stat.uid;
          var gid = stat.gid;
          var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
          var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
          var u = parseInt("100", 8);
          var g = parseInt("010", 8);
          var o = parseInt("001", 8);
          var ug = u | g;
          var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
          return ret;
        }
        __name(checkMode, "checkMode");
      }
    });
    var require_isexe = __commonJS({
      "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports2, module2) {
        var fs11 = require("fs");
        var core;
        if (process.platform === "win32" || global.TESTING_WINDOWS) {
          core = require_windows();
        } else {
          core = require_mode();
        }
        module2.exports = isexe;
        isexe.sync = sync;
        function isexe(path7, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = {};
          }
          if (!cb) {
            if (typeof Promise !== "function") {
              throw new TypeError("callback not provided");
            }
            return new Promise(function(resolve, reject) {
              isexe(path7, options || {}, function(er, is2) {
                if (er) {
                  reject(er);
                } else {
                  resolve(is2);
                }
              });
            });
          }
          core(path7, options || {}, function(er, is2) {
            if (er) {
              if (er.code === "EACCES" || options && options.ignoreErrors) {
                er = null;
                is2 = false;
              }
            }
            cb(er, is2);
          });
        }
        __name(isexe, "isexe");
        function sync(path7, options) {
          try {
            return core.sync(path7, options || {});
          } catch (er) {
            if (options && options.ignoreErrors || er.code === "EACCES") {
              return false;
            } else {
              throw er;
            }
          }
        }
        __name(sync, "sync");
      }
    });
    var require_which = __commonJS({
      "../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports2, module2) {
        var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
        var path7 = require("path");
        var COLON = isWindows ? ";" : ":";
        var isexe = require_isexe();
        var getNotFoundError = /* @__PURE__ */ __name((cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), "getNotFoundError");
        var getPathInfo = /* @__PURE__ */ __name((cmd, opt) => {
          const colon = opt.colon || COLON;
          const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
            ...isWindows ? [process.cwd()] : [],
            ...(opt.path || process.env.PATH || "").split(colon)
          ];
          const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
          const pathExt = isWindows ? pathExtExe.split(colon) : [""];
          if (isWindows) {
            if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
              pathExt.unshift("");
          }
          return {
            pathEnv,
            pathExt,
            pathExtExe
          };
        }, "getPathInfo");
        var which = /* @__PURE__ */ __name((cmd, opt, cb) => {
          if (typeof opt === "function") {
            cb = opt;
            opt = {};
          }
          if (!opt)
            opt = {};
          const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
          const found = [];
          const step = /* @__PURE__ */ __name((i) => new Promise((resolve, reject) => {
            if (i === pathEnv.length)
              return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = path7.join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            resolve(subStep(p, i, 0));
          }), "step");
          const subStep = /* @__PURE__ */ __name((p, i, ii) => new Promise((resolve, reject) => {
            if (ii === pathExt.length)
              return resolve(step(i + 1));
            const ext = pathExt[ii];
            isexe(p + ext, { pathExt: pathExtExe }, (er, is2) => {
              if (!er && is2) {
                if (opt.all)
                  found.push(p + ext);
                else
                  return resolve(p + ext);
              }
              return resolve(subStep(p, i, ii + 1));
            });
          }), "subStep");
          return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
        }, "which");
        var whichSync = /* @__PURE__ */ __name((cmd, opt) => {
          opt = opt || {};
          const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
          const found = [];
          for (let i = 0; i < pathEnv.length; i++) {
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = path7.join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            for (let j = 0; j < pathExt.length; j++) {
              const cur = p + pathExt[j];
              try {
                const is2 = isexe.sync(cur, { pathExt: pathExtExe });
                if (is2) {
                  if (opt.all)
                    found.push(cur);
                  else
                    return cur;
                }
              } catch (ex) {
              }
            }
          }
          if (opt.all && found.length)
            return found;
          if (opt.nothrow)
            return null;
          throw getNotFoundError(cmd);
        }, "whichSync");
        module2.exports = which;
        which.sync = whichSync;
      }
    });
    var require_path_key = __commonJS({
      "../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports2, module2) {
        "use strict";
        var pathKey = /* @__PURE__ */ __name((options = {}) => {
          const environment = options.env || process.env;
          const platform3 = options.platform || process.platform;
          if (platform3 !== "win32") {
            return "PATH";
          }
          return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
        }, "pathKey");
        module2.exports = pathKey;
        module2.exports.default = pathKey;
      }
    });
    var require_resolveCommand = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var which = require_which();
        var getPathKey = require_path_key();
        function resolveCommandAttempt(parsed, withoutPathExt) {
          const env2 = parsed.options.env || process.env;
          const cwd = process.cwd();
          const hasCustomCwd = parsed.options.cwd != null;
          const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
          if (shouldSwitchCwd) {
            try {
              process.chdir(parsed.options.cwd);
            } catch (err) {
            }
          }
          let resolved;
          try {
            resolved = which.sync(parsed.command, {
              path: env2[getPathKey({ env: env2 })],
              pathExt: withoutPathExt ? path7.delimiter : void 0
            });
          } catch (e) {
          } finally {
            if (shouldSwitchCwd) {
              process.chdir(cwd);
            }
          }
          if (resolved) {
            resolved = path7.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
          }
          return resolved;
        }
        __name(resolveCommandAttempt, "resolveCommandAttempt");
        function resolveCommand(parsed) {
          return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
        }
        __name(resolveCommand, "resolveCommand");
        module2.exports = resolveCommand;
      }
    });
    var require_escape = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
        "use strict";
        var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
        function escapeCommand(arg2) {
          arg2 = arg2.replace(metaCharsRegExp, "^$1");
          return arg2;
        }
        __name(escapeCommand, "escapeCommand");
        function escapeArgument(arg2, doubleEscapeMetaChars) {
          arg2 = `${arg2}`;
          arg2 = arg2.replace(/(\\*)"/g, '$1$1\\"');
          arg2 = arg2.replace(/(\\*)$/, "$1$1");
          arg2 = `"${arg2}"`;
          arg2 = arg2.replace(metaCharsRegExp, "^$1");
          if (doubleEscapeMetaChars) {
            arg2 = arg2.replace(metaCharsRegExp, "^$1");
          }
          return arg2;
        }
        __name(escapeArgument, "escapeArgument");
        module2.exports.command = escapeCommand;
        module2.exports.argument = escapeArgument;
      }
    });
    var require_shebang_regex = __commonJS({
      "../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports2, module2) {
        "use strict";
        module2.exports = /^#!(.*)/;
      }
    });
    var require_shebang_command = __commonJS({
      "../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports2, module2) {
        "use strict";
        var shebangRegex = require_shebang_regex();
        module2.exports = (string = "") => {
          const match = string.match(shebangRegex);
          if (!match) {
            return null;
          }
          const [path7, argument] = match[0].replace(/#! ?/, "").split(" ");
          const binary = path7.split("/").pop();
          if (binary === "env") {
            return argument;
          }
          return argument ? `${binary} ${argument}` : binary;
        };
      }
    });
    var require_readShebang = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
        "use strict";
        var fs11 = require("fs");
        var shebangCommand = require_shebang_command();
        function readShebang(command) {
          const size = 150;
          const buffer = Buffer.alloc(size);
          let fd;
          try {
            fd = fs11.openSync(command, "r");
            fs11.readSync(fd, buffer, 0, size, 0);
            fs11.closeSync(fd);
          } catch (e) {
          }
          return shebangCommand(buffer.toString());
        }
        __name(readShebang, "readShebang");
        module2.exports = readShebang;
      }
    });
    var require_parse = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var resolveCommand = require_resolveCommand();
        var escape = require_escape();
        var readShebang = require_readShebang();
        var isWin = process.platform === "win32";
        var isExecutableRegExp = /\.(?:com|exe)$/i;
        var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
        function detectShebang(parsed) {
          parsed.file = resolveCommand(parsed);
          const shebang = parsed.file && readShebang(parsed.file);
          if (shebang) {
            parsed.args.unshift(parsed.file);
            parsed.command = shebang;
            return resolveCommand(parsed);
          }
          return parsed.file;
        }
        __name(detectShebang, "detectShebang");
        function parseNonShell(parsed) {
          if (!isWin) {
            return parsed;
          }
          const commandFile = detectShebang(parsed);
          const needsShell = !isExecutableRegExp.test(commandFile);
          if (parsed.options.forceShell || needsShell) {
            const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
            parsed.command = path7.normalize(parsed.command);
            parsed.command = escape.command(parsed.command);
            parsed.args = parsed.args.map((arg2) => escape.argument(arg2, needsDoubleEscapeMetaChars));
            const shellCommand = [parsed.command].concat(parsed.args).join(" ");
            parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
            parsed.command = process.env.comspec || "cmd.exe";
            parsed.options.windowsVerbatimArguments = true;
          }
          return parsed;
        }
        __name(parseNonShell, "parseNonShell");
        function parse2(command, args, options) {
          if (args && !Array.isArray(args)) {
            options = args;
            args = null;
          }
          args = args ? args.slice(0) : [];
          options = Object.assign({}, options);
          const parsed = {
            command,
            args,
            options,
            file: void 0,
            original: {
              command,
              args
            }
          };
          return options.shell ? parsed : parseNonShell(parsed);
        }
        __name(parse2, "parse");
        module2.exports = parse2;
      }
    });
    var require_enoent = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
        "use strict";
        var isWin = process.platform === "win32";
        function notFoundError(original, syscall) {
          return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
            code: "ENOENT",
            errno: "ENOENT",
            syscall: `${syscall} ${original.command}`,
            path: original.command,
            spawnargs: original.args
          });
        }
        __name(notFoundError, "notFoundError");
        function hookChildProcess(cp, parsed) {
          if (!isWin) {
            return;
          }
          const originalEmit = cp.emit;
          cp.emit = function(name, arg1) {
            if (name === "exit") {
              const err = verifyENOENT(arg1, parsed, "spawn");
              if (err) {
                return originalEmit.call(cp, "error", err);
              }
            }
            return originalEmit.apply(cp, arguments);
          };
        }
        __name(hookChildProcess, "hookChildProcess");
        function verifyENOENT(status, parsed) {
          if (isWin && status === 1 && !parsed.file) {
            return notFoundError(parsed.original, "spawn");
          }
          return null;
        }
        __name(verifyENOENT, "verifyENOENT");
        function verifyENOENTSync(status, parsed) {
          if (isWin && status === 1 && !parsed.file) {
            return notFoundError(parsed.original, "spawnSync");
          }
          return null;
        }
        __name(verifyENOENTSync, "verifyENOENTSync");
        module2.exports = {
          hookChildProcess,
          verifyENOENT,
          verifyENOENTSync,
          notFoundError
        };
      }
    });
    var require_cross_spawn = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js"(exports2, module2) {
        "use strict";
        var cp = require("child_process");
        var parse2 = require_parse();
        var enoent = require_enoent();
        function spawn2(command, args, options) {
          const parsed = parse2(command, args, options);
          const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
          enoent.hookChildProcess(spawned, parsed);
          return spawned;
        }
        __name(spawn2, "spawn");
        function spawnSync(command, args, options) {
          const parsed = parse2(command, args, options);
          const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
          result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
          return result;
        }
        __name(spawnSync, "spawnSync");
        module2.exports = spawn2;
        module2.exports.spawn = spawn2;
        module2.exports.sync = spawnSync;
        module2.exports._parse = parse2;
        module2.exports._enoent = enoent;
      }
    });
    var require_strip_final_newline = __commonJS({
      "../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (input) => {
          const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
          const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
          if (input[input.length - 1] === LF) {
            input = input.slice(0, input.length - 1);
          }
          if (input[input.length - 1] === CR) {
            input = input.slice(0, input.length - 1);
          }
          return input;
        };
      }
    });
    var require_npm_run_path = __commonJS({
      "../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var pathKey = require_path_key();
        var npmRunPath = /* @__PURE__ */ __name((options) => {
          options = {
            cwd: process.cwd(),
            path: process.env[pathKey()],
            execPath: process.execPath,
            ...options
          };
          let previous;
          let cwdPath = path7.resolve(options.cwd);
          const result = [];
          while (previous !== cwdPath) {
            result.push(path7.join(cwdPath, "node_modules/.bin"));
            previous = cwdPath;
            cwdPath = path7.resolve(cwdPath, "..");
          }
          const execPathDir = path7.resolve(options.cwd, options.execPath, "..");
          result.push(execPathDir);
          return result.concat(options.path).join(path7.delimiter);
        }, "npmRunPath");
        module2.exports = npmRunPath;
        module2.exports.default = npmRunPath;
        module2.exports.env = (options) => {
          options = {
            env: process.env,
            ...options
          };
          const env2 = { ...options.env };
          const path8 = pathKey({ env: env2 });
          options.path = env2[path8];
          env2[path8] = module2.exports(options);
          return env2;
        };
      }
    });
    var require_mimic_fn = __commonJS({
      "../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js"(exports2, module2) {
        "use strict";
        var mimicFn = /* @__PURE__ */ __name((to, from) => {
          for (const prop of Reflect.ownKeys(from)) {
            Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
          }
          return to;
        }, "mimicFn");
        module2.exports = mimicFn;
        module2.exports.default = mimicFn;
      }
    });
    var require_onetime = __commonJS({
      "../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js"(exports2, module2) {
        "use strict";
        var mimicFn = require_mimic_fn();
        var calledFunctions = /* @__PURE__ */ new WeakMap();
        var onetime = /* @__PURE__ */ __name((function_, options = {}) => {
          if (typeof function_ !== "function") {
            throw new TypeError("Expected a function");
          }
          let returnValue;
          let callCount = 0;
          const functionName = function_.displayName || function_.name || "<anonymous>";
          const onetime2 = /* @__PURE__ */ __name(function(...arguments_) {
            calledFunctions.set(onetime2, ++callCount);
            if (callCount === 1) {
              returnValue = function_.apply(this, arguments_);
              function_ = null;
            } else if (options.throw === true) {
              throw new Error(`Function \`${functionName}\` can only be called once`);
            }
            return returnValue;
          }, "onetime");
          mimicFn(onetime2, function_);
          calledFunctions.set(onetime2, callCount);
          return onetime2;
        }, "onetime");
        module2.exports = onetime;
        module2.exports.default = onetime;
        module2.exports.callCount = (function_) => {
          if (!calledFunctions.has(function_)) {
            throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
          }
          return calledFunctions.get(function_);
        };
      }
    });
    var require_core = __commonJS({
      "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.SIGNALS = void 0;
        var SIGNALS = [
          {
            name: "SIGHUP",
            number: 1,
            action: "terminate",
            description: "Terminal closed",
            standard: "posix"
          },
          {
            name: "SIGINT",
            number: 2,
            action: "terminate",
            description: "User interruption with CTRL-C",
            standard: "ansi"
          },
          {
            name: "SIGQUIT",
            number: 3,
            action: "core",
            description: "User interruption with CTRL-\\",
            standard: "posix"
          },
          {
            name: "SIGILL",
            number: 4,
            action: "core",
            description: "Invalid machine instruction",
            standard: "ansi"
          },
          {
            name: "SIGTRAP",
            number: 5,
            action: "core",
            description: "Debugger breakpoint",
            standard: "posix"
          },
          {
            name: "SIGABRT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "ansi"
          },
          {
            name: "SIGIOT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "bsd"
          },
          {
            name: "SIGBUS",
            number: 7,
            action: "core",
            description: "Bus error due to misaligned, non-existing address or paging error",
            standard: "bsd"
          },
          {
            name: "SIGEMT",
            number: 7,
            action: "terminate",
            description: "Command should be emulated but is not implemented",
            standard: "other"
          },
          {
            name: "SIGFPE",
            number: 8,
            action: "core",
            description: "Floating point arithmetic error",
            standard: "ansi"
          },
          {
            name: "SIGKILL",
            number: 9,
            action: "terminate",
            description: "Forced termination",
            standard: "posix",
            forced: true
          },
          {
            name: "SIGUSR1",
            number: 10,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
          },
          {
            name: "SIGSEGV",
            number: 11,
            action: "core",
            description: "Segmentation fault",
            standard: "ansi"
          },
          {
            name: "SIGUSR2",
            number: 12,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
          },
          {
            name: "SIGPIPE",
            number: 13,
            action: "terminate",
            description: "Broken pipe or socket",
            standard: "posix"
          },
          {
            name: "SIGALRM",
            number: 14,
            action: "terminate",
            description: "Timeout or timer",
            standard: "posix"
          },
          {
            name: "SIGTERM",
            number: 15,
            action: "terminate",
            description: "Termination",
            standard: "ansi"
          },
          {
            name: "SIGSTKFLT",
            number: 16,
            action: "terminate",
            description: "Stack is empty or overflowed",
            standard: "other"
          },
          {
            name: "SIGCHLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "posix"
          },
          {
            name: "SIGCLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "other"
          },
          {
            name: "SIGCONT",
            number: 18,
            action: "unpause",
            description: "Unpaused",
            standard: "posix",
            forced: true
          },
          {
            name: "SIGSTOP",
            number: 19,
            action: "pause",
            description: "Paused",
            standard: "posix",
            forced: true
          },
          {
            name: "SIGTSTP",
            number: 20,
            action: "pause",
            description: 'Paused using CTRL-Z or "suspend"',
            standard: "posix"
          },
          {
            name: "SIGTTIN",
            number: 21,
            action: "pause",
            description: "Background process cannot read terminal input",
            standard: "posix"
          },
          {
            name: "SIGBREAK",
            number: 21,
            action: "terminate",
            description: "User interruption with CTRL-BREAK",
            standard: "other"
          },
          {
            name: "SIGTTOU",
            number: 22,
            action: "pause",
            description: "Background process cannot write to terminal output",
            standard: "posix"
          },
          {
            name: "SIGURG",
            number: 23,
            action: "ignore",
            description: "Socket received out-of-band data",
            standard: "bsd"
          },
          {
            name: "SIGXCPU",
            number: 24,
            action: "core",
            description: "Process timed out",
            standard: "bsd"
          },
          {
            name: "SIGXFSZ",
            number: 25,
            action: "core",
            description: "File too big",
            standard: "bsd"
          },
          {
            name: "SIGVTALRM",
            number: 26,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
          },
          {
            name: "SIGPROF",
            number: 27,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
          },
          {
            name: "SIGWINCH",
            number: 28,
            action: "ignore",
            description: "Terminal window size changed",
            standard: "bsd"
          },
          {
            name: "SIGIO",
            number: 29,
            action: "terminate",
            description: "I/O is available",
            standard: "other"
          },
          {
            name: "SIGPOLL",
            number: 29,
            action: "terminate",
            description: "Watched event",
            standard: "other"
          },
          {
            name: "SIGINFO",
            number: 29,
            action: "ignore",
            description: "Request for process information",
            standard: "other"
          },
          {
            name: "SIGPWR",
            number: 30,
            action: "terminate",
            description: "Device running out of power",
            standard: "systemv"
          },
          {
            name: "SIGSYS",
            number: 31,
            action: "core",
            description: "Invalid system call",
            standard: "other"
          },
          {
            name: "SIGUNUSED",
            number: 31,
            action: "terminate",
            description: "Invalid system call",
            standard: "other"
          }
        ];
        exports2.SIGNALS = SIGNALS;
      }
    });
    var require_realtime = __commonJS({
      "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
        var getRealtimeSignals = /* @__PURE__ */ __name(function() {
          const length = SIGRTMAX - SIGRTMIN + 1;
          return Array.from({ length }, getRealtimeSignal);
        }, "getRealtimeSignals");
        exports2.getRealtimeSignals = getRealtimeSignals;
        var getRealtimeSignal = /* @__PURE__ */ __name(function(value, index) {
          return {
            name: `SIGRT${index + 1}`,
            number: SIGRTMIN + index,
            action: "terminate",
            description: "Application-specific signal (realtime)",
            standard: "posix"
          };
        }, "getRealtimeSignal");
        var SIGRTMIN = 34;
        var SIGRTMAX = 64;
        exports2.SIGRTMAX = SIGRTMAX;
      }
    });
    var require_signals = __commonJS({
      "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.getSignals = void 0;
        var _os = require("os");
        var _core = require_core();
        var _realtime = require_realtime();
        var getSignals = /* @__PURE__ */ __name(function() {
          const realtimeSignals = (0, _realtime.getRealtimeSignals)();
          const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
          return signals;
        }, "getSignals");
        exports2.getSignals = getSignals;
        var normalizeSignal = /* @__PURE__ */ __name(function({
          name,
          number: defaultNumber,
          description,
          action,
          forced = false,
          standard
        }) {
          const {
            signals: { [name]: constantSignal }
          } = _os.constants;
          const supported = constantSignal !== void 0;
          const number = supported ? constantSignal : defaultNumber;
          return { name, number, description, supported, action, forced, standard };
        }, "normalizeSignal");
      }
    });
    var require_main = __commonJS({
      "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.signalsByNumber = exports2.signalsByName = void 0;
        var _os = require("os");
        var _signals = require_signals();
        var _realtime = require_realtime();
        var getSignalsByName = /* @__PURE__ */ __name(function() {
          const signals = (0, _signals.getSignals)();
          return signals.reduce(getSignalByName, {});
        }, "getSignalsByName");
        var getSignalByName = /* @__PURE__ */ __name(function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
          return {
            ...signalByNameMemo,
            [name]: { name, number, description, supported, action, forced, standard }
          };
        }, "getSignalByName");
        var signalsByName = getSignalsByName();
        exports2.signalsByName = signalsByName;
        var getSignalsByNumber = /* @__PURE__ */ __name(function() {
          const signals = (0, _signals.getSignals)();
          const length = _realtime.SIGRTMAX + 1;
          const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
          return Object.assign({}, ...signalsA);
        }, "getSignalsByNumber");
        var getSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {
          const signal = findSignalByNumber(number, signals);
          if (signal === void 0) {
            return {};
          }
          const { name, description, supported, action, forced, standard } = signal;
          return {
            [number]: {
              name,
              number,
              description,
              supported,
              action,
              forced,
              standard
            }
          };
        }, "getSignalByNumber");
        var findSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {
          const signal = signals.find(({ name }) => _os.constants.signals[name] === number);
          if (signal !== void 0) {
            return signal;
          }
          return signals.find((signalA) => signalA.number === number);
        }, "findSignalByNumber");
        var signalsByNumber = getSignalsByNumber();
        exports2.signalsByNumber = signalsByNumber;
      }
    });
    var require_error = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js"(exports2, module2) {
        "use strict";
        var { signalsByName } = require_main();
        var getErrorPrefix = /* @__PURE__ */ __name(({ timedOut: timedOut2, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
          if (timedOut2) {
            return `timed out after ${timeout} milliseconds`;
          }
          if (isCanceled) {
            return "was canceled";
          }
          if (errorCode !== void 0) {
            return `failed with ${errorCode}`;
          }
          if (signal !== void 0) {
            return `was killed with ${signal} (${signalDescription})`;
          }
          if (exitCode !== void 0) {
            return `failed with exit code ${exitCode}`;
          }
          return "failed";
        }, "getErrorPrefix");
        var makeError = /* @__PURE__ */ __name(({
          stdout,
          stderr,
          all: all5,
          error: error2,
          signal,
          exitCode,
          command,
          escapedCommand,
          timedOut: timedOut2,
          isCanceled,
          killed,
          parsed: { options: { timeout } }
        }) => {
          exitCode = exitCode === null ? void 0 : exitCode;
          signal = signal === null ? void 0 : signal;
          const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
          const errorCode = error2 && error2.code;
          const prefix = getErrorPrefix({ timedOut: timedOut2, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
          const execaMessage = `Command ${prefix}: ${command}`;
          const isError2 = Object.prototype.toString.call(error2) === "[object Error]";
          const shortMessage = isError2 ? `${execaMessage}
${error2.message}` : execaMessage;
          const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
          if (isError2) {
            error2.originalMessage = error2.message;
            error2.message = message;
          } else {
            error2 = new Error(message);
          }
          error2.shortMessage = shortMessage;
          error2.command = command;
          error2.escapedCommand = escapedCommand;
          error2.exitCode = exitCode;
          error2.signal = signal;
          error2.signalDescription = signalDescription;
          error2.stdout = stdout;
          error2.stderr = stderr;
          if (all5 !== void 0) {
            error2.all = all5;
          }
          if ("bufferedData" in error2) {
            delete error2.bufferedData;
          }
          error2.failed = true;
          error2.timedOut = Boolean(timedOut2);
          error2.isCanceled = isCanceled;
          error2.killed = killed && !timedOut2;
          return error2;
        }, "makeError");
        module2.exports = makeError;
      }
    });
    var require_stdio = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js"(exports2, module2) {
        "use strict";
        var aliases2 = ["stdin", "stdout", "stderr"];
        var hasAlias = /* @__PURE__ */ __name((options) => aliases2.some((alias) => options[alias] !== void 0), "hasAlias");
        var normalizeStdio = /* @__PURE__ */ __name((options) => {
          if (!options) {
            return;
          }
          const { stdio } = options;
          if (stdio === void 0) {
            return aliases2.map((alias) => options[alias]);
          }
          if (hasAlias(options)) {
            throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases2.map((alias) => `\`${alias}\``).join(", ")}`);
          }
          if (typeof stdio === "string") {
            return stdio;
          }
          if (!Array.isArray(stdio)) {
            throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
          }
          const length = Math.max(stdio.length, aliases2.length);
          return Array.from({ length }, (value, index) => stdio[index]);
        }, "normalizeStdio");
        module2.exports = normalizeStdio;
        module2.exports.node = (options) => {
          const stdio = normalizeStdio(options);
          if (stdio === "ipc") {
            return "ipc";
          }
          if (stdio === void 0 || typeof stdio === "string") {
            return [stdio, stdio, stdio, "ipc"];
          }
          if (stdio.includes("ipc")) {
            return stdio;
          }
          return [...stdio, "ipc"];
        };
      }
    });
    var require_signals2 = __commonJS({
      "../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js"(exports2, module2) {
        module2.exports = [
          "SIGABRT",
          "SIGALRM",
          "SIGHUP",
          "SIGINT",
          "SIGTERM"
        ];
        if (process.platform !== "win32") {
          module2.exports.push(
            "SIGVTALRM",
            "SIGXCPU",
            "SIGXFSZ",
            "SIGUSR2",
            "SIGTRAP",
            "SIGSYS",
            "SIGQUIT",
            "SIGIOT"
          );
        }
        if (process.platform === "linux") {
          module2.exports.push(
            "SIGIO",
            "SIGPOLL",
            "SIGPWR",
            "SIGSTKFLT",
            "SIGUNUSED"
          );
        }
      }
    });
    var require_signal_exit = __commonJS({
      "../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js"(exports2, module2) {
        var process22 = global.process;
        var processOk = /* @__PURE__ */ __name(function(process32) {
          return process32 && typeof process32 === "object" && typeof process32.removeListener === "function" && typeof process32.emit === "function" && typeof process32.reallyExit === "function" && typeof process32.listeners === "function" && typeof process32.kill === "function" && typeof process32.pid === "number" && typeof process32.on === "function";
        }, "processOk");
        if (!processOk(process22)) {
          module2.exports = function() {
            return function() {
            };
          };
        } else {
          assert2 = require("assert");
          signals = require_signals2();
          isWin = /^win/i.test(process22.platform);
          EE = require("events");
          if (typeof EE !== "function") {
            EE = EE.EventEmitter;
          }
          if (process22.__signal_exit_emitter__) {
            emitter = process22.__signal_exit_emitter__;
          } else {
            emitter = process22.__signal_exit_emitter__ = new EE();
            emitter.count = 0;
            emitter.emitted = {};
          }
          if (!emitter.infinite) {
            emitter.setMaxListeners(Infinity);
            emitter.infinite = true;
          }
          module2.exports = function(cb, opts) {
            if (!processOk(global.process)) {
              return function() {
              };
            }
            assert2.equal(typeof cb, "function", "a callback must be provided for exit handler");
            if (loaded === false) {
              load();
            }
            var ev = "exit";
            if (opts && opts.alwaysLast) {
              ev = "afterexit";
            }
            var remove = /* @__PURE__ */ __name(function() {
              emitter.removeListener(ev, cb);
              if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
                unload();
              }
            }, "remove");
            emitter.on(ev, cb);
            return remove;
          };
          unload = /* @__PURE__ */ __name(function unload2() {
            if (!loaded || !processOk(global.process)) {
              return;
            }
            loaded = false;
            signals.forEach(function(sig) {
              try {
                process22.removeListener(sig, sigListeners[sig]);
              } catch (er) {
              }
            });
            process22.emit = originalProcessEmit;
            process22.reallyExit = originalProcessReallyExit;
            emitter.count -= 1;
          }, "unload");
          module2.exports.unload = unload;
          emit = /* @__PURE__ */ __name(function emit2(event, code, signal) {
            if (emitter.emitted[event]) {
              return;
            }
            emitter.emitted[event] = true;
            emitter.emit(event, code, signal);
          }, "emit");
          sigListeners = {};
          signals.forEach(function(sig) {
            sigListeners[sig] = /* @__PURE__ */ __name(function listener() {
              if (!processOk(global.process)) {
                return;
              }
              var listeners = process22.listeners(sig);
              if (listeners.length === emitter.count) {
                unload();
                emit("exit", null, sig);
                emit("afterexit", null, sig);
                if (isWin && sig === "SIGHUP") {
                  sig = "SIGINT";
                }
                process22.kill(process22.pid, sig);
              }
            }, "listener");
          });
          module2.exports.signals = function() {
            return signals;
          };
          loaded = false;
          load = /* @__PURE__ */ __name(function load2() {
            if (loaded || !processOk(global.process)) {
              return;
            }
            loaded = true;
            emitter.count += 1;
            signals = signals.filter(function(sig) {
              try {
                process22.on(sig, sigListeners[sig]);
                return true;
              } catch (er) {
                return false;
              }
            });
            process22.emit = processEmit;
            process22.reallyExit = processReallyExit;
          }, "load");
          module2.exports.load = load;
          originalProcessReallyExit = process22.reallyExit;
          processReallyExit = /* @__PURE__ */ __name(function processReallyExit2(code) {
            if (!processOk(global.process)) {
              return;
            }
            process22.exitCode = code || 0;
            emit("exit", process22.exitCode, null);
            emit("afterexit", process22.exitCode, null);
            originalProcessReallyExit.call(process22, process22.exitCode);
          }, "processReallyExit");
          originalProcessEmit = process22.emit;
          processEmit = /* @__PURE__ */ __name(function processEmit2(ev, arg2) {
            if (ev === "exit" && processOk(global.process)) {
              if (arg2 !== void 0) {
                process22.exitCode = arg2;
              }
              var ret = originalProcessEmit.apply(this, arguments);
              emit("exit", process22.exitCode, null);
              emit("afterexit", process22.exitCode, null);
              return ret;
            } else {
              return originalProcessEmit.apply(this, arguments);
            }
          }, "processEmit");
        }
        var assert2;
        var signals;
        var isWin;
        var EE;
        var emitter;
        var unload;
        var emit;
        var sigListeners;
        var loaded;
        var load;
        var originalProcessReallyExit;
        var processReallyExit;
        var originalProcessEmit;
        var processEmit;
      }
    });
    var require_kill = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js"(exports2, module2) {
        "use strict";
        var os32 = require("os");
        var onExit = require_signal_exit();
        var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
        var spawnedKill = /* @__PURE__ */ __name((kill, signal = "SIGTERM", options = {}) => {
          const killResult = kill(signal);
          setKillTimeout(kill, signal, options, killResult);
          return killResult;
        }, "spawnedKill");
        var setKillTimeout = /* @__PURE__ */ __name((kill, signal, options, killResult) => {
          if (!shouldForceKill(signal, options, killResult)) {
            return;
          }
          const timeout = getForceKillAfterTimeout(options);
          const t = setTimeout(() => {
            kill("SIGKILL");
          }, timeout);
          if (t.unref) {
            t.unref();
          }
        }, "setKillTimeout");
        var shouldForceKill = /* @__PURE__ */ __name((signal, { forceKillAfterTimeout }, killResult) => {
          return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
        }, "shouldForceKill");
        var isSigterm = /* @__PURE__ */ __name((signal) => {
          return signal === os32.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
        }, "isSigterm");
        var getForceKillAfterTimeout = /* @__PURE__ */ __name(({ forceKillAfterTimeout = true }) => {
          if (forceKillAfterTimeout === true) {
            return DEFAULT_FORCE_KILL_TIMEOUT;
          }
          if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
            throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
          }
          return forceKillAfterTimeout;
        }, "getForceKillAfterTimeout");
        var spawnedCancel = /* @__PURE__ */ __name((spawned, context3) => {
          const killResult = spawned.kill();
          if (killResult) {
            context3.isCanceled = true;
          }
        }, "spawnedCancel");
        var timeoutKill = /* @__PURE__ */ __name((spawned, signal, reject) => {
          spawned.kill(signal);
          reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
        }, "timeoutKill");
        var setupTimeout = /* @__PURE__ */ __name((spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
          if (timeout === 0 || timeout === void 0) {
            return spawnedPromise;
          }
          let timeoutId;
          const timeoutPromise = new Promise((resolve, reject) => {
            timeoutId = setTimeout(() => {
              timeoutKill(spawned, killSignal, reject);
            }, timeout);
          });
          const safeSpawnedPromise = spawnedPromise.finally(() => {
            clearTimeout(timeoutId);
          });
          return Promise.race([timeoutPromise, safeSpawnedPromise]);
        }, "setupTimeout");
        var validateTimeout = /* @__PURE__ */ __name(({ timeout }) => {
          if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
            throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
          }
        }, "validateTimeout");
        var setExitHandler = /* @__PURE__ */ __name(async (spawned, { cleanup, detached }, timedPromise) => {
          if (!cleanup || detached) {
            return timedPromise;
          }
          const removeExitHandler = onExit(() => {
            spawned.kill();
          });
          return timedPromise.finally(() => {
            removeExitHandler();
          });
        }, "setExitHandler");
        module2.exports = {
          spawnedKill,
          spawnedCancel,
          setupTimeout,
          validateTimeout,
          setExitHandler
        };
      }
    });
    var require_is_stream = __commonJS({
      "../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js"(exports2, module2) {
        "use strict";
        var isStream2 = /* @__PURE__ */ __name((stream22) => stream22 !== null && typeof stream22 === "object" && typeof stream22.pipe === "function", "isStream");
        isStream2.writable = (stream22) => isStream2(stream22) && stream22.writable !== false && typeof stream22._write === "function" && typeof stream22._writableState === "object";
        isStream2.readable = (stream22) => isStream2(stream22) && stream22.readable !== false && typeof stream22._read === "function" && typeof stream22._readableState === "object";
        isStream2.duplex = (stream22) => isStream2.writable(stream22) && isStream2.readable(stream22);
        isStream2.transform = (stream22) => isStream2.duplex(stream22) && typeof stream22._transform === "function";
        module2.exports = isStream2;
      }
    });
    var require_buffer_stream = __commonJS({
      "../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
        "use strict";
        var { PassThrough: PassThroughStream2 } = require("stream");
        module2.exports = (options) => {
          options = { ...options };
          const { array } = options;
          let { encoding } = options;
          const isBuffer2 = encoding === "buffer";
          let objectMode = false;
          if (array) {
            objectMode = !(encoding || isBuffer2);
          } else {
            encoding = encoding || "utf8";
          }
          if (isBuffer2) {
            encoding = null;
          }
          const stream22 = new PassThroughStream2({ objectMode });
          if (encoding) {
            stream22.setEncoding(encoding);
          }
          let length = 0;
          const chunks = [];
          stream22.on("data", (chunk) => {
            chunks.push(chunk);
            if (objectMode) {
              length = chunks.length;
            } else {
              length += chunk.length;
            }
          });
          stream22.getBufferedValue = () => {
            if (array) {
              return chunks;
            }
            return isBuffer2 ? Buffer.concat(chunks, length) : chunks.join("");
          };
          stream22.getBufferedLength = () => length;
          return stream22;
        };
      }
    });
    var require_get_stream = __commonJS({
      "../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js"(exports2, module2) {
        "use strict";
        var { constants: BufferConstants } = require("buffer");
        var stream22 = require("stream");
        var { promisify: promisify4 } = require("util");
        var bufferStream = require_buffer_stream();
        var streamPipelinePromisified = promisify4(stream22.pipeline);
        var MaxBufferError = class extends Error {
          constructor() {
            super("maxBuffer exceeded");
            this.name = "MaxBufferError";
          }
        };
        __name(MaxBufferError, "MaxBufferError");
        async function getStream2(inputStream, options) {
          if (!inputStream) {
            throw new Error("Expected a stream");
          }
          options = {
            maxBuffer: Infinity,
            ...options
          };
          const { maxBuffer } = options;
          const stream32 = bufferStream(options);
          await new Promise((resolve, reject) => {
            const rejectPromise = /* @__PURE__ */ __name((error2) => {
              if (error2 && stream32.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
                error2.bufferedData = stream32.getBufferedValue();
              }
              reject(error2);
            }, "rejectPromise");
            (async () => {
              try {
                await streamPipelinePromisified(inputStream, stream32);
                resolve();
              } catch (error2) {
                rejectPromise(error2);
              }
            })();
            stream32.on("data", () => {
              if (stream32.getBufferedLength() > maxBuffer) {
                rejectPromise(new MaxBufferError());
              }
            });
          });
          return stream32.getBufferedValue();
        }
        __name(getStream2, "getStream");
        module2.exports = getStream2;
        module2.exports.buffer = (stream32, options) => getStream2(stream32, { ...options, encoding: "buffer" });
        module2.exports.array = (stream32, options) => getStream2(stream32, { ...options, array: true });
        module2.exports.MaxBufferError = MaxBufferError;
      }
    });
    var require_merge_stream = __commonJS({
      "../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js"(exports2, module2) {
        "use strict";
        var { PassThrough } = require("stream");
        module2.exports = function() {
          var sources = [];
          var output = new PassThrough({ objectMode: true });
          output.setMaxListeners(0);
          output.add = add2;
          output.isEmpty = isEmpty;
          output.on("unpipe", remove);
          Array.prototype.slice.call(arguments).forEach(add2);
          return output;
          function add2(source) {
            if (Array.isArray(source)) {
              source.forEach(add2);
              return this;
            }
            sources.push(source);
            source.once("end", remove.bind(null, source));
            source.once("error", output.emit.bind(output, "error"));
            source.pipe(output, { end: false });
            return this;
          }
          __name(add2, "add");
          function isEmpty() {
            return sources.length == 0;
          }
          __name(isEmpty, "isEmpty");
          function remove(source) {
            sources = sources.filter(function(it) {
              return it !== source;
            });
            if (!sources.length && output.readable) {
              output.end();
            }
          }
          __name(remove, "remove");
        };
      }
    });
    var require_stream = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js"(exports2, module2) {
        "use strict";
        var isStream2 = require_is_stream();
        var getStream2 = require_get_stream();
        var mergeStream = require_merge_stream();
        var handleInput = /* @__PURE__ */ __name((spawned, input) => {
          if (input === void 0 || spawned.stdin === void 0) {
            return;
          }
          if (isStream2(input)) {
            input.pipe(spawned.stdin);
          } else {
            spawned.stdin.end(input);
          }
        }, "handleInput");
        var makeAllStream = /* @__PURE__ */ __name((spawned, { all: all5 }) => {
          if (!all5 || !spawned.stdout && !spawned.stderr) {
            return;
          }
          const mixed = mergeStream();
          if (spawned.stdout) {
            mixed.add(spawned.stdout);
          }
          if (spawned.stderr) {
            mixed.add(spawned.stderr);
          }
          return mixed;
        }, "makeAllStream");
        var getBufferedData = /* @__PURE__ */ __name(async (stream22, streamPromise) => {
          if (!stream22) {
            return;
          }
          stream22.destroy();
          try {
            return await streamPromise;
          } catch (error2) {
            return error2.bufferedData;
          }
        }, "getBufferedData");
        var getStreamPromise = /* @__PURE__ */ __name((stream22, { encoding, buffer, maxBuffer }) => {
          if (!stream22 || !buffer) {
            return;
          }
          if (encoding) {
            return getStream2(stream22, { encoding, maxBuffer });
          }
          return getStream2.buffer(stream22, { maxBuffer });
        }, "getStreamPromise");
        var getSpawnedResult = /* @__PURE__ */ __name(async ({ stdout, stderr, all: all5 }, { encoding, buffer, maxBuffer }, processDone) => {
          const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
          const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
          const allPromise = getStreamPromise(all5, { encoding, buffer, maxBuffer: maxBuffer * 2 });
          try {
            return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
          } catch (error2) {
            return Promise.all([
              { error: error2, signal: error2.signal, timedOut: error2.timedOut },
              getBufferedData(stdout, stdoutPromise),
              getBufferedData(stderr, stderrPromise),
              getBufferedData(all5, allPromise)
            ]);
          }
        }, "getSpawnedResult");
        var validateInputSync = /* @__PURE__ */ __name(({ input }) => {
          if (isStream2(input)) {
            throw new TypeError("The `input` option cannot be a stream in sync mode");
          }
        }, "validateInputSync");
        module2.exports = {
          handleInput,
          makeAllStream,
          getSpawnedResult,
          validateInputSync
        };
      }
    });
    var require_promise = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js"(exports2, module2) {
        "use strict";
        var nativePromisePrototype = (async () => {
        })().constructor.prototype;
        var descriptors2 = ["then", "catch", "finally"].map((property) => [
          property,
          Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
        ]);
        var mergePromise = /* @__PURE__ */ __name((spawned, promise) => {
          for (const [property, descriptor] of descriptors2) {
            const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
            Reflect.defineProperty(spawned, property, { ...descriptor, value });
          }
          return spawned;
        }, "mergePromise");
        var getSpawnedPromise = /* @__PURE__ */ __name((spawned) => {
          return new Promise((resolve, reject) => {
            spawned.on("exit", (exitCode, signal) => {
              resolve({ exitCode, signal });
            });
            spawned.on("error", (error2) => {
              reject(error2);
            });
            if (spawned.stdin) {
              spawned.stdin.on("error", (error2) => {
                reject(error2);
              });
            }
          });
        }, "getSpawnedPromise");
        module2.exports = {
          mergePromise,
          getSpawnedPromise
        };
      }
    });
    var require_command = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js"(exports2, module2) {
        "use strict";
        var normalizeArgs = /* @__PURE__ */ __name((file, args = []) => {
          if (!Array.isArray(args)) {
            return [file];
          }
          return [file, ...args];
        }, "normalizeArgs");
        var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
        var DOUBLE_QUOTES_REGEXP = /"/g;
        var escapeArg = /* @__PURE__ */ __name((arg2) => {
          if (typeof arg2 !== "string" || NO_ESCAPE_REGEXP.test(arg2)) {
            return arg2;
          }
          return `"${arg2.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
        }, "escapeArg");
        var joinCommand = /* @__PURE__ */ __name((file, args) => {
          return normalizeArgs(file, args).join(" ");
        }, "joinCommand");
        var getEscapedCommand = /* @__PURE__ */ __name((file, args) => {
          return normalizeArgs(file, args).map((arg2) => escapeArg(arg2)).join(" ");
        }, "getEscapedCommand");
        var SPACES_REGEXP = / +/g;
        var parseCommand = /* @__PURE__ */ __name((command) => {
          const tokens = [];
          for (const token of command.trim().split(SPACES_REGEXP)) {
            const previousToken = tokens[tokens.length - 1];
            if (previousToken && previousToken.endsWith("\\")) {
              tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
            } else {
              tokens.push(token);
            }
          }
          return tokens;
        }, "parseCommand");
        module2.exports = {
          joinCommand,
          getEscapedCommand,
          parseCommand
        };
      }
    });
    var require_execa = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var childProcess = require("child_process");
        var crossSpawn = require_cross_spawn();
        var stripFinalNewline = require_strip_final_newline();
        var npmRunPath = require_npm_run_path();
        var onetime = require_onetime();
        var makeError = require_error();
        var normalizeStdio = require_stdio();
        var { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = require_kill();
        var { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = require_stream();
        var { mergePromise, getSpawnedPromise } = require_promise();
        var { joinCommand, parseCommand, getEscapedCommand } = require_command();
        var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
        var getEnv2 = /* @__PURE__ */ __name(({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
          const env2 = extendEnv ? { ...process.env, ...envOption } : envOption;
          if (preferLocal) {
            return npmRunPath.env({ env: env2, cwd: localDir, execPath });
          }
          return env2;
        }, "getEnv");
        var handleArguments = /* @__PURE__ */ __name((file, args, options = {}) => {
          const parsed = crossSpawn._parse(file, args, options);
          file = parsed.command;
          args = parsed.args;
          options = parsed.options;
          options = {
            maxBuffer: DEFAULT_MAX_BUFFER,
            buffer: true,
            stripFinalNewline: true,
            extendEnv: true,
            preferLocal: false,
            localDir: options.cwd || process.cwd(),
            execPath: process.execPath,
            encoding: "utf8",
            reject: true,
            cleanup: true,
            all: false,
            windowsHide: true,
            ...options
          };
          options.env = getEnv2(options);
          options.stdio = normalizeStdio(options);
          if (process.platform === "win32" && path7.basename(file, ".exe") === "cmd") {
            args.unshift("/q");
          }
          return { file, args, options, parsed };
        }, "handleArguments");
        var handleOutput = /* @__PURE__ */ __name((options, value, error2) => {
          if (typeof value !== "string" && !Buffer.isBuffer(value)) {
            return error2 === void 0 ? void 0 : "";
          }
          if (options.stripFinalNewline) {
            return stripFinalNewline(value);
          }
          return value;
        }, "handleOutput");
        var execa2 = /* @__PURE__ */ __name((file, args, options) => {
          const parsed = handleArguments(file, args, options);
          const command = joinCommand(file, args);
          const escapedCommand = getEscapedCommand(file, args);
          validateTimeout(parsed.options);
          let spawned;
          try {
            spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
          } catch (error2) {
            const dummySpawned = new childProcess.ChildProcess();
            const errorPromise = Promise.reject(makeError({
              error: error2,
              stdout: "",
              stderr: "",
              all: "",
              command,
              escapedCommand,
              parsed,
              timedOut: false,
              isCanceled: false,
              killed: false
            }));
            return mergePromise(dummySpawned, errorPromise);
          }
          const spawnedPromise = getSpawnedPromise(spawned);
          const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
          const processDone = setExitHandler(spawned, parsed.options, timedPromise);
          const context3 = { isCanceled: false };
          spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
          spawned.cancel = spawnedCancel.bind(null, spawned, context3);
          const handlePromise = /* @__PURE__ */ __name(async () => {
            const [{ error: error2, exitCode, signal, timedOut: timedOut2 }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
            const stdout = handleOutput(parsed.options, stdoutResult);
            const stderr = handleOutput(parsed.options, stderrResult);
            const all5 = handleOutput(parsed.options, allResult);
            if (error2 || exitCode !== 0 || signal !== null) {
              const returnedError = makeError({
                error: error2,
                exitCode,
                signal,
                stdout,
                stderr,
                all: all5,
                command,
                escapedCommand,
                parsed,
                timedOut: timedOut2,
                isCanceled: context3.isCanceled,
                killed: spawned.killed
              });
              if (!parsed.options.reject) {
                return returnedError;
              }
              throw returnedError;
            }
            return {
              command,
              escapedCommand,
              exitCode: 0,
              stdout,
              stderr,
              all: all5,
              failed: false,
              timedOut: false,
              isCanceled: false,
              killed: false
            };
          }, "handlePromise");
          const handlePromiseOnce = onetime(handlePromise);
          handleInput(spawned, parsed.options.input);
          spawned.all = makeAllStream(spawned, parsed.options);
          return mergePromise(spawned, handlePromiseOnce);
        }, "execa");
        module2.exports = execa2;
        module2.exports.sync = (file, args, options) => {
          const parsed = handleArguments(file, args, options);
          const command = joinCommand(file, args);
          const escapedCommand = getEscapedCommand(file, args);
          validateInputSync(parsed.options);
          let result;
          try {
            result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
          } catch (error2) {
            throw makeError({
              error: error2,
              stdout: "",
              stderr: "",
              all: "",
              command,
              escapedCommand,
              parsed,
              timedOut: false,
              isCanceled: false,
              killed: false
            });
          }
          const stdout = handleOutput(parsed.options, result.stdout, result.error);
          const stderr = handleOutput(parsed.options, result.stderr, result.error);
          if (result.error || result.status !== 0 || result.signal !== null) {
            const error2 = makeError({
              stdout,
              stderr,
              error: result.error,
              signal: result.signal,
              exitCode: result.status,
              command,
              escapedCommand,
              parsed,
              timedOut: result.error && result.error.code === "ETIMEDOUT",
              isCanceled: false,
              killed: result.signal !== null
            });
            if (!parsed.options.reject) {
              return error2;
            }
            throw error2;
          }
          return {
            command,
            escapedCommand,
            exitCode: 0,
            stdout,
            stderr,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
          };
        };
        module2.exports.command = (command, options) => {
          const [file, ...args] = parseCommand(command);
          return execa2(file, args, options);
        };
        module2.exports.commandSync = (command, options) => {
          const [file, ...args] = parseCommand(command);
          return execa2.sync(file, args, options);
        };
        module2.exports.node = (scriptPath, args, options = {}) => {
          if (args && !Array.isArray(args) && typeof args === "object") {
            options = args;
            args = [];
          }
          const stdio = normalizeStdio.node(options);
          const defaultExecArgv = process.execArgv.filter((arg2) => !arg2.startsWith("--inspect"));
          const {
            nodePath = process.execPath,
            nodeOptions = defaultExecArgv
          } = options;
          return execa2(
            nodePath,
            [
              ...nodeOptions,
              scriptPath,
              ...Array.isArray(args) ? args : []
            ],
            {
              ...options,
              stdin: void 0,
              stdout: void 0,
              stderr: void 0,
              stdio,
              shell: false
            }
          );
        };
      }
    });
    var require_package = __commonJS({
      "../../node_modules/.pnpm/dotenv@16.0.3/node_modules/dotenv/package.json"(exports2, module2) {
        module2.exports = {
          name: "dotenv",
          version: "16.0.3",
          description: "Loads environment variables from .env file",
          main: "lib/main.js",
          types: "lib/main.d.ts",
          exports: {
            ".": {
              require: "./lib/main.js",
              types: "./lib/main.d.ts",
              default: "./lib/main.js"
            },
            "./config": "./config.js",
            "./config.js": "./config.js",
            "./lib/env-options": "./lib/env-options.js",
            "./lib/env-options.js": "./lib/env-options.js",
            "./lib/cli-options": "./lib/cli-options.js",
            "./lib/cli-options.js": "./lib/cli-options.js",
            "./package.json": "./package.json"
          },
          scripts: {
            "dts-check": "tsc --project tests/types/tsconfig.json",
            lint: "standard",
            "lint-readme": "standard-markdown",
            pretest: "npm run lint && npm run dts-check",
            test: "tap tests/*.js --100 -Rspec",
            prerelease: "npm test",
            release: "standard-version"
          },
          repository: {
            type: "git",
            url: "git://github.com/motdotla/dotenv.git"
          },
          keywords: [
            "dotenv",
            "env",
            ".env",
            "environment",
            "variables",
            "config",
            "settings"
          ],
          readmeFilename: "README.md",
          license: "BSD-2-Clause",
          devDependencies: {
            "@types/node": "^17.0.9",
            decache: "^4.6.1",
            dtslint: "^3.7.0",
            sinon: "^12.0.1",
            standard: "^16.0.4",
            "standard-markdown": "^7.1.0",
            "standard-version": "^9.3.2",
            tap: "^15.1.6",
            tar: "^6.1.11",
            typescript: "^4.5.4"
          },
          engines: {
            node: ">=12"
          }
        };
      }
    });
    var require_main2 = __commonJS({
      "../../node_modules/.pnpm/dotenv@16.0.3/node_modules/dotenv/lib/main.js"(exports2, module2) {
        var fs11 = require("fs");
        var path7 = require("path");
        var os32 = require("os");
        var packageJson = require_package();
        var version = packageJson.version;
        var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
        function parse2(src) {
          const obj = {};
          let lines = src.toString();
          lines = lines.replace(/\r\n?/mg, "\n");
          let match;
          while ((match = LINE.exec(lines)) != null) {
            const key = match[1];
            let value = match[2] || "";
            value = value.trim();
            const maybeQuote = value[0];
            value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
            if (maybeQuote === '"') {
              value = value.replace(/\\n/g, "\n");
              value = value.replace(/\\r/g, "\r");
            }
            obj[key] = value;
          }
          return obj;
        }
        __name(parse2, "parse");
        function _log(message) {
          console.log(`[dotenv@${version}][DEBUG] ${message}`);
        }
        __name(_log, "_log");
        function _resolveHome(envPath) {
          return envPath[0] === "~" ? path7.join(os32.homedir(), envPath.slice(1)) : envPath;
        }
        __name(_resolveHome, "_resolveHome");
        function config2(options) {
          let dotenvPath = path7.resolve(process.cwd(), ".env");
          let encoding = "utf8";
          const debug13 = Boolean(options && options.debug);
          const override = Boolean(options && options.override);
          if (options) {
            if (options.path != null) {
              dotenvPath = _resolveHome(options.path);
            }
            if (options.encoding != null) {
              encoding = options.encoding;
            }
          }
          try {
            const parsed = DotenvModule.parse(fs11.readFileSync(dotenvPath, { encoding }));
            Object.keys(parsed).forEach(function(key) {
              if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
                process.env[key] = parsed[key];
              } else {
                if (override === true) {
                  process.env[key] = parsed[key];
                }
                if (debug13) {
                  if (override === true) {
                    _log(`"${key}" is already defined in \`process.env\` and WAS overwritten`);
                  } else {
                    _log(`"${key}" is already defined in \`process.env\` and was NOT overwritten`);
                  }
                }
              }
            });
            return { parsed };
          } catch (e) {
            if (debug13) {
              _log(`Failed to load ${dotenvPath} ${e.message}`);
            }
            return { error: e };
          }
        }
        __name(config2, "config");
        var DotenvModule = {
          config: config2,
          parse: parse2
        };
        module2.exports.config = DotenvModule.config;
        module2.exports.parse = DotenvModule.parse;
        module2.exports = DotenvModule;
      }
    });
    var require_arg = __commonJS({
      "../../node_modules/.pnpm/arg@5.0.2/node_modules/arg/index.js"(exports2, module2) {
        var flagSymbol = Symbol("arg flag");
        var ArgError = class extends Error {
          constructor(msg, code) {
            super(msg);
            this.name = "ArgError";
            this.code = code;
            Object.setPrototypeOf(this, ArgError.prototype);
          }
        };
        __name(ArgError, "ArgError");
        function arg2(opts, {
          argv = process.argv.slice(2),
          permissive = false,
          stopAtPositional = false
        } = {}) {
          if (!opts) {
            throw new ArgError(
              "argument specification object is required",
              "ARG_CONFIG_NO_SPEC"
            );
          }
          const result = { _: [] };
          const aliases2 = {};
          const handlers = {};
          for (const key of Object.keys(opts)) {
            if (!key) {
              throw new ArgError(
                "argument key cannot be an empty string",
                "ARG_CONFIG_EMPTY_KEY"
              );
            }
            if (key[0] !== "-") {
              throw new ArgError(
                `argument key must start with '-' but found: '${key}'`,
                "ARG_CONFIG_NONOPT_KEY"
              );
            }
            if (key.length === 1) {
              throw new ArgError(
                `argument key must have a name; singular '-' keys are not allowed: ${key}`,
                "ARG_CONFIG_NONAME_KEY"
              );
            }
            if (typeof opts[key] === "string") {
              aliases2[key] = opts[key];
              continue;
            }
            let type = opts[key];
            let isFlag = false;
            if (Array.isArray(type) && type.length === 1 && typeof type[0] === "function") {
              const [fn] = type;
              type = /* @__PURE__ */ __name((value, name, prev = []) => {
                prev.push(fn(value, name, prev[prev.length - 1]));
                return prev;
              }, "type");
              isFlag = fn === Boolean || fn[flagSymbol] === true;
            } else if (typeof type === "function") {
              isFlag = type === Boolean || type[flagSymbol] === true;
            } else {
              throw new ArgError(
                `type missing or not a function or valid array type: ${key}`,
                "ARG_CONFIG_VAD_TYPE"
              );
            }
            if (key[1] !== "-" && key.length > 2) {
              throw new ArgError(
                `short argument keys (with a single hyphen) must have only one character: ${key}`,
                "ARG_CONFIG_SHORTOPT_TOOLONG"
              );
            }
            handlers[key] = [type, isFlag];
          }
          for (let i = 0, len = argv.length; i < len; i++) {
            const wholeArg = argv[i];
            if (stopAtPositional && result._.length > 0) {
              result._ = result._.concat(argv.slice(i));
              break;
            }
            if (wholeArg === "--") {
              result._ = result._.concat(argv.slice(i + 1));
              break;
            }
            if (wholeArg.length > 1 && wholeArg[0] === "-") {
              const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
              for (let j = 0; j < separatedArguments.length; j++) {
                const arg3 = separatedArguments[j];
                const [originalArgName, argStr] = arg3[1] === "-" ? arg3.split(/=(.*)/, 2) : [arg3, void 0];
                let argName = originalArgName;
                while (argName in aliases2) {
                  argName = aliases2[argName];
                }
                if (!(argName in handlers)) {
                  if (permissive) {
                    result._.push(arg3);
                    continue;
                  } else {
                    throw new ArgError(
                      `unknown or unexpected option: ${originalArgName}`,
                      "ARG_UNKNOWN_OPTION"
                    );
                  }
                }
                const [type, isFlag] = handlers[argName];
                if (!isFlag && j + 1 < separatedArguments.length) {
                  throw new ArgError(
                    `option requires argument (but was followed by another short argument): ${originalArgName}`,
                    "ARG_MISSING_REQUIRED_SHORTARG"
                  );
                }
                if (isFlag) {
                  result[argName] = type(true, argName, result[argName]);
                } else if (argStr === void 0) {
                  if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === "-" && !(argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type === Number || typeof BigInt !== "undefined" && type === BigInt))) {
                    const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
                    throw new ArgError(
                      `option requires argument: ${originalArgName}${extended}`,
                      "ARG_MISSING_REQUIRED_LONGARG"
                    );
                  }
                  result[argName] = type(argv[i + 1], argName, result[argName]);
                  ++i;
                } else {
                  result[argName] = type(argStr, argName, result[argName]);
                }
              }
            } else {
              result._.push(wholeArg);
            }
          }
          return result;
        }
        __name(arg2, "arg");
        arg2.flag = (fn) => {
          fn[flagSymbol] = true;
          return fn;
        };
        arg2.COUNT = arg2.flag((v, name, existingCount) => (existingCount || 0) + 1);
        arg2.ArgError = ArgError;
        module2.exports = arg2;
      }
    });
    var require_min_indent = __commonJS({
      "../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (string) => {
          const match = string.match(/^[ \t]*(?=\S)/gm);
          if (!match) {
            return 0;
          }
          return match.reduce((r, a) => Math.min(r, a.length), Infinity);
        };
      }
    });
    var require_strip_indent = __commonJS({
      "../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js"(exports2, module2) {
        "use strict";
        var minIndent = require_min_indent();
        module2.exports = (string) => {
          const indent4 = minIndent(string);
          if (indent4 === 0) {
            return string;
          }
          const regex = new RegExp(`^[ \\t]{${indent4}}`, "gm");
          return string.replace(regex, "");
        };
      }
    });
    var require_package2 = __commonJS({
      "../../node_modules/.pnpm/@prisma+engines-version@4.7.1-1.272861e07ab64f234d3ffc4094e32bd61775599c/node_modules/@prisma/engines-version/package.json"(exports2, module2) {
        module2.exports = {
          name: "@prisma/engines-version",
          version: "4.7.1-1.272861e07ab64f234d3ffc4094e32bd61775599c",
          main: "index.js",
          types: "index.d.ts",
          license: "Apache-2.0",
          author: "Tim Suchanek <suchanek@prisma.io>",
          prisma: {
            enginesVersion: "272861e07ab64f234d3ffc4094e32bd61775599c"
          },
          repository: {
            type: "git",
            url: "https://github.com/prisma/engines-wrapper.git",
            directory: "packages/engines-version"
          },
          devDependencies: {
            "@types/node": "16.11.64",
            typescript: "4.8.4"
          },
          files: [
            "index.js",
            "index.d.ts"
          ],
          scripts: {
            build: "tsc -d"
          }
        };
      }
    });
    var require_engines_version = __commonJS({
      "../../node_modules/.pnpm/@prisma+engines-version@4.7.1-1.272861e07ab64f234d3ffc4094e32bd61775599c/node_modules/@prisma/engines-version/index.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.enginesVersion = void 0;
        exports2.enginesVersion = require_package2().prisma.enginesVersion;
      }
    });
    var require_retry_operation = __commonJS({
      "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js"(exports2, module2) {
        function RetryOperation(timeouts, options) {
          if (typeof options === "boolean") {
            options = { forever: options };
          }
          this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
          this._timeouts = timeouts;
          this._options = options || {};
          this._maxRetryTime = options && options.maxRetryTime || Infinity;
          this._fn = null;
          this._errors = [];
          this._attempts = 1;
          this._operationTimeout = null;
          this._operationTimeoutCb = null;
          this._timeout = null;
          this._operationStart = null;
          this._timer = null;
          if (this._options.forever) {
            this._cachedTimeouts = this._timeouts.slice(0);
          }
        }
        __name(RetryOperation, "RetryOperation");
        module2.exports = RetryOperation;
        RetryOperation.prototype.reset = function() {
          this._attempts = 1;
          this._timeouts = this._originalTimeouts.slice(0);
        };
        RetryOperation.prototype.stop = function() {
          if (this._timeout) {
            clearTimeout(this._timeout);
          }
          if (this._timer) {
            clearTimeout(this._timer);
          }
          this._timeouts = [];
          this._cachedTimeouts = null;
        };
        RetryOperation.prototype.retry = function(err) {
          if (this._timeout) {
            clearTimeout(this._timeout);
          }
          if (!err) {
            return false;
          }
          var currentTime = (/* @__PURE__ */ new Date()).getTime();
          if (err && currentTime - this._operationStart >= this._maxRetryTime) {
            this._errors.push(err);
            this._errors.unshift(new Error("RetryOperation timeout occurred"));
            return false;
          }
          this._errors.push(err);
          var timeout = this._timeouts.shift();
          if (timeout === void 0) {
            if (this._cachedTimeouts) {
              this._errors.splice(0, this._errors.length - 1);
              timeout = this._cachedTimeouts.slice(-1);
            } else {
              return false;
            }
          }
          var self2 = this;
          this._timer = setTimeout(function() {
            self2._attempts++;
            if (self2._operationTimeoutCb) {
              self2._timeout = setTimeout(function() {
                self2._operationTimeoutCb(self2._attempts);
              }, self2._operationTimeout);
              if (self2._options.unref) {
                self2._timeout.unref();
              }
            }
            self2._fn(self2._attempts);
          }, timeout);
          if (this._options.unref) {
            this._timer.unref();
          }
          return true;
        };
        RetryOperation.prototype.attempt = function(fn, timeoutOps) {
          this._fn = fn;
          if (timeoutOps) {
            if (timeoutOps.timeout) {
              this._operationTimeout = timeoutOps.timeout;
            }
            if (timeoutOps.cb) {
              this._operationTimeoutCb = timeoutOps.cb;
            }
          }
          var self2 = this;
          if (this._operationTimeoutCb) {
            this._timeout = setTimeout(function() {
              self2._operationTimeoutCb();
            }, self2._operationTimeout);
          }
          this._operationStart = (/* @__PURE__ */ new Date()).getTime();
          this._fn(this._attempts);
        };
        RetryOperation.prototype.try = function(fn) {
          console.log("Using RetryOperation.try() is deprecated");
          this.attempt(fn);
        };
        RetryOperation.prototype.start = function(fn) {
          console.log("Using RetryOperation.start() is deprecated");
          this.attempt(fn);
        };
        RetryOperation.prototype.start = RetryOperation.prototype.try;
        RetryOperation.prototype.errors = function() {
          return this._errors;
        };
        RetryOperation.prototype.attempts = function() {
          return this._attempts;
        };
        RetryOperation.prototype.mainError = function() {
          if (this._errors.length === 0) {
            return null;
          }
          var counts = {};
          var mainError = null;
          var mainErrorCount = 0;
          for (var i = 0; i < this._errors.length; i++) {
            var error2 = this._errors[i];
            var message = error2.message;
            var count2 = (counts[message] || 0) + 1;
            counts[message] = count2;
            if (count2 >= mainErrorCount) {
              mainError = error2;
              mainErrorCount = count2;
            }
          }
          return mainError;
        };
      }
    });
    var require_retry = __commonJS({
      "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js"(exports2) {
        var RetryOperation = require_retry_operation();
        exports2.operation = function(options) {
          var timeouts = exports2.timeouts(options);
          return new RetryOperation(timeouts, {
            forever: options && (options.forever || options.retries === Infinity),
            unref: options && options.unref,
            maxRetryTime: options && options.maxRetryTime
          });
        };
        exports2.timeouts = function(options) {
          if (options instanceof Array) {
            return [].concat(options);
          }
          var opts = {
            retries: 10,
            factor: 2,
            minTimeout: 1 * 1e3,
            maxTimeout: Infinity,
            randomize: false
          };
          for (var key in options) {
            opts[key] = options[key];
          }
          if (opts.minTimeout > opts.maxTimeout) {
            throw new Error("minTimeout is greater than maxTimeout");
          }
          var timeouts = [];
          for (var i = 0; i < opts.retries; i++) {
            timeouts.push(this.createTimeout(i, opts));
          }
          if (options && options.forever && !timeouts.length) {
            timeouts.push(this.createTimeout(i, opts));
          }
          timeouts.sort(function(a, b) {
            return a - b;
          });
          return timeouts;
        };
        exports2.createTimeout = function(attempt, opts) {
          var random2 = opts.randomize ? Math.random() + 1 : 1;
          var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
          timeout = Math.min(timeout, opts.maxTimeout);
          return timeout;
        };
        exports2.wrap = function(obj, options, methods) {
          if (options instanceof Array) {
            methods = options;
            options = null;
          }
          if (!methods) {
            methods = [];
            for (var key in obj) {
              if (typeof obj[key] === "function") {
                methods.push(key);
              }
            }
          }
          for (var i = 0; i < methods.length; i++) {
            var method = methods[i];
            var original = obj[method];
            obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
              var op = exports2.operation(options);
              var args = Array.prototype.slice.call(arguments, 1);
              var callback = args.pop();
              args.push(function(err) {
                if (op.retry(err)) {
                  return;
                }
                if (err) {
                  arguments[0] = op.mainError();
                }
                callback.apply(this, arguments);
              });
              op.attempt(function() {
                original2.apply(obj, args);
              });
            }, "retryWrapper")).bind(obj, original);
            obj[method].options = options;
          }
        };
      }
    });
    var require_retry2 = __commonJS({
      "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js"(exports2, module2) {
        module2.exports = require_retry();
      }
    });
    var require_p_retry = __commonJS({
      "../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js"(exports2, module2) {
        "use strict";
        var retry = require_retry2();
        var networkErrorMsgs = [
          "Failed to fetch",
          "NetworkError when attempting to fetch resource.",
          "The Internet connection appears to be offline.",
          "Network request failed"
        ];
        var AbortError2 = class extends Error {
          constructor(message) {
            super();
            if (message instanceof Error) {
              this.originalError = message;
              ({ message } = message);
            } else {
              this.originalError = new Error(message);
              this.originalError.stack = this.stack;
            }
            this.name = "AbortError";
            this.message = message;
          }
        };
        __name(AbortError2, "AbortError");
        var decorateErrorWithCounts = /* @__PURE__ */ __name((error2, attemptNumber, options) => {
          const retriesLeft = options.retries - (attemptNumber - 1);
          error2.attemptNumber = attemptNumber;
          error2.retriesLeft = retriesLeft;
          return error2;
        }, "decorateErrorWithCounts");
        var isNetworkError = /* @__PURE__ */ __name((errorMessage) => networkErrorMsgs.includes(errorMessage), "isNetworkError");
        var pRetry2 = /* @__PURE__ */ __name((input, options) => new Promise((resolve, reject) => {
          options = {
            onFailedAttempt: () => {
            },
            retries: 10,
            ...options
          };
          const operation = retry.operation(options);
          operation.attempt(async (attemptNumber) => {
            try {
              resolve(await input(attemptNumber));
            } catch (error2) {
              if (!(error2 instanceof Error)) {
                reject(new TypeError(`Non-error was thrown: "${error2}". You should only throw errors.`));
                return;
              }
              if (error2 instanceof AbortError2) {
                operation.stop();
                reject(error2.originalError);
              } else if (error2 instanceof TypeError && !isNetworkError(error2.message)) {
                operation.stop();
                reject(error2);
              } else {
                decorateErrorWithCounts(error2, attemptNumber, options);
                try {
                  await options.onFailedAttempt(error2);
                } catch (error3) {
                  reject(error3);
                  return;
                }
                if (!operation.retry(error2)) {
                  reject(operation.mainError());
                }
              }
            }
          });
        }), "pRetry");
        module2.exports = pRetry2;
        module2.exports.default = pRetry2;
        module2.exports.AbortError = AbortError2;
      }
    });
    var require_ansi_regex = __commonJS({
      "../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js"(exports2, module2) {
        "use strict";
        module2.exports = ({ onlyFirst = false } = {}) => {
          const pattern = [
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
          ].join("|");
          return new RegExp(pattern, onlyFirst ? void 0 : "g");
        };
      }
    });
    var require_strip_ansi = __commonJS({
      "../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js"(exports2, module2) {
        "use strict";
        var ansiRegex = require_ansi_regex();
        module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
      }
    });
    var require_new_github_issue_url = __commonJS({
      "../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (options = {}) => {
          let repoUrl;
          if (options.repoUrl) {
            repoUrl = options.repoUrl;
          } else if (options.user && options.repo) {
            repoUrl = `https://github.com/${options.user}/${options.repo}`;
          } else {
            throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
          }
          const url2 = new URL(`${repoUrl}/issues/new`);
          const types2 = [
            "body",
            "title",
            "labels",
            "template",
            "milestone",
            "assignee",
            "projects"
          ];
          for (const type of types2) {
            let value = options[type];
            if (value === void 0) {
              continue;
            }
            if (type === "labels" || type === "projects") {
              if (!Array.isArray(value)) {
                throw new TypeError(`The \`${type}\` option should be an array`);
              }
              value = value.join(",");
            }
            url2.searchParams.set(type, value);
          }
          return url2.toString();
        };
        module2.exports.default = module2.exports;
      }
    });
    var require_indent_string = __commonJS({
      "../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (string, count2 = 1, options) => {
          options = {
            indent: " ",
            includeEmptyLines: false,
            ...options
          };
          if (typeof string !== "string") {
            throw new TypeError(
              `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
            );
          }
          if (typeof count2 !== "number") {
            throw new TypeError(
              `Expected \`count\` to be a \`number\`, got \`${typeof count2}\``
            );
          }
          if (typeof options.indent !== "string") {
            throw new TypeError(
              `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
            );
          }
          if (count2 === 0) {
            return string;
          }
          const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
          return string.replace(regex, options.indent.repeat(count2));
        };
      }
    });
    var require_symbols = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/core/symbols.js"(exports2, module2) {
        module2.exports = {
          kClose: Symbol("close"),
          kDestroy: Symbol("destroy"),
          kDispatch: Symbol("dispatch"),
          kUrl: Symbol("url"),
          kWriting: Symbol("writing"),
          kResuming: Symbol("resuming"),
          kQueue: Symbol("queue"),
          kConnect: Symbol("connect"),
          kConnecting: Symbol("connecting"),
          kHeadersList: Symbol("headers list"),
          kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
          kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
          kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
          kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
          kKeepAlive: Symbol("keep alive"),
          kHeadersTimeout: Symbol("headers timeout"),
          kBodyTimeout: Symbol("body timeout"),
          kServerName: Symbol("server name"),
          kHost: Symbol("host"),
          kNoRef: Symbol("no ref"),
          kBodyUsed: Symbol("used"),
          kRunning: Symbol("running"),
          kBlocking: Symbol("blocking"),
          kPending: Symbol("pending"),
          kSize: Symbol("size"),
          kBusy: Symbol("busy"),
          kQueued: Symbol("queued"),
          kFree: Symbol("free"),
          kConnected: Symbol("connected"),
          kClosed: Symbol("closed"),
          kNeedDrain: Symbol("need drain"),
          kReset: Symbol("reset"),
          kDestroyed: Symbol("destroyed"),
          kMaxHeadersSize: Symbol("max headers size"),
          kRunningIdx: Symbol("running index"),
          kPendingIdx: Symbol("pending index"),
          kError: Symbol("error"),
          kClients: Symbol("clients"),
          kClient: Symbol("client"),
          kParser: Symbol("parser"),
          kOnDestroyed: Symbol("destroy callbacks"),
          kPipelining: Symbol("pipelinig"),
          kSocket: Symbol("socket"),
          kHostHeader: Symbol("host header"),
          kConnector: Symbol("connector"),
          kStrictContentLength: Symbol("strict content length"),
          kMaxRedirections: Symbol("maxRedirections"),
          kMaxRequests: Symbol("maxRequestsPerClient"),
          kProxy: Symbol("proxy agent options"),
          kCounter: Symbol("socket request counter"),
          kInterceptors: Symbol("dispatch interceptors")
        };
      }
    });
    var require_errors = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/core/errors.js"(exports2, module2) {
        "use strict";
        var UndiciError = class extends Error {
          constructor(message) {
            super(message);
            this.name = "UndiciError";
            this.code = "UND_ERR";
          }
        };
        __name(UndiciError, "UndiciError");
        var ConnectTimeoutError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, ConnectTimeoutError);
            this.name = "ConnectTimeoutError";
            this.message = message || "Connect Timeout Error";
            this.code = "UND_ERR_CONNECT_TIMEOUT";
          }
        };
        __name(ConnectTimeoutError, "ConnectTimeoutError");
        var HeadersTimeoutError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, HeadersTimeoutError);
            this.name = "HeadersTimeoutError";
            this.message = message || "Headers Timeout Error";
            this.code = "UND_ERR_HEADERS_TIMEOUT";
          }
        };
        __name(HeadersTimeoutError, "HeadersTimeoutError");
        var HeadersOverflowError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, HeadersOverflowError);
            this.name = "HeadersOverflowError";
            this.message = message || "Headers Overflow Error";
            this.code = "UND_ERR_HEADERS_OVERFLOW";
          }
        };
        __name(HeadersOverflowError, "HeadersOverflowError");
        var BodyTimeoutError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, BodyTimeoutError);
            this.name = "BodyTimeoutError";
            this.message = message || "Body Timeout Error";
            this.code = "UND_ERR_BODY_TIMEOUT";
          }
        };
        __name(BodyTimeoutError, "BodyTimeoutError");
        var ResponseStatusCodeError = class extends UndiciError {
          constructor(message, statusCode, headers, body) {
            super(message);
            Error.captureStackTrace(this, ResponseStatusCodeError);
            this.name = "ResponseStatusCodeError";
            this.message = message || "Response Status Code Error";
            this.code = "UND_ERR_RESPONSE_STATUS_CODE";
            this.body = body;
            this.status = statusCode;
            this.statusCode = statusCode;
            this.headers = headers;
          }
        };
        __name(ResponseStatusCodeError, "ResponseStatusCodeError");
        var InvalidArgumentError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, InvalidArgumentError);
            this.name = "InvalidArgumentError";
            this.message = message || "Invalid Argument Error";
            this.code = "UND_ERR_INVALID_ARG";
          }
        };
        __name(InvalidArgumentError, "InvalidArgumentError");
        var InvalidReturnValueError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, InvalidReturnValueError);
            this.name = "InvalidReturnValueError";
            this.message = message || "Invalid Return Value Error";
            this.code = "UND_ERR_INVALID_RETURN_VALUE";
          }
        };
        __name(InvalidReturnValueError, "InvalidReturnValueError");
        var RequestAbortedError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, RequestAbortedError);
            this.name = "AbortError";
            this.message = message || "Request aborted";
            this.code = "UND_ERR_ABORTED";
          }
        };
        __name(RequestAbortedError, "RequestAbortedError");
        var InformationalError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, InformationalError);
            this.name = "InformationalError";
            this.message = message || "Request information";
            this.code = "UND_ERR_INFO";
          }
        };
        __name(InformationalError, "InformationalError");
        var RequestContentLengthMismatchError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, RequestContentLengthMismatchError);
            this.name = "RequestContentLengthMismatchError";
            this.message = message || "Request body length does not match content-length header";
            this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
          }
        };
        __name(RequestContentLengthMismatchError, "RequestContentLengthMismatchError");
        var ResponseContentLengthMismatchError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, ResponseContentLengthMismatchError);
            this.name = "ResponseContentLengthMismatchError";
            this.message = message || "Response body length does not match content-length header";
            this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
          }
        };
        __name(ResponseContentLengthMismatchError, "ResponseContentLengthMismatchError");
        var ClientDestroyedError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, ClientDestroyedError);
            this.name = "ClientDestroyedError";
            this.message = message || "The client is destroyed";
            this.code = "UND_ERR_DESTROYED";
          }
        };
        __name(ClientDestroyedError, "ClientDestroyedError");
        var ClientClosedError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, ClientClosedError);
            this.name = "ClientClosedError";
            this.message = message || "The client is closed";
            this.code = "UND_ERR_CLOSED";
          }
        };
        __name(ClientClosedError, "ClientClosedError");
        var SocketError = class extends UndiciError {
          constructor(message, socket) {
            super(message);
            Error.captureStackTrace(this, SocketError);
            this.name = "SocketError";
            this.message = message || "Socket error";
            this.code = "UND_ERR_SOCKET";
            this.socket = socket;
          }
        };
        __name(SocketError, "SocketError");
        var NotSupportedError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, NotSupportedError);
            this.name = "NotSupportedError";
            this.message = message || "Not supported error";
            this.code = "UND_ERR_NOT_SUPPORTED";
          }
        };
        __name(NotSupportedError, "NotSupportedError");
        var BalancedPoolMissingUpstreamError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, NotSupportedError);
            this.name = "MissingUpstreamError";
            this.message = message || "No upstream has been added to the BalancedPool";
            this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
          }
        };
        __name(BalancedPoolMissingUpstreamError, "BalancedPoolMissingUpstreamError");
        var HTTPParserError = class extends Error {
          constructor(message, code, data) {
            super(message);
            Error.captureStackTrace(this, HTTPParserError);
            this.name = "HTTPParserError";
            this.code = code ? `HPE_${code}` : void 0;
            this.data = data ? data.toString() : void 0;
          }
        };
        __name(HTTPParserError, "HTTPParserError");
        module2.exports = {
          HTTPParserError,
          UndiciError,
          HeadersTimeoutError,
          HeadersOverflowError,
          BodyTimeoutError,
          RequestContentLengthMismatchError,
          ConnectTimeoutError,
          ResponseStatusCodeError,
          InvalidArgumentError,
          InvalidReturnValueError,
          RequestAbortedError,
          ClientDestroyedError,
          ClientClosedError,
          InformationalError,
          SocketError,
          NotSupportedError,
          ResponseContentLengthMismatchError,
          BalancedPoolMissingUpstreamError
        };
      }
    });
    var require_util2 = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/core/util.js"(exports2, module2) {
        "use strict";
        var assert2 = require("assert");
        var { kDestroyed, kBodyUsed } = require_symbols();
        var { IncomingMessage } = require("http");
        var stream22 = require("stream");
        var net2 = require("net");
        var { InvalidArgumentError } = require_errors();
        var { Blob: Blob2 } = require("buffer");
        var nodeUtil = require("util");
        var { stringify: stringify2 } = require("querystring");
        function nop() {
        }
        __name(nop, "nop");
        function isStream2(obj) {
          return obj && typeof obj.pipe === "function";
        }
        __name(isStream2, "isStream");
        function isBlobLike(object) {
          return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
        }
        __name(isBlobLike, "isBlobLike");
        function buildURL2(url2, queryParams) {
          if (url2.includes("?") || url2.includes("#")) {
            throw new Error('Query params cannot be passed when url already contains "?" or "#".');
          }
          const stringified = stringify2(queryParams);
          if (stringified) {
            url2 += "?" + stringified;
          }
          return url2;
        }
        __name(buildURL2, "buildURL");
        function parseURL(url2) {
          if (typeof url2 === "string") {
            url2 = new URL(url2);
          }
          if (!url2 || typeof url2 !== "object") {
            throw new InvalidArgumentError("invalid url");
          }
          if (url2.port != null && url2.port !== "" && !Number.isFinite(parseInt(url2.port))) {
            throw new InvalidArgumentError("invalid port");
          }
          if (url2.path != null && typeof url2.path !== "string") {
            throw new InvalidArgumentError("invalid path");
          }
          if (url2.pathname != null && typeof url2.pathname !== "string") {
            throw new InvalidArgumentError("invalid pathname");
          }
          if (url2.hostname != null && typeof url2.hostname !== "string") {
            throw new InvalidArgumentError("invalid hostname");
          }
          if (url2.origin != null && typeof url2.origin !== "string") {
            throw new InvalidArgumentError("invalid origin");
          }
          if (!/^https?:/.test(url2.origin || url2.protocol)) {
            throw new InvalidArgumentError("invalid protocol");
          }
          if (!(url2 instanceof URL)) {
            const port = url2.port != null ? url2.port : url2.protocol === "https:" ? 443 : 80;
            let origin = url2.origin != null ? url2.origin : `${url2.protocol}//${url2.hostname}:${port}`;
            let path7 = url2.path != null ? url2.path : `${url2.pathname || ""}${url2.search || ""}`;
            if (origin.endsWith("/")) {
              origin = origin.substring(0, origin.length - 1);
            }
            if (path7 && !path7.startsWith("/")) {
              path7 = `/${path7}`;
            }
            url2 = new URL(origin + path7);
          }
          return url2;
        }
        __name(parseURL, "parseURL");
        function parseOrigin(url2) {
          url2 = parseURL(url2);
          if (url2.pathname !== "/" || url2.search || url2.hash) {
            throw new InvalidArgumentError("invalid url");
          }
          return url2;
        }
        __name(parseOrigin, "parseOrigin");
        function getHostname(host) {
          if (host[0] === "[") {
            const idx2 = host.indexOf("]");
            assert2(idx2 !== -1);
            return host.substr(1, idx2 - 1);
          }
          const idx = host.indexOf(":");
          if (idx === -1)
            return host;
          return host.substr(0, idx);
        }
        __name(getHostname, "getHostname");
        function getServerName(host) {
          if (!host) {
            return null;
          }
          assert2.strictEqual(typeof host, "string");
          const servername = getHostname(host);
          if (net2.isIP(servername)) {
            return "";
          }
          return servername;
        }
        __name(getServerName, "getServerName");
        function deepClone2(obj) {
          return JSON.parse(JSON.stringify(obj));
        }
        __name(deepClone2, "deepClone");
        function isAsyncIterable2(obj) {
          return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
        }
        __name(isAsyncIterable2, "isAsyncIterable");
        function isIterable2(obj) {
          return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
        }
        __name(isIterable2, "isIterable");
        function bodyLength(body) {
          if (body == null) {
            return 0;
          } else if (isStream2(body)) {
            const state = body._readableState;
            return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
          } else if (isBlobLike(body)) {
            return body.size != null ? body.size : null;
          } else if (isBuffer2(body)) {
            return body.byteLength;
          }
          return null;
        }
        __name(bodyLength, "bodyLength");
        function isDestroyed(stream32) {
          return !stream32 || !!(stream32.destroyed || stream32[kDestroyed]);
        }
        __name(isDestroyed, "isDestroyed");
        function isReadableAborted(stream32) {
          const state = stream32 && stream32._readableState;
          return isDestroyed(stream32) && state && !state.endEmitted;
        }
        __name(isReadableAborted, "isReadableAborted");
        function destroy(stream32, err) {
          if (!isStream2(stream32) || isDestroyed(stream32)) {
            return;
          }
          if (typeof stream32.destroy === "function") {
            if (Object.getPrototypeOf(stream32).constructor === IncomingMessage) {
              stream32.socket = null;
            }
            stream32.destroy(err);
          } else if (err) {
            process.nextTick((stream4, err2) => {
              stream4.emit("error", err2);
            }, stream32, err);
          }
          if (stream32.destroyed !== true) {
            stream32[kDestroyed] = true;
          }
        }
        __name(destroy, "destroy");
        var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
        function parseKeepAliveTimeout(val) {
          const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
          return m ? parseInt(m[1], 10) * 1e3 : null;
        }
        __name(parseKeepAliveTimeout, "parseKeepAliveTimeout");
        function parseHeaders(headers, obj = {}) {
          for (let i = 0; i < headers.length; i += 2) {
            const key = headers[i].toString().toLowerCase();
            let val = obj[key];
            if (!val) {
              if (Array.isArray(headers[i + 1])) {
                obj[key] = headers[i + 1];
              } else {
                obj[key] = headers[i + 1].toString();
              }
            } else {
              if (!Array.isArray(val)) {
                val = [val];
                obj[key] = val;
              }
              val.push(headers[i + 1].toString());
            }
          }
          return obj;
        }
        __name(parseHeaders, "parseHeaders");
        function parseRawHeaders(headers) {
          return headers.map((header) => header.toString());
        }
        __name(parseRawHeaders, "parseRawHeaders");
        function isBuffer2(buffer) {
          return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
        }
        __name(isBuffer2, "isBuffer");
        function validateHandler(handler, method, upgrade) {
          if (!handler || typeof handler !== "object") {
            throw new InvalidArgumentError("handler must be an object");
          }
          if (typeof handler.onConnect !== "function") {
            throw new InvalidArgumentError("invalid onConnect method");
          }
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
            throw new InvalidArgumentError("invalid onBodySent method");
          }
          if (upgrade || method === "CONNECT") {
            if (typeof handler.onUpgrade !== "function") {
              throw new InvalidArgumentError("invalid onUpgrade method");
            }
          } else {
            if (typeof handler.onHeaders !== "function") {
              throw new InvalidArgumentError("invalid onHeaders method");
            }
            if (typeof handler.onData !== "function") {
              throw new InvalidArgumentError("invalid onData method");
            }
            if (typeof handler.onComplete !== "function") {
              throw new InvalidArgumentError("invalid onComplete method");
            }
          }
        }
        __name(validateHandler, "validateHandler");
        function isDisturbed(body) {
          return !!(body && (stream22.isDisturbed ? stream22.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
        }
        __name(isDisturbed, "isDisturbed");
        function isErrored(body) {
          return !!(body && (stream22.isErrored ? stream22.isErrored(body) : /state: 'errored'/.test(
            nodeUtil.inspect(body)
          )));
        }
        __name(isErrored, "isErrored");
        function isReadable(body) {
          return !!(body && (stream22.isReadable ? stream22.isReadable(body) : /state: 'readable'/.test(
            nodeUtil.inspect(body)
          )));
        }
        __name(isReadable, "isReadable");
        function getSocketInfo(socket) {
          return {
            localAddress: socket.localAddress,
            localPort: socket.localPort,
            remoteAddress: socket.remoteAddress,
            remotePort: socket.remotePort,
            remoteFamily: socket.remoteFamily,
            timeout: socket.timeout,
            bytesWritten: socket.bytesWritten,
            bytesRead: socket.bytesRead
          };
        }
        __name(getSocketInfo, "getSocketInfo");
        var ReadableStream2;
        function ReadableStreamFrom(iterable) {
          if (!ReadableStream2) {
            ReadableStream2 = require("stream/web").ReadableStream;
          }
          if (ReadableStream2.from) {
            return ReadableStream2.from(iterable);
          }
          let iterator;
          return new ReadableStream2(
            {
              async start() {
                iterator = iterable[Symbol.asyncIterator]();
              },
              async pull(controller) {
                const { done, value } = await iterator.next();
                if (done) {
                  queueMicrotask(() => {
                    controller.close();
                  });
                } else {
                  const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
                  controller.enqueue(new Uint8Array(buf));
                }
                return controller.desiredSize > 0;
              },
              async cancel(reason) {
                await iterator.return();
              }
            },
            0
          );
        }
        __name(ReadableStreamFrom, "ReadableStreamFrom");
        function isFormDataLike(chunk) {
          return chunk && chunk.constructor && chunk.constructor.name === "FormData";
        }
        __name(isFormDataLike, "isFormDataLike");
        var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
        kEnumerableProperty.enumerable = true;
        module2.exports = {
          kEnumerableProperty,
          nop,
          isDisturbed,
          isErrored,
          isReadable,
          toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),
          isReadableAborted,
          isBlobLike,
          parseOrigin,
          parseURL,
          getServerName,
          isStream: isStream2,
          isIterable: isIterable2,
          isAsyncIterable: isAsyncIterable2,
          isDestroyed,
          parseRawHeaders,
          parseHeaders,
          parseKeepAliveTimeout,
          destroy,
          bodyLength,
          deepClone: deepClone2,
          ReadableStreamFrom,
          isBuffer: isBuffer2,
          validateHandler,
          getSocketInfo,
          isFormDataLike,
          buildURL: buildURL2
        };
      }
    });
    var require_utils = __commonJS({
      "../../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js"(exports2, module2) {
        "use strict";
        function parseContentType(str) {
          if (str.length === 0)
            return;
          const params = /* @__PURE__ */ Object.create(null);
          let i = 0;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (code !== 47 || i === 0)
                return;
              break;
            }
          }
          if (i === str.length)
            return;
          const type = str.slice(0, i).toLowerCase();
          const subtypeStart = ++i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === subtypeStart)
                return;
              if (parseContentTypeParams(str, i, params) === void 0)
                return;
              break;
            }
          }
          if (i === subtypeStart)
            return;
          const subtype = str.slice(subtypeStart, i).toLowerCase();
          return { type, subtype, params };
        }
        __name(parseContentType, "parseContentType");
        function parseContentTypeParams(str, i, params) {
          while (i < str.length) {
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (code !== 32 && code !== 9)
                break;
            }
            if (i === str.length)
              break;
            if (str.charCodeAt(i++) !== 59)
              return;
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (code !== 32 && code !== 9)
                break;
            }
            if (i === str.length)
              return;
            let name;
            const nameStart = i;
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (TOKEN[code] !== 1) {
                if (code !== 61)
                  return;
                break;
              }
            }
            if (i === str.length)
              return;
            name = str.slice(nameStart, i);
            ++i;
            if (i === str.length)
              return;
            let value = "";
            let valueStart;
            if (str.charCodeAt(i) === 34) {
              valueStart = ++i;
              let escaping = false;
              for (; i < str.length; ++i) {
                const code = str.charCodeAt(i);
                if (code === 92) {
                  if (escaping) {
                    valueStart = i;
                    escaping = false;
                  } else {
                    value += str.slice(valueStart, i);
                    escaping = true;
                  }
                  continue;
                }
                if (code === 34) {
                  if (escaping) {
                    valueStart = i;
                    escaping = false;
                    continue;
                  }
                  value += str.slice(valueStart, i);
                  break;
                }
                if (escaping) {
                  valueStart = i - 1;
                  escaping = false;
                }
                if (QDTEXT[code] !== 1)
                  return;
              }
              if (i === str.length)
                return;
              ++i;
            } else {
              valueStart = i;
              for (; i < str.length; ++i) {
                const code = str.charCodeAt(i);
                if (TOKEN[code] !== 1) {
                  if (i === valueStart)
                    return;
                  break;
                }
              }
              value = str.slice(valueStart, i);
            }
            name = name.toLowerCase();
            if (params[name] === void 0)
              params[name] = value;
          }
          return params;
        }
        __name(parseContentTypeParams, "parseContentTypeParams");
        function parseDisposition(str, defDecoder) {
          if (str.length === 0)
            return;
          const params = /* @__PURE__ */ Object.create(null);
          let i = 0;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (parseDispositionParams(str, i, params, defDecoder) === void 0)
                return;
              break;
            }
          }
          const type = str.slice(0, i).toLowerCase();
          return { type, params };
        }
        __name(parseDisposition, "parseDisposition");
        function parseDispositionParams(str, i, params, defDecoder) {
          while (i < str.length) {
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (code !== 32 && code !== 9)
                break;
            }
            if (i === str.length)
              break;
            if (str.charCodeAt(i++) !== 59)
              return;
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (code !== 32 && code !== 9)
                break;
            }
            if (i === str.length)
              return;
            let name;
            const nameStart = i;
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (TOKEN[code] !== 1) {
                if (code === 61)
                  break;
                return;
              }
            }
            if (i === str.length)
              return;
            let value = "";
            let valueStart;
            let charset;
            name = str.slice(nameStart, i);
            if (name.charCodeAt(name.length - 1) === 42) {
              const charsetStart = ++i;
              for (; i < str.length; ++i) {
                const code = str.charCodeAt(i);
                if (CHARSET[code] !== 1) {
                  if (code !== 39)
                    return;
                  break;
                }
              }
              if (i === str.length)
                return;
              charset = str.slice(charsetStart, i);
              ++i;
              for (; i < str.length; ++i) {
                const code = str.charCodeAt(i);
                if (code === 39)
                  break;
              }
              if (i === str.length)
                return;
              ++i;
              if (i === str.length)
                return;
              valueStart = i;
              let encode3 = 0;
              for (; i < str.length; ++i) {
                const code = str.charCodeAt(i);
                if (EXTENDED_VALUE[code] !== 1) {
                  if (code === 37) {
                    let hexUpper;
                    let hexLower;
                    if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                      const byteVal = (hexUpper << 4) + hexLower;
                      value += str.slice(valueStart, i);
                      value += String.fromCharCode(byteVal);
                      i += 2;
                      valueStart = i + 1;
                      if (byteVal >= 128)
                        encode3 = 2;
                      else if (encode3 === 0)
                        encode3 = 1;
                      continue;
                    }
                    return;
                  }
                  break;
                }
              }
              value += str.slice(valueStart, i);
              value = convertToUTF8(value, charset, encode3);
              if (value === void 0)
                return;
            } else {
              ++i;
              if (i === str.length)
                return;
              if (str.charCodeAt(i) === 34) {
                valueStart = ++i;
                let escaping = false;
                for (; i < str.length; ++i) {
                  const code = str.charCodeAt(i);
                  if (code === 92) {
                    if (escaping) {
                      valueStart = i;
                      escaping = false;
                    } else {
                      value += str.slice(valueStart, i);
                      escaping = true;
                    }
                    continue;
                  }
                  if (code === 34) {
                    if (escaping) {
                      valueStart = i;
                      escaping = false;
                      continue;
                    }
                    value += str.slice(valueStart, i);
                    break;
                  }
                  if (escaping) {
                    valueStart = i - 1;
                    escaping = false;
                  }
                  if (QDTEXT[code] !== 1)
                    return;
                }
                if (i === str.length)
                  return;
                ++i;
              } else {
                valueStart = i;
                for (; i < str.length; ++i) {
                  const code = str.charCodeAt(i);
                  if (TOKEN[code] !== 1) {
                    if (i === valueStart)
                      return;
                    break;
                  }
                }
                value = str.slice(valueStart, i);
              }
              value = defDecoder(value, 2);
              if (value === void 0)
                return;
            }
            name = name.toLowerCase();
            if (params[name] === void 0)
              params[name] = value;
          }
          return params;
        }
        __name(parseDispositionParams, "parseDispositionParams");
        function getDecoder(charset) {
          let lc;
          while (true) {
            switch (charset) {
              case "utf-8":
              case "utf8":
                return decoders.utf8;
              case "latin1":
              case "ascii":
              case "us-ascii":
              case "iso-8859-1":
              case "iso8859-1":
              case "iso88591":
              case "iso_8859-1":
              case "windows-1252":
              case "iso_8859-1:1987":
              case "cp1252":
              case "x-cp1252":
                return decoders.latin1;
              case "utf16le":
              case "utf-16le":
              case "ucs2":
              case "ucs-2":
                return decoders.utf16le;
              case "base64":
                return decoders.base64;
              default:
                if (lc === void 0) {
                  lc = true;
                  charset = charset.toLowerCase();
                  continue;
                }
                return decoders.other.bind(charset);
            }
          }
        }
        __name(getDecoder, "getDecoder");
        var decoders = {
          utf8: (data, hint) => {
            if (data.length === 0)
              return "";
            if (typeof data === "string") {
              if (hint < 2)
                return data;
              data = Buffer.from(data, "latin1");
            }
            return data.utf8Slice(0, data.length);
          },
          latin1: (data, hint) => {
            if (data.length === 0)
              return "";
            if (typeof data === "string")
              return data;
            return data.latin1Slice(0, data.length);
          },
          utf16le: (data, hint) => {
            if (data.length === 0)
              return "";
            if (typeof data === "string")
              data = Buffer.from(data, "latin1");
            return data.ucs2Slice(0, data.length);
          },
          base64: (data, hint) => {
            if (data.length === 0)
              return "";
            if (typeof data === "string")
              data = Buffer.from(data, "latin1");
            return data.base64Slice(0, data.length);
          },
          other: (data, hint) => {
            if (data.length === 0)
              return "";
            if (typeof data === "string")
              data = Buffer.from(data, "latin1");
            try {
              const decoder = new TextDecoder(exports2);
              return decoder.decode(data);
            } catch (e) {
            }
          }
        };
        function convertToUTF8(data, charset, hint) {
          const decode = getDecoder(charset);
          if (decode)
            return decode(data, hint);
        }
        __name(convertToUTF8, "convertToUTF8");
        function basename(path7) {
          if (typeof path7 !== "string")
            return "";
          for (let i = path7.length - 1; i >= 0; --i) {
            switch (path7.charCodeAt(i)) {
              case 47:
              case 92:
                path7 = path7.slice(i + 1);
                return path7 === ".." || path7 === "." ? "" : path7;
            }
          }
          return path7 === ".." || path7 === "." ? "" : path7;
        }
        __name(basename, "basename");
        var TOKEN = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          1,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ];
        var QDTEXT = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ];
        var CHARSET = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ];
        var EXTENDED_VALUE = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ];
        var HEX_VALUES = [
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          10,
          11,
          12,
          13,
          14,
          15,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          10,
          11,
          12,
          13,
          14,
          15,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1
        ];
        module2.exports = {
          basename,
          convertToUTF8,
          getDecoder,
          parseContentType,
          parseDisposition
        };
      }
    });
    var require_sbmh = __commonJS({
      "../../node_modules/.pnpm/streamsearch@1.1.0/node_modules/streamsearch/lib/sbmh.js"(exports2, module2) {
        "use strict";
        function memcmp(buf1, pos1, buf2, pos2, num) {
          for (let i = 0; i < num; ++i) {
            if (buf1[pos1 + i] !== buf2[pos2 + i])
              return false;
          }
          return true;
        }
        __name(memcmp, "memcmp");
        var SBMH = class {
          constructor(needle, cb) {
            if (typeof cb !== "function")
              throw new Error("Missing match callback");
            if (typeof needle === "string")
              needle = Buffer.from(needle);
            else if (!Buffer.isBuffer(needle))
              throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
            const needleLen = needle.length;
            this.maxMatches = Infinity;
            this.matches = 0;
            this._cb = cb;
            this._lookbehindSize = 0;
            this._needle = needle;
            this._bufPos = 0;
            this._lookbehind = Buffer.allocUnsafe(needleLen);
            this._occ = [
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen,
              needleLen
            ];
            if (needleLen > 1) {
              for (let i = 0; i < needleLen - 1; ++i)
                this._occ[needle[i]] = needleLen - 1 - i;
            }
          }
          reset() {
            this.matches = 0;
            this._lookbehindSize = 0;
            this._bufPos = 0;
          }
          push(chunk, pos) {
            let result;
            if (!Buffer.isBuffer(chunk))
              chunk = Buffer.from(chunk, "latin1");
            const chunkLen = chunk.length;
            this._bufPos = pos || 0;
            while (result !== chunkLen && this.matches < this.maxMatches)
              result = feed(this, chunk);
            return result;
          }
          destroy() {
            const lbSize = this._lookbehindSize;
            if (lbSize)
              this._cb(false, this._lookbehind, 0, lbSize, false);
            this.reset();
          }
        };
        __name(SBMH, "SBMH");
        function feed(self2, data) {
          const len = data.length;
          const needle = self2._needle;
          const needleLen = needle.length;
          let pos = -self2._lookbehindSize;
          const lastNeedleCharPos = needleLen - 1;
          const lastNeedleChar = needle[lastNeedleCharPos];
          const end = len - needleLen;
          const occ = self2._occ;
          const lookbehind = self2._lookbehind;
          if (pos < 0) {
            while (pos < 0 && pos <= end) {
              const nextPos = pos + lastNeedleCharPos;
              const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
              if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
                self2._lookbehindSize = 0;
                ++self2.matches;
                if (pos > -self2._lookbehindSize)
                  self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
                else
                  self2._cb(true, void 0, 0, 0, true);
                return self2._bufPos = pos + needleLen;
              }
              pos += occ[ch];
            }
            while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
              ++pos;
            if (pos < 0) {
              const bytesToCutOff = self2._lookbehindSize + pos;
              if (bytesToCutOff > 0) {
                self2._cb(false, lookbehind, 0, bytesToCutOff, false);
              }
              self2._lookbehindSize -= bytesToCutOff;
              lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
              lookbehind.set(data, self2._lookbehindSize);
              self2._lookbehindSize += len;
              self2._bufPos = len;
              return len;
            }
            self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
            self2._lookbehindSize = 0;
          }
          pos += self2._bufPos;
          const firstNeedleChar = needle[0];
          while (pos <= end) {
            const ch = data[pos + lastNeedleCharPos];
            if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
              ++self2.matches;
              if (pos > 0)
                self2._cb(true, data, self2._bufPos, pos, true);
              else
                self2._cb(true, void 0, 0, 0, true);
              return self2._bufPos = pos + needleLen;
            }
            pos += occ[ch];
          }
          while (pos < len) {
            if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
              ++pos;
              continue;
            }
            data.copy(lookbehind, 0, pos, len);
            self2._lookbehindSize = len - pos;
            break;
          }
          if (pos > 0)
            self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
          self2._bufPos = len;
          return len;
        }
        __name(feed, "feed");
        function matchNeedle(self2, data, pos, len) {
          const lb = self2._lookbehind;
          const lbSize = self2._lookbehindSize;
          const needle = self2._needle;
          for (let i = 0; i < len; ++i, ++pos) {
            const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
            if (ch !== needle[i])
              return false;
          }
          return true;
        }
        __name(matchNeedle, "matchNeedle");
        module2.exports = SBMH;
      }
    });
    var require_multipart = __commonJS({
      "../../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/multipart.js"(exports2, module2) {
        "use strict";
        var { Readable, Writable } = require("stream");
        var StreamSearch = require_sbmh();
        var {
          basename,
          convertToUTF8,
          getDecoder,
          parseContentType,
          parseDisposition
        } = require_utils();
        var BUF_CRLF = Buffer.from("\r\n");
        var BUF_CR = Buffer.from("\r");
        var BUF_DASH = Buffer.from("-");
        function noop4() {
        }
        __name(noop4, "noop");
        var MAX_HEADER_PAIRS = 2e3;
        var MAX_HEADER_SIZE = 16 * 1024;
        var HPARSER_NAME = 0;
        var HPARSER_PRE_OWS = 1;
        var HPARSER_VALUE = 2;
        var HeaderParser = class {
          constructor(cb) {
            this.header = /* @__PURE__ */ Object.create(null);
            this.pairCount = 0;
            this.byteCount = 0;
            this.state = HPARSER_NAME;
            this.name = "";
            this.value = "";
            this.crlf = 0;
            this.cb = cb;
          }
          reset() {
            this.header = /* @__PURE__ */ Object.create(null);
            this.pairCount = 0;
            this.byteCount = 0;
            this.state = HPARSER_NAME;
            this.name = "";
            this.value = "";
            this.crlf = 0;
          }
          push(chunk, pos, end) {
            let start = pos;
            while (pos < end) {
              switch (this.state) {
                case HPARSER_NAME: {
                  let done = false;
                  for (; pos < end; ++pos) {
                    if (this.byteCount === MAX_HEADER_SIZE)
                      return -1;
                    ++this.byteCount;
                    const code = chunk[pos];
                    if (TOKEN[code] !== 1) {
                      if (code !== 58)
                        return -1;
                      this.name += chunk.latin1Slice(start, pos);
                      if (this.name.length === 0)
                        return -1;
                      ++pos;
                      done = true;
                      this.state = HPARSER_PRE_OWS;
                      break;
                    }
                  }
                  if (!done) {
                    this.name += chunk.latin1Slice(start, pos);
                    break;
                  }
                }
                case HPARSER_PRE_OWS: {
                  let done = false;
                  for (; pos < end; ++pos) {
                    if (this.byteCount === MAX_HEADER_SIZE)
                      return -1;
                    ++this.byteCount;
                    const code = chunk[pos];
                    if (code !== 32 && code !== 9) {
                      start = pos;
                      done = true;
                      this.state = HPARSER_VALUE;
                      break;
                    }
                  }
                  if (!done)
                    break;
                }
                case HPARSER_VALUE:
                  switch (this.crlf) {
                    case 0:
                      for (; pos < end; ++pos) {
                        if (this.byteCount === MAX_HEADER_SIZE)
                          return -1;
                        ++this.byteCount;
                        const code = chunk[pos];
                        if (FIELD_VCHAR[code] !== 1) {
                          if (code !== 13)
                            return -1;
                          ++this.crlf;
                          break;
                        }
                      }
                      this.value += chunk.latin1Slice(start, pos++);
                      break;
                    case 1:
                      if (this.byteCount === MAX_HEADER_SIZE)
                        return -1;
                      ++this.byteCount;
                      if (chunk[pos++] !== 10)
                        return -1;
                      ++this.crlf;
                      break;
                    case 2: {
                      if (this.byteCount === MAX_HEADER_SIZE)
                        return -1;
                      ++this.byteCount;
                      const code = chunk[pos];
                      if (code === 32 || code === 9) {
                        start = pos;
                        this.crlf = 0;
                      } else {
                        if (++this.pairCount < MAX_HEADER_PAIRS) {
                          this.name = this.name.toLowerCase();
                          if (this.header[this.name] === void 0)
                            this.header[this.name] = [this.value];
                          else
                            this.header[this.name].push(this.value);
                        }
                        if (code === 13) {
                          ++this.crlf;
                          ++pos;
                        } else {
                          start = pos;
                          this.crlf = 0;
                          this.state = HPARSER_NAME;
                          this.name = "";
                          this.value = "";
                        }
                      }
                      break;
                    }
                    case 3: {
                      if (this.byteCount === MAX_HEADER_SIZE)
                        return -1;
                      ++this.byteCount;
                      if (chunk[pos++] !== 10)
                        return -1;
                      const header = this.header;
                      this.reset();
                      this.cb(header);
                      return pos;
                    }
                  }
                  break;
              }
            }
            return pos;
          }
        };
        __name(HeaderParser, "HeaderParser");
        var FileStream = class extends Readable {
          constructor(opts, owner) {
            super(opts);
            this.truncated = false;
            this._readcb = null;
            this.once("end", () => {
              this._read();
              if (--owner._fileEndsLeft === 0 && owner._finalcb) {
                const cb = owner._finalcb;
                owner._finalcb = null;
                process.nextTick(cb);
              }
            });
          }
          _read(n) {
            const cb = this._readcb;
            if (cb) {
              this._readcb = null;
              cb();
            }
          }
        };
        __name(FileStream, "FileStream");
        var ignoreData = {
          push: (chunk, pos) => {
          },
          destroy: () => {
          }
        };
        function callAndUnsetCb(self2, err) {
          const cb = self2._writecb;
          self2._writecb = null;
          if (err)
            self2.destroy(err);
          else if (cb)
            cb();
        }
        __name(callAndUnsetCb, "callAndUnsetCb");
        function nullDecoder(val, hint) {
          return val;
        }
        __name(nullDecoder, "nullDecoder");
        var Multipart = class extends Writable {
          constructor(cfg) {
            const streamOpts = {
              autoDestroy: true,
              emitClose: true,
              highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
            };
            super(streamOpts);
            if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
              throw new Error("Multipart: Boundary not found");
            const boundary = cfg.conType.params.boundary;
            const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
            const defCharset = cfg.defCharset || "utf8";
            const preservePath = cfg.preservePath;
            const fileOpts = {
              autoDestroy: true,
              emitClose: true,
              highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : void 0
            };
            const limits = cfg.limits;
            const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
            const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
            const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
            const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
            const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
            let parts = -1;
            let fields = 0;
            let files = 0;
            let skipPart = false;
            this._fileEndsLeft = 0;
            this._fileStream = void 0;
            this._complete = false;
            let fileSize = 0;
            let field;
            let fieldSize = 0;
            let partCharset;
            let partEncoding;
            let partType;
            let partName;
            let partTruncated = false;
            let hitFilesLimit = false;
            let hitFieldsLimit = false;
            this._hparser = null;
            const hparser = new HeaderParser((header) => {
              this._hparser = null;
              skipPart = false;
              partType = "text/plain";
              partCharset = defCharset;
              partEncoding = "7bit";
              partName = void 0;
              partTruncated = false;
              let filename;
              if (!header["content-disposition"]) {
                skipPart = true;
                return;
              }
              const disp = parseDisposition(
                header["content-disposition"][0],
                paramDecoder
              );
              if (!disp || disp.type !== "form-data") {
                skipPart = true;
                return;
              }
              if (disp.params) {
                if (disp.params.name)
                  partName = disp.params.name;
                if (disp.params["filename*"])
                  filename = disp.params["filename*"];
                else if (disp.params.filename)
                  filename = disp.params.filename;
                if (filename !== void 0 && !preservePath)
                  filename = basename(filename);
              }
              if (header["content-type"]) {
                const conType = parseContentType(header["content-type"][0]);
                if (conType) {
                  partType = `${conType.type}/${conType.subtype}`;
                  if (conType.params && typeof conType.params.charset === "string")
                    partCharset = conType.params.charset.toLowerCase();
                }
              }
              if (header["content-transfer-encoding"])
                partEncoding = header["content-transfer-encoding"][0].toLowerCase();
              if (partType === "application/octet-stream" || filename !== void 0) {
                if (files === filesLimit) {
                  if (!hitFilesLimit) {
                    hitFilesLimit = true;
                    this.emit("filesLimit");
                  }
                  skipPart = true;
                  return;
                }
                ++files;
                if (this.listenerCount("file") === 0) {
                  skipPart = true;
                  return;
                }
                fileSize = 0;
                this._fileStream = new FileStream(fileOpts, this);
                ++this._fileEndsLeft;
                this.emit(
                  "file",
                  partName,
                  this._fileStream,
                  {
                    filename,
                    encoding: partEncoding,
                    mimeType: partType
                  }
                );
              } else {
                if (fields === fieldsLimit) {
                  if (!hitFieldsLimit) {
                    hitFieldsLimit = true;
                    this.emit("fieldsLimit");
                  }
                  skipPart = true;
                  return;
                }
                ++fields;
                if (this.listenerCount("field") === 0) {
                  skipPart = true;
                  return;
                }
                field = [];
                fieldSize = 0;
              }
            });
            let matchPostBoundary = 0;
            const ssCb = /* @__PURE__ */ __name((isMatch, data, start, end, isDataSafe) => {
              retrydata:
                while (data) {
                  if (this._hparser !== null) {
                    const ret = this._hparser.push(data, start, end);
                    if (ret === -1) {
                      this._hparser = null;
                      hparser.reset();
                      this.emit("error", new Error("Malformed part header"));
                      break;
                    }
                    start = ret;
                  }
                  if (start === end)
                    break;
                  if (matchPostBoundary !== 0) {
                    if (matchPostBoundary === 1) {
                      switch (data[start]) {
                        case 45:
                          matchPostBoundary = 2;
                          ++start;
                          break;
                        case 13:
                          matchPostBoundary = 3;
                          ++start;
                          break;
                        default:
                          matchPostBoundary = 0;
                      }
                      if (start === end)
                        return;
                    }
                    if (matchPostBoundary === 2) {
                      matchPostBoundary = 0;
                      if (data[start] === 45) {
                        this._complete = true;
                        this._bparser = ignoreData;
                        return;
                      }
                      const writecb = this._writecb;
                      this._writecb = noop4;
                      ssCb(false, BUF_DASH, 0, 1, false);
                      this._writecb = writecb;
                    } else if (matchPostBoundary === 3) {
                      matchPostBoundary = 0;
                      if (data[start] === 10) {
                        ++start;
                        if (parts >= partsLimit)
                          break;
                        this._hparser = hparser;
                        if (start === end)
                          break;
                        continue retrydata;
                      } else {
                        const writecb = this._writecb;
                        this._writecb = noop4;
                        ssCb(false, BUF_CR, 0, 1, false);
                        this._writecb = writecb;
                      }
                    }
                  }
                  if (!skipPart) {
                    if (this._fileStream) {
                      let chunk;
                      const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                      if (!isDataSafe) {
                        chunk = Buffer.allocUnsafe(actualLen);
                        data.copy(chunk, 0, start, start + actualLen);
                      } else {
                        chunk = data.slice(start, start + actualLen);
                      }
                      fileSize += chunk.length;
                      if (fileSize === fileSizeLimit) {
                        if (chunk.length > 0)
                          this._fileStream.push(chunk);
                        this._fileStream.emit("limit");
                        this._fileStream.truncated = true;
                        skipPart = true;
                      } else if (!this._fileStream.push(chunk)) {
                        if (this._writecb)
                          this._fileStream._readcb = this._writecb;
                        this._writecb = null;
                      }
                    } else if (field !== void 0) {
                      let chunk;
                      const actualLen = Math.min(
                        end - start,
                        fieldSizeLimit - fieldSize
                      );
                      if (!isDataSafe) {
                        chunk = Buffer.allocUnsafe(actualLen);
                        data.copy(chunk, 0, start, start + actualLen);
                      } else {
                        chunk = data.slice(start, start + actualLen);
                      }
                      fieldSize += actualLen;
                      field.push(chunk);
                      if (fieldSize === fieldSizeLimit) {
                        skipPart = true;
                        partTruncated = true;
                      }
                    }
                  }
                  break;
                }
              if (isMatch) {
                matchPostBoundary = 1;
                if (this._fileStream) {
                  this._fileStream.push(null);
                  this._fileStream = null;
                } else if (field !== void 0) {
                  let data2;
                  switch (field.length) {
                    case 0:
                      data2 = "";
                      break;
                    case 1:
                      data2 = convertToUTF8(field[0], partCharset, 0);
                      break;
                    default:
                      data2 = convertToUTF8(
                        Buffer.concat(field, fieldSize),
                        partCharset,
                        0
                      );
                  }
                  field = void 0;
                  fieldSize = 0;
                  this.emit(
                    "field",
                    partName,
                    data2,
                    {
                      nameTruncated: false,
                      valueTruncated: partTruncated,
                      encoding: partEncoding,
                      mimeType: partType
                    }
                  );
                }
                if (++parts === partsLimit)
                  this.emit("partsLimit");
              }
            }, "ssCb");
            this._bparser = new StreamSearch(`\r
--${boundary}`, ssCb);
            this._writecb = null;
            this._finalcb = null;
            this.write(BUF_CRLF);
          }
          static detect(conType) {
            return conType.type === "multipart" && conType.subtype === "form-data";
          }
          _write(chunk, enc, cb) {
            this._writecb = cb;
            this._bparser.push(chunk, 0);
            if (this._writecb)
              callAndUnsetCb(this);
          }
          _destroy(err, cb) {
            this._hparser = null;
            this._bparser = ignoreData;
            if (!err)
              err = checkEndState(this);
            const fileStream = this._fileStream;
            if (fileStream) {
              this._fileStream = null;
              fileStream.destroy(err);
            }
            cb(err);
          }
          _final(cb) {
            this._bparser.destroy();
            if (!this._complete)
              return cb(new Error("Unexpected end of form"));
            if (this._fileEndsLeft)
              this._finalcb = finalcb.bind(null, this, cb);
            else
              finalcb(this, cb);
          }
        };
        __name(Multipart, "Multipart");
        function finalcb(self2, cb, err) {
          if (err)
            return cb(err);
          err = checkEndState(self2);
          cb(err);
        }
        __name(finalcb, "finalcb");
        function checkEndState(self2) {
          if (self2._hparser)
            return new Error("Malformed part header");
          const fileStream = self2._fileStream;
          if (fileStream) {
            self2._fileStream = null;
            fileStream.destroy(new Error("Unexpected end of file"));
          }
          if (!self2._complete)
            return new Error("Unexpected end of form");
        }
        __name(checkEndState, "checkEndState");
        var TOKEN = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          1,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ];
        var FIELD_VCHAR = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ];
        module2.exports = Multipart;
      }
    });
    var require_urlencoded = __commonJS({
      "../../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/urlencoded.js"(exports2, module2) {
        "use strict";
        var { Writable } = require("stream");
        var { getDecoder } = require_utils();
        var URLEncoded = class extends Writable {
          constructor(cfg) {
            const streamOpts = {
              autoDestroy: true,
              emitClose: true,
              highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
            };
            super(streamOpts);
            let charset = cfg.defCharset || "utf8";
            if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
              charset = cfg.conType.params.charset;
            this.charset = charset;
            const limits = cfg.limits;
            this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
            this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
            this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
            this._inKey = true;
            this._keyTrunc = false;
            this._valTrunc = false;
            this._bytesKey = 0;
            this._bytesVal = 0;
            this._fields = 0;
            this._key = "";
            this._val = "";
            this._byte = -2;
            this._lastPos = 0;
            this._encode = 0;
            this._decoder = getDecoder(charset);
          }
          static detect(conType) {
            return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
          }
          _write(chunk, enc, cb) {
            if (this._fields >= this.fieldsLimit)
              return cb();
            let i = 0;
            const len = chunk.length;
            this._lastPos = 0;
            if (this._byte !== -2) {
              i = readPctEnc(this, chunk, i, len);
              if (i === -1)
                return cb(new Error("Malformed urlencoded form"));
              if (i >= len)
                return cb();
              if (this._inKey)
                ++this._bytesKey;
              else
                ++this._bytesVal;
            }
            main:
              while (i < len) {
                if (this._inKey) {
                  i = skipKeyBytes(this, chunk, i, len);
                  while (i < len) {
                    switch (chunk[i]) {
                      case 61:
                        if (this._lastPos < i)
                          this._key += chunk.latin1Slice(this._lastPos, i);
                        this._lastPos = ++i;
                        this._key = this._decoder(this._key, this._encode);
                        this._encode = 0;
                        this._inKey = false;
                        continue main;
                      case 38:
                        if (this._lastPos < i)
                          this._key += chunk.latin1Slice(this._lastPos, i);
                        this._lastPos = ++i;
                        this._key = this._decoder(this._key, this._encode);
                        this._encode = 0;
                        if (this._bytesKey > 0) {
                          this.emit(
                            "field",
                            this._key,
                            "",
                            {
                              nameTruncated: this._keyTrunc,
                              valueTruncated: false,
                              encoding: this.charset,
                              mimeType: "text/plain"
                            }
                          );
                        }
                        this._key = "";
                        this._val = "";
                        this._keyTrunc = false;
                        this._valTrunc = false;
                        this._bytesKey = 0;
                        this._bytesVal = 0;
                        if (++this._fields >= this.fieldsLimit) {
                          this.emit("fieldsLimit");
                          return cb();
                        }
                        continue;
                      case 43:
                        if (this._lastPos < i)
                          this._key += chunk.latin1Slice(this._lastPos, i);
                        this._key += " ";
                        this._lastPos = i + 1;
                        break;
                      case 37:
                        if (this._encode === 0)
                          this._encode = 1;
                        if (this._lastPos < i)
                          this._key += chunk.latin1Slice(this._lastPos, i);
                        this._lastPos = i + 1;
                        this._byte = -1;
                        i = readPctEnc(this, chunk, i + 1, len);
                        if (i === -1)
                          return cb(new Error("Malformed urlencoded form"));
                        if (i >= len)
                          return cb();
                        ++this._bytesKey;
                        i = skipKeyBytes(this, chunk, i, len);
                        continue;
                    }
                    ++i;
                    ++this._bytesKey;
                    i = skipKeyBytes(this, chunk, i, len);
                  }
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                } else {
                  i = skipValBytes(this, chunk, i, len);
                  while (i < len) {
                    switch (chunk[i]) {
                      case 38:
                        if (this._lastPos < i)
                          this._val += chunk.latin1Slice(this._lastPos, i);
                        this._lastPos = ++i;
                        this._inKey = true;
                        this._val = this._decoder(this._val, this._encode);
                        this._encode = 0;
                        if (this._bytesKey > 0 || this._bytesVal > 0) {
                          this.emit(
                            "field",
                            this._key,
                            this._val,
                            {
                              nameTruncated: this._keyTrunc,
                              valueTruncated: this._valTrunc,
                              encoding: this.charset,
                              mimeType: "text/plain"
                            }
                          );
                        }
                        this._key = "";
                        this._val = "";
                        this._keyTrunc = false;
                        this._valTrunc = false;
                        this._bytesKey = 0;
                        this._bytesVal = 0;
                        if (++this._fields >= this.fieldsLimit) {
                          this.emit("fieldsLimit");
                          return cb();
                        }
                        continue main;
                      case 43:
                        if (this._lastPos < i)
                          this._val += chunk.latin1Slice(this._lastPos, i);
                        this._val += " ";
                        this._lastPos = i + 1;
                        break;
                      case 37:
                        if (this._encode === 0)
                          this._encode = 1;
                        if (this._lastPos < i)
                          this._val += chunk.latin1Slice(this._lastPos, i);
                        this._lastPos = i + 1;
                        this._byte = -1;
                        i = readPctEnc(this, chunk, i + 1, len);
                        if (i === -1)
                          return cb(new Error("Malformed urlencoded form"));
                        if (i >= len)
                          return cb();
                        ++this._bytesVal;
                        i = skipValBytes(this, chunk, i, len);
                        continue;
                    }
                    ++i;
                    ++this._bytesVal;
                    i = skipValBytes(this, chunk, i, len);
                  }
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                }
              }
            cb();
          }
          _final(cb) {
            if (this._byte !== -2)
              return cb(new Error("Malformed urlencoded form"));
            if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
              if (this._inKey)
                this._key = this._decoder(this._key, this._encode);
              else
                this._val = this._decoder(this._val, this._encode);
              this.emit(
                "field",
                this._key,
                this._val,
                {
                  nameTruncated: this._keyTrunc,
                  valueTruncated: this._valTrunc,
                  encoding: this.charset,
                  mimeType: "text/plain"
                }
              );
            }
            cb();
          }
        };
        __name(URLEncoded, "URLEncoded");
        function readPctEnc(self2, chunk, pos, len) {
          if (pos >= len)
            return len;
          if (self2._byte === -1) {
            const hexUpper = HEX_VALUES[chunk[pos++]];
            if (hexUpper === -1)
              return -1;
            if (hexUpper >= 8)
              self2._encode = 2;
            if (pos < len) {
              const hexLower = HEX_VALUES[chunk[pos++]];
              if (hexLower === -1)
                return -1;
              if (self2._inKey)
                self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
              else
                self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
              self2._byte = -2;
              self2._lastPos = pos;
            } else {
              self2._byte = hexUpper;
            }
          } else {
            const hexLower = HEX_VALUES[chunk[pos++]];
            if (hexLower === -1)
              return -1;
            if (self2._inKey)
              self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
            else
              self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
            self2._byte = -2;
            self2._lastPos = pos;
          }
          return pos;
        }
        __name(readPctEnc, "readPctEnc");
        function skipKeyBytes(self2, chunk, pos, len) {
          if (self2._bytesKey > self2.fieldNameSizeLimit) {
            if (!self2._keyTrunc) {
              if (self2._lastPos < pos)
                self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
            }
            self2._keyTrunc = true;
            for (; pos < len; ++pos) {
              const code = chunk[pos];
              if (code === 61 || code === 38)
                break;
              ++self2._bytesKey;
            }
            self2._lastPos = pos;
          }
          return pos;
        }
        __name(skipKeyBytes, "skipKeyBytes");
        function skipValBytes(self2, chunk, pos, len) {
          if (self2._bytesVal > self2.fieldSizeLimit) {
            if (!self2._valTrunc) {
              if (self2._lastPos < pos)
                self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
            }
            self2._valTrunc = true;
            for (; pos < len; ++pos) {
              if (chunk[pos] === 38)
                break;
              ++self2._bytesVal;
            }
            self2._lastPos = pos;
          }
          return pos;
        }
        __name(skipValBytes, "skipValBytes");
        var HEX_VALUES = [
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          10,
          11,
          12,
          13,
          14,
          15,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          10,
          11,
          12,
          13,
          14,
          15,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1
        ];
        module2.exports = URLEncoded;
      }
    });
    var require_lib = __commonJS({
      "../../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/index.js"(exports2, module2) {
        "use strict";
        var { parseContentType } = require_utils();
        function getInstance(cfg) {
          const headers = cfg.headers;
          const conType = parseContentType(headers["content-type"]);
          if (!conType)
            throw new Error("Malformed content type");
          for (const type of TYPES) {
            const matched = type.detect(conType);
            if (!matched)
              continue;
            const instanceCfg = {
              limits: cfg.limits,
              headers,
              conType,
              highWaterMark: void 0,
              fileHwm: void 0,
              defCharset: void 0,
              defParamCharset: void 0,
              preservePath: false
            };
            if (cfg.highWaterMark)
              instanceCfg.highWaterMark = cfg.highWaterMark;
            if (cfg.fileHwm)
              instanceCfg.fileHwm = cfg.fileHwm;
            instanceCfg.defCharset = cfg.defCharset;
            instanceCfg.defParamCharset = cfg.defParamCharset;
            instanceCfg.preservePath = cfg.preservePath;
            return new type(instanceCfg);
          }
          throw new Error(`Unsupported content type: ${headers["content-type"]}`);
        }
        __name(getInstance, "getInstance");
        var TYPES = [
          require_multipart(),
          require_urlencoded()
        ].filter(function(typemod) {
          return typeof typemod.detect === "function";
        });
        module2.exports = (cfg) => {
          if (typeof cfg !== "object" || cfg === null)
            cfg = {};
          if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
            throw new Error("Missing Content-Type");
          }
          return getInstance(cfg);
        };
      }
    });
    var require_constants = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
        "use strict";
        var corsSafeListedMethods = ["GET", "HEAD", "POST"];
        var nullBodyStatus = [101, 204, 205, 304];
        var redirectStatus = [301, 302, 303, 307, 308];
        var referrerPolicy = [
          "",
          "no-referrer",
          "no-referrer-when-downgrade",
          "same-origin",
          "origin",
          "strict-origin",
          "origin-when-cross-origin",
          "strict-origin-when-cross-origin",
          "unsafe-url"
        ];
        var requestRedirect = ["follow", "manual", "error"];
        var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
        var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
        var requestCredentials = ["omit", "same-origin", "include"];
        var requestCache = [
          "default",
          "no-store",
          "reload",
          "no-cache",
          "force-cache",
          "only-if-cached"
        ];
        var requestBodyHeader = [
          "content-encoding",
          "content-language",
          "content-location",
          "content-type"
        ];
        var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
        var subresource = [
          "audio",
          "audioworklet",
          "font",
          "image",
          "manifest",
          "paintworklet",
          "script",
          "style",
          "track",
          "video",
          "xslt",
          ""
        ];
        var _a32;
        var DOMException = (_a32 = globalThis.DOMException) != null ? _a32 : (() => {
          try {
            atob("~");
          } catch (err) {
            return Object.getPrototypeOf(err).constructor;
          }
        })();
        module2.exports = {
          DOMException,
          subresource,
          forbiddenMethods,
          requestBodyHeader,
          referrerPolicy,
          requestRedirect,
          requestMode,
          requestCredentials,
          requestCache,
          redirectStatus,
          corsSafeListedMethods,
          nullBodyStatus,
          safeMethods
        };
      }
    });
    var require_util3 = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/util.js"(exports2, module2) {
        "use strict";
        var { redirectStatus } = require_constants();
        var { performance: performance3 } = require("perf_hooks");
        var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util2();
        var assert2 = require("assert");
        var { isUint8Array } = require("util/types");
        var crypto22;
        try {
          crypto22 = require("crypto");
        } catch (e) {
        }
        var badPorts = [
          "1",
          "7",
          "9",
          "11",
          "13",
          "15",
          "17",
          "19",
          "20",
          "21",
          "22",
          "23",
          "25",
          "37",
          "42",
          "43",
          "53",
          "69",
          "77",
          "79",
          "87",
          "95",
          "101",
          "102",
          "103",
          "104",
          "109",
          "110",
          "111",
          "113",
          "115",
          "117",
          "119",
          "123",
          "135",
          "137",
          "139",
          "143",
          "161",
          "179",
          "389",
          "427",
          "465",
          "512",
          "513",
          "514",
          "515",
          "526",
          "530",
          "531",
          "532",
          "540",
          "548",
          "554",
          "556",
          "563",
          "587",
          "601",
          "636",
          "989",
          "990",
          "993",
          "995",
          "1719",
          "1720",
          "1723",
          "2049",
          "3659",
          "4045",
          "5060",
          "5061",
          "6000",
          "6566",
          "6665",
          "6666",
          "6667",
          "6668",
          "6669",
          "6697",
          "10080"
        ];
        function responseURL(response) {
          const urlList = response.urlList;
          const length = urlList.length;
          return length === 0 ? null : urlList[length - 1].toString();
        }
        __name(responseURL, "responseURL");
        function responseLocationURL(response, requestFragment) {
          if (!redirectStatus.includes(response.status)) {
            return null;
          }
          let location = response.headersList.get("location");
          location = location ? new URL(location, responseURL(response)) : null;
          if (location && !location.hash) {
            location.hash = requestFragment;
          }
          return location;
        }
        __name(responseLocationURL, "responseLocationURL");
        function requestCurrentURL(request2) {
          return request2.urlList[request2.urlList.length - 1];
        }
        __name(requestCurrentURL, "requestCurrentURL");
        function requestBadPort(request2) {
          const url2 = requestCurrentURL(request2);
          if (/^https?:/.test(url2.protocol) && badPorts.includes(url2.port)) {
            return "blocked";
          }
          return "allowed";
        }
        __name(requestBadPort, "requestBadPort");
        function isErrorLike(object) {
          var _a32, _b22;
          return object instanceof Error || (((_a32 = object == null ? void 0 : object.constructor) == null ? void 0 : _a32.name) === "Error" || ((_b22 = object == null ? void 0 : object.constructor) == null ? void 0 : _b22.name) === "DOMException");
        }
        __name(isErrorLike, "isErrorLike");
        function isValidReasonPhrase(statusText) {
          for (let i = 0; i < statusText.length; ++i) {
            const c = statusText.charCodeAt(i);
            if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {
              return false;
            }
          }
          return true;
        }
        __name(isValidReasonPhrase, "isValidReasonPhrase");
        function isTokenChar(c) {
          return !(c >= 127 || c <= 32 || c === "(" || c === ")" || c === "<" || c === ">" || c === "@" || c === "," || c === ";" || c === ":" || c === "\\" || c === '"' || c === "/" || c === "[" || c === "]" || c === "?" || c === "=" || c === "{" || c === "}");
        }
        __name(isTokenChar, "isTokenChar");
        function isValidHTTPToken(characters) {
          if (!characters || typeof characters !== "string") {
            return false;
          }
          for (let i = 0; i < characters.length; ++i) {
            const c = characters.charCodeAt(i);
            if (c > 127 || !isTokenChar(c)) {
              return false;
            }
          }
          return true;
        }
        __name(isValidHTTPToken, "isValidHTTPToken");
        function isValidHeaderName2(potentialValue) {
          if (potentialValue.length === 0) {
            return false;
          }
          for (const char of potentialValue) {
            if (!isValidHTTPToken(char)) {
              return false;
            }
          }
          return true;
        }
        __name(isValidHeaderName2, "isValidHeaderName");
        function isValidHeaderValue(potentialValue) {
          if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
            return false;
          }
          if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
            return false;
          }
          return true;
        }
        __name(isValidHeaderValue, "isValidHeaderValue");
        function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {
          const policy = "";
          if (policy !== "") {
            request2.referrerPolicy = policy;
          }
        }
        __name(setRequestReferrerPolicyOnRedirect, "setRequestReferrerPolicyOnRedirect");
        function crossOriginResourcePolicyCheck() {
          return "allowed";
        }
        __name(crossOriginResourcePolicyCheck, "crossOriginResourcePolicyCheck");
        function corsCheck() {
          return "success";
        }
        __name(corsCheck, "corsCheck");
        function TAOCheck() {
          return "success";
        }
        __name(TAOCheck, "TAOCheck");
        function appendFetchMetadata(httpRequest) {
          let header = null;
          header = httpRequest.mode;
          httpRequest.headersList.set("sec-fetch-mode", header);
        }
        __name(appendFetchMetadata, "appendFetchMetadata");
        function appendRequestOriginHeader(request2) {
          let serializedOrigin = request2.origin;
          if (request2.responseTainting === "cors" || request2.mode === "websocket") {
            if (serializedOrigin) {
              request2.headersList.append("Origin", serializedOrigin);
            }
          } else if (request2.method !== "GET" && request2.method !== "HEAD") {
            switch (request2.referrerPolicy) {
              case "no-referrer":
                serializedOrigin = null;
                break;
              case "no-referrer-when-downgrade":
              case "strict-origin":
              case "strict-origin-when-cross-origin":
                if (/^https:/.test(request2.origin) && !/^https:/.test(requestCurrentURL(request2))) {
                  serializedOrigin = null;
                }
                break;
              case "same-origin":
                if (!sameOrigin(request2, requestCurrentURL(request2))) {
                  serializedOrigin = null;
                }
                break;
              default:
            }
            if (serializedOrigin) {
              request2.headersList.append("Origin", serializedOrigin);
            }
          }
        }
        __name(appendRequestOriginHeader, "appendRequestOriginHeader");
        function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
          return performance3.now();
        }
        __name(coarsenedSharedCurrentTime, "coarsenedSharedCurrentTime");
        function createOpaqueTimingInfo(timingInfo) {
          var _a32, _b22;
          return {
            startTime: (_a32 = timingInfo.startTime) != null ? _a32 : 0,
            redirectStartTime: 0,
            redirectEndTime: 0,
            postRedirectStartTime: (_b22 = timingInfo.startTime) != null ? _b22 : 0,
            finalServiceWorkerStartTime: 0,
            finalNetworkResponseStartTime: 0,
            finalNetworkRequestStartTime: 0,
            endTime: 0,
            encodedBodySize: 0,
            decodedBodySize: 0,
            finalConnectionTimingInfo: null
          };
        }
        __name(createOpaqueTimingInfo, "createOpaqueTimingInfo");
        function makePolicyContainer() {
          return {};
        }
        __name(makePolicyContainer, "makePolicyContainer");
        function clonePolicyContainer() {
          return {};
        }
        __name(clonePolicyContainer, "clonePolicyContainer");
        function determineRequestsReferrer(request2) {
          var _a32, _b22, _c2, _d2, _e, _f, _g;
          const policy = request2.referrerPolicy;
          if (policy == null || policy === "" || policy === "no-referrer") {
            return "no-referrer";
          }
          const environment = request2.client;
          let referrerSource = null;
          if (request2.referrer === "client") {
            if (((_c2 = (_b22 = (_a32 = request2.client) == null ? void 0 : _a32.globalObject) == null ? void 0 : _b22.constructor) == null ? void 0 : _c2.name) === "Window") {
              const origin = (_f = (_d2 = environment.globalObject.self) == null ? void 0 : _d2.origin) != null ? _f : (_e = environment.globalObject.location) == null ? void 0 : _e.origin;
              if (origin == null || origin === "null")
                return "no-referrer";
              referrerSource = new URL(environment.globalObject.location.href);
            } else {
              if (((_g = environment == null ? void 0 : environment.globalObject) == null ? void 0 : _g.location) == null) {
                return "no-referrer";
              }
              referrerSource = new URL(environment.globalObject.location.href);
            }
          } else if (request2.referrer instanceof URL) {
            referrerSource = request2.referrer;
          } else {
            return "no-referrer";
          }
          const urlProtocol = referrerSource.protocol;
          if (urlProtocol === "about:" || urlProtocol === "data:" || urlProtocol === "blob:") {
            return "no-referrer";
          }
          let temp;
          let referrerOrigin;
          const referrerUrl = (temp = stripURLForReferrer(referrerSource)).length > 4096 ? referrerOrigin = stripURLForReferrer(referrerSource, true) : temp;
          const areSameOrigin = sameOrigin(request2, referrerUrl);
          const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerUrl) && !isURLPotentiallyTrustworthy(request2.url);
          switch (policy) {
            case "origin":
              return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
            case "unsafe-url":
              return referrerUrl;
            case "same-origin":
              return areSameOrigin ? referrerOrigin : "no-referrer";
            case "origin-when-cross-origin":
              return areSameOrigin ? referrerUrl : referrerOrigin;
            case "strict-origin-when-cross-origin":
              if (areSameOrigin)
                return referrerOrigin;
            case "strict-origin":
            case "no-referrer-when-downgrade":
            default:
              return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
          }
          function stripURLForReferrer(url2, originOnly = false) {
            const urlObject = new URL(url2.href);
            urlObject.username = "";
            urlObject.password = "";
            urlObject.hash = "";
            return originOnly ? urlObject.origin : urlObject.href;
          }
          __name(stripURLForReferrer, "stripURLForReferrer");
        }
        __name(determineRequestsReferrer, "determineRequestsReferrer");
        function isURLPotentiallyTrustworthy(url2) {
          if (!(url2 instanceof URL)) {
            return false;
          }
          if (url2.href === "about:blank" || url2.href === "about:srcdoc") {
            return true;
          }
          if (url2.protocol === "data:")
            return true;
          if (url2.protocol === "file:")
            return true;
          return isOriginPotentiallyTrustworthy(url2.origin);
          function isOriginPotentiallyTrustworthy(origin) {
            if (origin == null || origin === "null")
              return false;
            const originAsURL = new URL(origin);
            if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
              return true;
            }
            if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
              return true;
            }
            return false;
          }
          __name(isOriginPotentiallyTrustworthy, "isOriginPotentiallyTrustworthy");
        }
        __name(isURLPotentiallyTrustworthy, "isURLPotentiallyTrustworthy");
        function bytesMatch(bytes, metadataList) {
          if (crypto22 === void 0) {
            return true;
          }
          const parsedMetadata = parseMetadata(metadataList);
          if (parsedMetadata === "no metadata") {
            return true;
          }
          if (parsedMetadata.length === 0) {
            return true;
          }
          const metadata = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));
          for (const item of metadata) {
            const algorithm = item.algo;
            const expectedValue = item.hash;
            const actualValue = crypto22.createHash(algorithm).update(bytes).digest("base64");
            if (actualValue === expectedValue) {
              return true;
            }
          }
          return false;
        }
        __name(bytesMatch, "bytesMatch");
        var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={1,2}))( +[\x21-\x7e]?)?/i;
        function parseMetadata(metadata) {
          const result = [];
          let empty2 = true;
          const supportedHashes = crypto22.getHashes();
          for (const token of metadata.split(" ")) {
            empty2 = false;
            const parsedToken = parseHashWithOptions.exec(token);
            if (parsedToken === null || parsedToken.groups === void 0) {
              continue;
            }
            const algorithm = parsedToken.groups.algo;
            if (supportedHashes.includes(algorithm.toLowerCase())) {
              result.push(parsedToken.groups);
            }
          }
          if (empty2 === true) {
            return "no metadata";
          }
          return result;
        }
        __name(parseMetadata, "parseMetadata");
        function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {
        }
        __name(tryUpgradeRequestToAPotentiallyTrustworthyURL, "tryUpgradeRequestToAPotentiallyTrustworthyURL");
        function sameOrigin(A, B) {
          if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
            return true;
          }
          return false;
        }
        __name(sameOrigin, "sameOrigin");
        function createDeferredPromise() {
          let res;
          let rej;
          const promise = new Promise((resolve, reject) => {
            res = resolve;
            rej = reject;
          });
          return { promise, resolve: res, reject: rej };
        }
        __name(createDeferredPromise, "createDeferredPromise");
        function isAborted(fetchParams) {
          return fetchParams.controller.state === "aborted";
        }
        __name(isAborted, "isAborted");
        function isCancelled(fetchParams) {
          return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
        }
        __name(isCancelled, "isCancelled");
        function normalizeMethod(method) {
          return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;
        }
        __name(normalizeMethod, "normalizeMethod");
        function serializeJavascriptValueToJSONString(value) {
          const result = JSON.stringify(value);
          if (result === void 0) {
            throw new TypeError("Value is not JSON serializable");
          }
          assert2(typeof result === "string");
          return result;
        }
        __name(serializeJavascriptValueToJSONString, "serializeJavascriptValueToJSONString");
        var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
        function makeIterator(iterator, name) {
          const i = {
            next() {
              if (Object.getPrototypeOf(this) !== i) {
                throw new TypeError(
                  `'next' called on an object that does not implement interface ${name} Iterator.`
                );
              }
              return iterator.next();
            },
            [Symbol.toStringTag]: `${name} Iterator`
          };
          Object.setPrototypeOf(i, esIteratorPrototype);
          return Object.setPrototypeOf({}, i);
        }
        __name(makeIterator, "makeIterator");
        async function fullyReadBody(body, processBody, processBodyError) {
          try {
            const chunks = [];
            let length = 0;
            const reader = body.stream.getReader();
            while (true) {
              const { done, value } = await reader.read();
              if (done === true) {
                break;
              }
              assert2(isUint8Array(value));
              chunks.push(value);
              length += value.byteLength;
            }
            const fulfilledSteps = /* @__PURE__ */ __name((bytes) => queueMicrotask(() => {
              processBody(bytes);
            }), "fulfilledSteps");
            fulfilledSteps(Buffer.concat(chunks, length));
          } catch (err) {
            queueMicrotask(() => processBodyError(err));
          }
        }
        __name(fullyReadBody, "fullyReadBody");
        var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
        module2.exports = {
          isAborted,
          isCancelled,
          createDeferredPromise,
          ReadableStreamFrom,
          toUSVString,
          tryUpgradeRequestToAPotentiallyTrustworthyURL,
          coarsenedSharedCurrentTime,
          determineRequestsReferrer,
          makePolicyContainer,
          clonePolicyContainer,
          appendFetchMetadata,
          appendRequestOriginHeader,
          TAOCheck,
          corsCheck,
          crossOriginResourcePolicyCheck,
          createOpaqueTimingInfo,
          setRequestReferrerPolicyOnRedirect,
          isValidHTTPToken,
          requestBadPort,
          requestCurrentURL,
          responseURL,
          responseLocationURL,
          isBlobLike,
          isURLPotentiallyTrustworthy,
          isValidReasonPhrase,
          sameOrigin,
          normalizeMethod,
          serializeJavascriptValueToJSONString,
          makeIterator,
          isValidHeaderName: isValidHeaderName2,
          isValidHeaderValue,
          hasOwn,
          isErrorLike,
          fullyReadBody,
          bytesMatch
        };
      }
    });
    var require_symbols2 = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
        "use strict";
        module2.exports = {
          kUrl: Symbol("url"),
          kHeaders: Symbol("headers"),
          kSignal: Symbol("signal"),
          kState: Symbol("state"),
          kGuard: Symbol("guard"),
          kRealm: Symbol("realm")
        };
      }
    });
    var require_webidl = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
        "use strict";
        var { types: types2 } = require("util");
        var { hasOwn, toUSVString } = require_util3();
        var webidl = {};
        webidl.converters = {};
        webidl.util = {};
        webidl.errors = {};
        webidl.errors.exception = function(message) {
          throw new TypeError(`${message.header}: ${message.message}`);
        };
        webidl.errors.conversionFailed = function(context3) {
          const plural = context3.types.length === 1 ? "" : " one of";
          const message = `${context3.argument} could not be converted to${plural}: ${context3.types.join(", ")}.`;
          return webidl.errors.exception({
            header: context3.prefix,
            message
          });
        };
        webidl.errors.invalidArgument = function(context3) {
          return webidl.errors.exception({
            header: context3.prefix,
            message: `"${context3.value}" is an invalid ${context3.type}.`
          });
        };
        webidl.util.Type = function(V) {
          switch (typeof V) {
            case "undefined":
              return "Undefined";
            case "boolean":
              return "Boolean";
            case "string":
              return "String";
            case "symbol":
              return "Symbol";
            case "number":
              return "Number";
            case "bigint":
              return "BigInt";
            case "function":
            case "object": {
              if (V === null) {
                return "Null";
              }
              return "Object";
            }
          }
        };
        webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
          let upperBound;
          let lowerBound;
          if (bitLength === 64) {
            upperBound = Math.pow(2, 53) - 1;
            if (signedness === "unsigned") {
              lowerBound = 0;
            } else {
              lowerBound = Math.pow(-2, 53) + 1;
            }
          } else if (signedness === "unsigned") {
            lowerBound = 0;
            upperBound = Math.pow(2, bitLength) - 1;
          } else {
            lowerBound = Math.pow(-2, bitLength) - 1;
            upperBound = Math.pow(2, bitLength - 1) - 1;
          }
          let x = Number(V);
          if (Object.is(-0, x)) {
            x = 0;
          }
          if (opts.enforceRange === true) {
            if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
              webidl.errors.exception({
                header: "Integer conversion",
                message: `Could not convert ${V} to an integer.`
              });
            }
            x = webidl.util.IntegerPart(x);
            if (x < lowerBound || x > upperBound) {
              webidl.errors.exception({
                header: "Integer conversion",
                message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
              });
            }
            return x;
          }
          if (!Number.isNaN(x) && opts.clamp === true) {
            x = Math.min(Math.max(x, lowerBound), upperBound);
            if (Math.floor(x) % 2 === 0) {
              x = Math.floor(x);
            } else {
              x = Math.ceil(x);
            }
            return x;
          }
          if (Number.isNaN(x) || Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
            return 0;
          }
          x = webidl.util.IntegerPart(x);
          x = x % Math.pow(2, bitLength);
          if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
            return x - Math.pow(2, bitLength);
          }
          return x;
        };
        webidl.util.IntegerPart = function(n) {
          const r = Math.floor(Math.abs(n));
          if (n < 0) {
            return -1 * r;
          }
          return r;
        };
        webidl.sequenceConverter = function(converter) {
          return (V) => {
            var _a32;
            if (webidl.util.Type(V) !== "Object") {
              webidl.errors.exception({
                header: "Sequence",
                message: `Value of type ${webidl.util.Type(V)} is not an Object.`
              });
            }
            const method = (_a32 = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a32.call(V);
            const seq = [];
            if (method === void 0 || typeof method.next !== "function") {
              webidl.errors.exception({
                header: "Sequence",
                message: "Object is not an iterator."
              });
            }
            while (true) {
              const { done, value } = method.next();
              if (done) {
                break;
              }
              seq.push(converter(value));
            }
            return seq;
          };
        };
        webidl.recordConverter = function(keyConverter, valueConverter) {
          return (V) => {
            const record = {};
            const type = webidl.util.Type(V);
            if (type === "Undefined" || type === "Null") {
              return record;
            }
            if (type !== "Object") {
              webidl.errors.exception({
                header: "Record",
                message: `Expected ${V} to be an Object type.`
              });
            }
            for (let [key, value] of Object.entries(V)) {
              key = keyConverter(key);
              value = valueConverter(value);
              record[key] = value;
            }
            return record;
          };
        };
        webidl.interfaceConverter = function(i) {
          return (V, opts = {}) => {
            if (opts.strict !== false && !(V instanceof i)) {
              webidl.errors.exception({
                header: i.name,
                message: `Expected ${V} to be an instance of ${i.name}.`
              });
            }
            return V;
          };
        };
        webidl.dictionaryConverter = function(converters) {
          return (dictionary) => {
            const type = webidl.util.Type(dictionary);
            const dict = {};
            if (type !== "Null" && type !== "Undefined" && type !== "Object") {
              webidl.errors.exception({
                header: "Dictionary",
                message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
              });
            }
            for (const options of converters) {
              const { key, defaultValue, required, converter } = options;
              if (required === true) {
                if (!hasOwn(dictionary, key)) {
                  webidl.errors.exception({
                    header: "Dictionary",
                    message: `Missing required key "${key}".`
                  });
                }
              }
              let value = dictionary[key];
              const hasDefault = hasOwn(options, "defaultValue");
              if (hasDefault && value !== null) {
                value = value != null ? value : defaultValue;
              }
              if (required || hasDefault || value !== void 0) {
                value = converter(value);
                if (options.allowedValues && !options.allowedValues.includes(value)) {
                  webidl.errors.exception({
                    header: "Dictionary",
                    message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
                  });
                }
                dict[key] = value;
              }
            }
            return dict;
          };
        };
        webidl.nullableConverter = function(converter) {
          return (V) => {
            if (V === null) {
              return V;
            }
            return converter(V);
          };
        };
        webidl.converters.DOMString = function(V, opts = {}) {
          if (V === null && opts.legacyNullToEmptyString) {
            return "";
          }
          if (typeof V === "symbol") {
            throw new TypeError("Could not convert argument of type symbol to string.");
          }
          return String(V);
        };
        webidl.converters.ByteString = function(V) {
          const x = webidl.converters.DOMString(V);
          for (let index = 0; index < x.length; index++) {
            const charCode = x.charCodeAt(index);
            if (charCode > 255) {
              throw new TypeError(
                `Cannot convert argument to a ByteString because the character atindex ${index} has a value of ${charCode} which is greater than 255.`
              );
            }
          }
          return x;
        };
        webidl.converters.USVString = toUSVString;
        webidl.converters.boolean = function(V) {
          const x = Boolean(V);
          return x;
        };
        webidl.converters.any = function(V) {
          return V;
        };
        webidl.converters["long long"] = function(V, opts) {
          const x = webidl.util.ConvertToInt(V, 64, "signed", opts);
          return x;
        };
        webidl.converters["unsigned short"] = function(V) {
          const x = webidl.util.ConvertToInt(V, 16, "unsigned");
          return x;
        };
        webidl.converters.ArrayBuffer = function(V, opts = {}) {
          if (webidl.util.Type(V) !== "Object" || !types2.isAnyArrayBuffer(V)) {
            webidl.errors.conversionFailed({
              prefix: `${V}`,
              argument: `${V}`,
              types: ["ArrayBuffer"]
            });
          }
          if (opts.allowShared === false && types2.isSharedArrayBuffer(V)) {
            webidl.errors.exception({
              header: "ArrayBuffer",
              message: "SharedArrayBuffer is not allowed."
            });
          }
          return V;
        };
        webidl.converters.TypedArray = function(V, T, opts = {}) {
          if (webidl.util.Type(V) !== "Object" || !types2.isTypedArray(V) || V.constructor.name !== T.name) {
            webidl.errors.conversionFailed({
              prefix: `${T.name}`,
              argument: `${V}`,
              types: [T.name]
            });
          }
          if (opts.allowShared === false && types2.isSharedArrayBuffer(V.buffer)) {
            webidl.errors.exception({
              header: "ArrayBuffer",
              message: "SharedArrayBuffer is not allowed."
            });
          }
          return V;
        };
        webidl.converters.DataView = function(V, opts = {}) {
          if (webidl.util.Type(V) !== "Object" || !types2.isDataView(V)) {
            webidl.errors.exception({
              header: "DataView",
              message: "Object is not a DataView."
            });
          }
          if (opts.allowShared === false && types2.isSharedArrayBuffer(V.buffer)) {
            webidl.errors.exception({
              header: "ArrayBuffer",
              message: "SharedArrayBuffer is not allowed."
            });
          }
          return V;
        };
        webidl.converters.BufferSource = function(V, opts = {}) {
          if (types2.isAnyArrayBuffer(V)) {
            return webidl.converters.ArrayBuffer(V, opts);
          }
          if (types2.isTypedArray(V)) {
            return webidl.converters.TypedArray(V, V.constructor);
          }
          if (types2.isDataView(V)) {
            return webidl.converters.DataView(V, opts);
          }
          throw new TypeError(`Could not convert ${V} to a BufferSource.`);
        };
        webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
          webidl.converters.ByteString
        );
        webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
          webidl.converters["sequence<ByteString>"]
        );
        webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
          webidl.converters.ByteString,
          webidl.converters.ByteString
        );
        module2.exports = {
          webidl
        };
      }
    });
    var require_file = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/file.js"(exports2, module2) {
        "use strict";
        var { Blob: Blob2 } = require("buffer");
        var { types: types2 } = require("util");
        var { kState } = require_symbols2();
        var { isBlobLike } = require_util3();
        var { webidl } = require_webidl();
        var File = class extends Blob2 {
          constructor(fileBits, fileName, options = {}) {
            if (arguments.length < 2) {
              throw new TypeError("2 arguments required");
            }
            fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
            fileName = webidl.converters.USVString(fileName);
            options = webidl.converters.FilePropertyBag(options);
            const n = fileName;
            const d = options.lastModified;
            super(processBlobParts(fileBits, options), { type: options.type });
            this[kState] = {
              name: n,
              lastModified: d
            };
          }
          get name() {
            if (!(this instanceof File)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].name;
          }
          get lastModified() {
            if (!(this instanceof File)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].lastModified;
          }
          get [Symbol.toStringTag]() {
            return this.constructor.name;
          }
        };
        __name(File, "File");
        var FileLike = class {
          constructor(blobLike, fileName, options = {}) {
            var _a32;
            const n = fileName;
            const t = options.type;
            const d = (_a32 = options.lastModified) != null ? _a32 : Date.now();
            this[kState] = {
              blobLike,
              name: n,
              type: t,
              lastModified: d
            };
          }
          stream(...args) {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.stream(...args);
          }
          arrayBuffer(...args) {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.arrayBuffer(...args);
          }
          slice(...args) {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.slice(...args);
          }
          text(...args) {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.text(...args);
          }
          get size() {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.size;
          }
          get type() {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.type;
          }
          get name() {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].name;
          }
          get lastModified() {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].lastModified;
          }
          get [Symbol.toStringTag]() {
            return "File";
          }
        };
        __name(FileLike, "FileLike");
        webidl.converters.Blob = webidl.interfaceConverter(Blob2);
        webidl.converters.BlobPart = function(V, opts) {
          if (webidl.util.Type(V) === "Object") {
            if (isBlobLike(V)) {
              return webidl.converters.Blob(V, { strict: false });
            }
            return webidl.converters.BufferSource(V, opts);
          } else {
            return webidl.converters.USVString(V, opts);
          }
        };
        webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
          webidl.converters.BlobPart
        );
        webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
          {
            key: "lastModified",
            converter: webidl.converters["long long"],
            get defaultValue() {
              return Date.now();
            }
          },
          {
            key: "type",
            converter: webidl.converters.DOMString,
            defaultValue: ""
          },
          {
            key: "endings",
            converter: (value) => {
              value = webidl.converters.DOMString(value);
              value = value.toLowerCase();
              if (value !== "native") {
                value = "transparent";
              }
              return value;
            },
            defaultValue: "transparent"
          }
        ]);
        function processBlobParts(parts, options) {
          const bytes = [];
          for (const element of parts) {
            if (typeof element === "string") {
              let s = element;
              if (options.endings === "native") {
                s = convertLineEndingsNative(s);
              }
              bytes.push(new TextEncoder().encode(s));
            } else if (types2.isAnyArrayBuffer(element) || types2.isTypedArray(element)) {
              if (!element.buffer) {
                bytes.push(new Uint8Array(element));
              } else {
                bytes.push(
                  new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
                );
              }
            } else if (isBlobLike(element)) {
              bytes.push(element);
            }
          }
          return bytes;
        }
        __name(processBlobParts, "processBlobParts");
        function convertLineEndingsNative(s) {
          let nativeLineEnding = "\n";
          if (process.platform === "win32") {
            nativeLineEnding = "\r\n";
          }
          return s.replace(/\r?\n/g, nativeLineEnding);
        }
        __name(convertLineEndingsNative, "convertLineEndingsNative");
        function isFileLike(object) {
          return object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
        }
        __name(isFileLike, "isFileLike");
        module2.exports = { File, FileLike, isFileLike };
      }
    });
    var require_formdata = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
        "use strict";
        var { isBlobLike, toUSVString, makeIterator } = require_util3();
        var { kState } = require_symbols2();
        var { File, FileLike, isFileLike } = require_file();
        var { webidl } = require_webidl();
        var { Blob: Blob2 } = require("buffer");
        var _FormData = class {
          constructor(form) {
            if (arguments.length > 0 && form != null) {
              webidl.errors.conversionFailed({
                prefix: "FormData constructor",
                argument: "Argument 1",
                types: ["null"]
              });
            }
            this[kState] = [];
          }
          append(name, value, filename = void 0) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 2) {
              throw new TypeError(
                `Failed to execute 'append' on 'FormData': 2 arguments required, but only ${arguments.length} present.`
              );
            }
            if (arguments.length === 3 && !isBlobLike(value)) {
              throw new TypeError(
                "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
              );
            }
            name = webidl.converters.USVString(name);
            value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
            filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
            const entry = makeEntry(name, value, filename);
            this[kState].push(entry);
          }
          delete(name) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
              );
            }
            name = webidl.converters.USVString(name);
            const next = [];
            for (const entry of this[kState]) {
              if (entry.name !== name) {
                next.push(entry);
              }
            }
            this[kState] = next;
          }
          get(name) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to execute 'get' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
              );
            }
            name = webidl.converters.USVString(name);
            const idx = this[kState].findIndex((entry) => entry.name === name);
            if (idx === -1) {
              return null;
            }
            return this[kState][idx].value;
          }
          getAll(name) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
              );
            }
            name = webidl.converters.USVString(name);
            return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
          }
          has(name) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to execute 'has' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
              );
            }
            name = webidl.converters.USVString(name);
            return this[kState].findIndex((entry) => entry.name === name) !== -1;
          }
          set(name, value, filename = void 0) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 2) {
              throw new TypeError(
                `Failed to execute 'set' on 'FormData': 2 arguments required, but only ${arguments.length} present.`
              );
            }
            if (arguments.length === 3 && !isBlobLike(value)) {
              throw new TypeError(
                "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
              );
            }
            name = webidl.converters.USVString(name);
            value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
            filename = arguments.length === 3 ? toUSVString(filename) : void 0;
            const entry = makeEntry(name, value, filename);
            const idx = this[kState].findIndex((entry2) => entry2.name === name);
            if (idx !== -1) {
              this[kState] = [
                ...this[kState].slice(0, idx),
                entry,
                ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
              ];
            } else {
              this[kState].push(entry);
            }
          }
          get [Symbol.toStringTag]() {
            return this.constructor.name;
          }
          entries() {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(
              makeIterable(this[kState], "entries"),
              "FormData"
            );
          }
          keys() {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(
              makeIterable(this[kState], "keys"),
              "FormData"
            );
          }
          values() {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(
              makeIterable(this[kState], "values"),
              "FormData"
            );
          }
          forEach(callbackFn, thisArg = globalThis) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to execute 'forEach' on 'FormData': 1 argument required, but only ${arguments.length} present.`
              );
            }
            if (typeof callbackFn !== "function") {
              throw new TypeError(
                "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
              );
            }
            for (const [key, value] of this) {
              callbackFn.apply(thisArg, [value, key, this]);
            }
          }
        };
        var FormData4 = _FormData;
        __name(FormData4, "FormData");
        __publicField(FormData4, "name", "FormData");
        FormData4.prototype[Symbol.iterator] = FormData4.prototype.entries;
        function makeEntry(name, value, filename) {
          name = Buffer.from(name).toString("utf8");
          if (typeof value === "string") {
            value = Buffer.from(value).toString("utf8");
          } else {
            if (!isFileLike(value)) {
              value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
            }
            if (filename !== void 0) {
              value = value instanceof File ? new File([value], filename, { type: value.type }) : new FileLike(value, filename, { type: value.type });
            }
          }
          return { name, value };
        }
        __name(makeEntry, "makeEntry");
        function* makeIterable(entries2, type) {
          for (const { name, value } of entries2) {
            if (type === "entries") {
              yield [name, value];
            } else if (type === "values") {
              yield value;
            } else {
              yield name;
            }
          }
        }
        __name(makeIterable, "makeIterable");
        module2.exports = { FormData: FormData4 };
      }
    });
    var require_body = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/body.js"(exports2, module2) {
        "use strict";
        var Busboy = require_lib();
        var util2 = require_util2();
        var { ReadableStreamFrom, toUSVString, isBlobLike } = require_util3();
        var { FormData: FormData4 } = require_formdata();
        var { kState } = require_symbols2();
        var { webidl } = require_webidl();
        var { DOMException } = require_constants();
        var { Blob: Blob2 } = require("buffer");
        var { kBodyUsed } = require_symbols();
        var assert2 = require("assert");
        var { isErrored } = require_util2();
        var { isUint8Array, isArrayBuffer: isArrayBuffer2 } = require("util/types");
        var { File } = require_file();
        var ReadableStream2;
        async function* blobGen(blob) {
          yield* blob.stream();
        }
        __name(blobGen, "blobGen");
        function extractBody(object, keepalive = false) {
          if (!ReadableStream2) {
            ReadableStream2 = require("stream/web").ReadableStream;
          }
          let stream22 = null;
          let action = null;
          let source = null;
          let length = null;
          let contentType = null;
          if (object == null) {
          } else if (object instanceof URLSearchParams) {
            source = object.toString();
            contentType = "application/x-www-form-urlencoded;charset=UTF-8";
          } else if (isArrayBuffer2(object)) {
            source = new Uint8Array(object.slice());
          } else if (ArrayBuffer.isView(object)) {
            source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
          } else if (util2.isFormDataLike(object)) {
            const boundary = "----formdata-undici-" + Math.random();
            const prefix = `--${boundary}\r
Content-Disposition: form-data`;
            const escape = /* @__PURE__ */ __name((str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "escape");
            const normalizeLinefeeds = /* @__PURE__ */ __name((value) => value.replace(/\r?\n|\r/g, "\r\n"), "normalizeLinefeeds");
            action = /* @__PURE__ */ __name(async function* (object2) {
              const enc = new TextEncoder();
              for (const [name, value] of object2) {
                if (typeof value === "string") {
                  yield enc.encode(
                    prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`
                  );
                } else {
                  yield enc.encode(
                    prefix + `; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`
                  );
                  yield* blobGen(value);
                  yield enc.encode("\r\n");
                }
              }
              yield enc.encode(`--${boundary}--`);
            }, "action");
            source = object;
            contentType = "multipart/form-data; boundary=" + boundary;
          } else if (isBlobLike(object)) {
            action = blobGen;
            source = object;
            length = object.size;
            if (object.type) {
              contentType = object.type;
            }
          } else if (typeof object[Symbol.asyncIterator] === "function") {
            if (keepalive) {
              throw new TypeError("keepalive");
            }
            if (util2.isDisturbed(object) || object.locked) {
              throw new TypeError(
                "Response body object should not be disturbed or locked"
              );
            }
            stream22 = object instanceof ReadableStream2 ? object : ReadableStreamFrom(object);
          } else {
            source = toUSVString(object);
            contentType = "text/plain;charset=UTF-8";
          }
          if (typeof source === "string" || util2.isBuffer(source)) {
            length = Buffer.byteLength(source);
          }
          if (action != null) {
            let iterator;
            stream22 = new ReadableStream2({
              async start() {
                iterator = action(object)[Symbol.asyncIterator]();
              },
              async pull(controller) {
                const { value, done } = await iterator.next();
                if (done) {
                  queueMicrotask(() => {
                    controller.close();
                  });
                } else {
                  if (!isErrored(stream22)) {
                    controller.enqueue(new Uint8Array(value));
                  }
                }
                return controller.desiredSize > 0;
              },
              async cancel(reason) {
                await iterator.return();
              }
            });
          } else if (!stream22) {
            stream22 = new ReadableStream2({
              async pull(controller) {
                controller.enqueue(
                  typeof source === "string" ? new TextEncoder().encode(source) : source
                );
                queueMicrotask(() => {
                  controller.close();
                });
              }
            });
          }
          const body = { stream: stream22, source, length };
          return [body, contentType];
        }
        __name(extractBody, "extractBody");
        function safelyExtractBody(object, keepalive = false) {
          if (!ReadableStream2) {
            ReadableStream2 = require("stream/web").ReadableStream;
          }
          if (object instanceof ReadableStream2) {
            assert2(!util2.isDisturbed(object), "The body has already been consumed.");
            assert2(!object.locked, "The stream is locked.");
          }
          return extractBody(object, keepalive);
        }
        __name(safelyExtractBody, "safelyExtractBody");
        function cloneBody(body) {
          const [out1, out2] = body.stream.tee();
          body.stream = out1;
          return {
            stream: out2,
            length: body.length,
            source: body.source
          };
        }
        __name(cloneBody, "cloneBody");
        async function* consumeBody(body) {
          if (body) {
            if (isUint8Array(body)) {
              yield body;
            } else {
              const stream22 = body.stream;
              if (util2.isDisturbed(stream22)) {
                throw new TypeError("The body has already been consumed.");
              }
              if (stream22.locked) {
                throw new TypeError("The stream is locked.");
              }
              stream22[kBodyUsed] = true;
              yield* stream22;
            }
          }
        }
        __name(consumeBody, "consumeBody");
        function throwIfAborted(state) {
          if (state.aborted) {
            throw new DOMException("The operation was aborted.", "AbortError");
          }
        }
        __name(throwIfAborted, "throwIfAborted");
        function bodyMixinMethods(instance) {
          const methods = {
            async blob() {
              if (!(this instanceof instance)) {
                throw new TypeError("Illegal invocation");
              }
              throwIfAborted(this[kState]);
              const chunks = [];
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                chunks.push(new Blob2([chunk]));
              }
              return new Blob2(chunks, { type: this.headers.get("Content-Type") || "" });
            },
            async arrayBuffer() {
              if (!(this instanceof instance)) {
                throw new TypeError("Illegal invocation");
              }
              throwIfAborted(this[kState]);
              const contentLength = this.headers.get("content-length");
              const encoded = this.headers.has("content-encoding");
              if (!encoded && contentLength) {
                const buffer2 = new Uint8Array(contentLength);
                let offset2 = 0;
                for await (const chunk of consumeBody(this[kState].body)) {
                  if (!isUint8Array(chunk)) {
                    throw new TypeError("Expected Uint8Array chunk");
                  }
                  buffer2.set(chunk, offset2);
                  offset2 += chunk.length;
                }
                return buffer2.buffer;
              }
              const chunks = [];
              let size = 0;
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                chunks.push(chunk);
                size += chunk.byteLength;
              }
              const buffer = new Uint8Array(size);
              let offset = 0;
              for (const chunk of chunks) {
                buffer.set(chunk, offset);
                offset += chunk.byteLength;
              }
              return buffer.buffer;
            },
            async text() {
              if (!(this instanceof instance)) {
                throw new TypeError("Illegal invocation");
              }
              throwIfAborted(this[kState]);
              let result = "";
              const textDecoder = new TextDecoder();
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                result += textDecoder.decode(chunk, { stream: true });
              }
              result += textDecoder.decode();
              return result;
            },
            async json() {
              if (!(this instanceof instance)) {
                throw new TypeError("Illegal invocation");
              }
              throwIfAborted(this[kState]);
              return JSON.parse(await this.text());
            },
            async formData() {
              if (!(this instanceof instance)) {
                throw new TypeError("Illegal invocation");
              }
              throwIfAborted(this[kState]);
              const contentType = this.headers.get("Content-Type");
              if (/multipart\/form-data/.test(contentType)) {
                const headers = {};
                for (const [key, value] of this.headers)
                  headers[key.toLowerCase()] = value;
                const responseFormData = new FormData4();
                let busboy;
                try {
                  busboy = Busboy({ headers });
                } catch (err) {
                  throw Object.assign(new TypeError(), { cause: err });
                }
                busboy.on("field", (name, value) => {
                  responseFormData.append(name, value);
                });
                busboy.on("file", (name, value, info2) => {
                  const { filename, encoding, mimeType } = info2;
                  const chunks = [];
                  if (encoding.toLowerCase() === "base64") {
                    let base64chunk = "";
                    value.on("data", (chunk) => {
                      base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                      const end = base64chunk.length - base64chunk.length % 4;
                      chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                      base64chunk = base64chunk.slice(end);
                    });
                    value.on("end", () => {
                      chunks.push(Buffer.from(base64chunk, "base64"));
                      responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                    });
                  } else {
                    value.on("data", (chunk) => {
                      chunks.push(chunk);
                    });
                    value.on("end", () => {
                      responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                    });
                  }
                });
                const busboyResolve = new Promise((resolve, reject) => {
                  busboy.on("finish", resolve);
                  busboy.on("error", (err) => reject(err));
                });
                if (this.body !== null)
                  for await (const chunk of consumeBody(this[kState].body))
                    busboy.write(chunk);
                busboy.end();
                await busboyResolve;
                return responseFormData;
              } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
                let entries2;
                try {
                  let text = "";
                  const textDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
                  for await (const chunk of consumeBody(this[kState].body)) {
                    if (!isUint8Array(chunk)) {
                      throw new TypeError("Expected Uint8Array chunk");
                    }
                    text += textDecoder.decode(chunk, { stream: true });
                  }
                  text += textDecoder.decode();
                  entries2 = new URLSearchParams(text);
                } catch (err) {
                  throw Object.assign(new TypeError(), { cause: err });
                }
                const formData = new FormData4();
                for (const [name, value] of entries2) {
                  formData.append(name, value);
                }
                return formData;
              } else {
                await Promise.resolve();
                throwIfAborted(this[kState]);
                webidl.errors.exception({
                  header: `${instance.name}.formData`,
                  message: "Could not parse content as FormData."
                });
              }
            }
          };
          return methods;
        }
        __name(bodyMixinMethods, "bodyMixinMethods");
        var properties = {
          body: {
            enumerable: true,
            get() {
              if (!this || !this[kState]) {
                throw new TypeError("Illegal invocation");
              }
              return this[kState].body ? this[kState].body.stream : null;
            }
          },
          bodyUsed: {
            enumerable: true,
            get() {
              if (!this || !this[kState]) {
                throw new TypeError("Illegal invocation");
              }
              return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);
            }
          }
        };
        function mixinBody(prototype3) {
          Object.assign(prototype3.prototype, bodyMixinMethods(prototype3));
          Object.defineProperties(prototype3.prototype, properties);
        }
        __name(mixinBody, "mixinBody");
        module2.exports = {
          extractBody,
          safelyExtractBody,
          cloneBody,
          mixinBody
        };
      }
    });
    var require_request = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/core/request.js"(exports2, module2) {
        "use strict";
        var {
          InvalidArgumentError,
          NotSupportedError
        } = require_errors();
        var assert2 = require("assert");
        var util2 = require_util2();
        var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
        var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
        var invalidPathRegex = /[^\u0021-\u00ff]/;
        var kHandler = Symbol("handler");
        var channels = {};
        var extractBody;
        var nodeVersion = process.versions.node.split(".");
        var nodeMajor = Number(nodeVersion[0]);
        var nodeMinor = Number(nodeVersion[1]);
        try {
          const diagnosticsChannel = require("diagnostics_channel");
          channels.create = diagnosticsChannel.channel("undici:request:create");
          channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
          channels.headers = diagnosticsChannel.channel("undici:request:headers");
          channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
          channels.error = diagnosticsChannel.channel("undici:request:error");
        } catch (e) {
          channels.create = { hasSubscribers: false };
          channels.bodySent = { hasSubscribers: false };
          channels.headers = { hasSubscribers: false };
          channels.trailers = { hasSubscribers: false };
          channels.error = { hasSubscribers: false };
        }
        var Request2 = class {
          constructor(origin, {
            path: path7,
            method,
            body,
            headers,
            query: query2,
            idempotent,
            blocking,
            upgrade,
            headersTimeout,
            bodyTimeout,
            throwOnError
          }, handler) {
            if (typeof path7 !== "string") {
              throw new InvalidArgumentError("path must be a string");
            } else if (path7[0] !== "/" && !(path7.startsWith("http://") || path7.startsWith("https://")) && method !== "CONNECT") {
              throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
            } else if (invalidPathRegex.exec(path7) !== null) {
              throw new InvalidArgumentError("invalid request path");
            }
            if (typeof method !== "string") {
              throw new InvalidArgumentError("method must be a string");
            } else if (tokenRegExp.exec(method) === null) {
              throw new InvalidArgumentError("invalid request method");
            }
            if (upgrade && typeof upgrade !== "string") {
              throw new InvalidArgumentError("upgrade must be a string");
            }
            if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
              throw new InvalidArgumentError("invalid headersTimeout");
            }
            if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
              throw new InvalidArgumentError("invalid bodyTimeout");
            }
            this.headersTimeout = headersTimeout;
            this.bodyTimeout = bodyTimeout;
            this.throwOnError = throwOnError === true;
            this.method = method;
            if (body == null) {
              this.body = null;
            } else if (util2.isStream(body)) {
              this.body = body;
            } else if (util2.isBuffer(body)) {
              this.body = body.byteLength ? body : null;
            } else if (ArrayBuffer.isView(body)) {
              this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
            } else if (body instanceof ArrayBuffer) {
              this.body = body.byteLength ? Buffer.from(body) : null;
            } else if (typeof body === "string") {
              this.body = body.length ? Buffer.from(body) : null;
            } else if (util2.isFormDataLike(body) || util2.isIterable(body) || util2.isBlobLike(body)) {
              this.body = body;
            } else {
              throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
            }
            this.completed = false;
            this.aborted = false;
            this.upgrade = upgrade || null;
            this.path = query2 ? util2.buildURL(path7, query2) : path7;
            this.origin = origin;
            this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
            this.blocking = blocking == null ? false : blocking;
            this.host = null;
            this.contentLength = null;
            this.contentType = null;
            this.headers = "";
            if (Array.isArray(headers)) {
              if (headers.length % 2 !== 0) {
                throw new InvalidArgumentError("headers array must be even");
              }
              for (let i = 0; i < headers.length; i += 2) {
                processHeader(this, headers[i], headers[i + 1]);
              }
            } else if (headers && typeof headers === "object") {
              const keys2 = Object.keys(headers);
              for (let i = 0; i < keys2.length; i++) {
                const key = keys2[i];
                processHeader(this, key, headers[key]);
              }
            } else if (headers != null) {
              throw new InvalidArgumentError("headers must be an object or an array");
            }
            if (util2.isFormDataLike(this.body)) {
              if (nodeMajor < 16 || nodeMajor === 16 && nodeMinor < 8) {
                throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
              }
              if (!extractBody) {
                extractBody = require_body().extractBody;
              }
              const [bodyStream, contentType] = extractBody(body);
              if (this.contentType == null) {
                this.contentType = contentType;
                this.headers += `content-type: ${contentType}\r
`;
              }
              this.body = bodyStream.stream;
            } else if (util2.isBlobLike(body) && this.contentType == null && body.type) {
              this.contentType = body.type;
              this.headers += `content-type: ${body.type}\r
`;
            }
            util2.validateHandler(handler, method, upgrade);
            this.servername = util2.getServerName(this.host);
            this[kHandler] = handler;
            if (channels.create.hasSubscribers) {
              channels.create.publish({ request: this });
            }
          }
          onBodySent(chunk) {
            if (this[kHandler].onBodySent) {
              try {
                this[kHandler].onBodySent(chunk);
              } catch (err) {
                this.onError(err);
              }
            }
          }
          onRequestSent() {
            if (channels.bodySent.hasSubscribers) {
              channels.bodySent.publish({ request: this });
            }
          }
          onConnect(abort) {
            assert2(!this.aborted);
            assert2(!this.completed);
            return this[kHandler].onConnect(abort);
          }
          onHeaders(statusCode, headers, resume, statusText) {
            assert2(!this.aborted);
            assert2(!this.completed);
            if (channels.headers.hasSubscribers) {
              channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
            }
            return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
          }
          onData(chunk) {
            assert2(!this.aborted);
            assert2(!this.completed);
            return this[kHandler].onData(chunk);
          }
          onUpgrade(statusCode, headers, socket) {
            assert2(!this.aborted);
            assert2(!this.completed);
            return this[kHandler].onUpgrade(statusCode, headers, socket);
          }
          onComplete(trailers) {
            assert2(!this.aborted);
            this.completed = true;
            if (channels.trailers.hasSubscribers) {
              channels.trailers.publish({ request: this, trailers });
            }
            return this[kHandler].onComplete(trailers);
          }
          onError(error2) {
            if (channels.error.hasSubscribers) {
              channels.error.publish({ request: this, error: error2 });
            }
            if (this.aborted) {
              return;
            }
            this.aborted = true;
            return this[kHandler].onError(error2);
          }
          addHeader(key, value) {
            processHeader(this, key, value);
            return this;
          }
        };
        __name(Request2, "Request");
        function processHeader(request2, key, val) {
          if (val && typeof val === "object") {
            throw new InvalidArgumentError(`invalid ${key} header`);
          } else if (val === void 0) {
            return;
          }
          if (request2.host === null && key.length === 4 && key.toLowerCase() === "host") {
            request2.host = val;
          } else if (request2.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
            request2.contentLength = parseInt(val, 10);
            if (!Number.isFinite(request2.contentLength)) {
              throw new InvalidArgumentError("invalid content-length header");
            }
          } else if (request2.contentType === null && key.length === 12 && key.toLowerCase() === "content-type" && headerCharRegex.exec(val) === null) {
            request2.contentType = val;
            request2.headers += `${key}: ${val}\r
`;
          } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
            throw new InvalidArgumentError("invalid transfer-encoding header");
          } else if (key.length === 10 && key.toLowerCase() === "connection") {
            throw new InvalidArgumentError("invalid connection header");
          } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
            throw new InvalidArgumentError("invalid keep-alive header");
          } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
            throw new InvalidArgumentError("invalid upgrade header");
          } else if (key.length === 6 && key.toLowerCase() === "expect") {
            throw new NotSupportedError("expect header not supported");
          } else if (tokenRegExp.exec(key) === null) {
            throw new InvalidArgumentError("invalid header key");
          } else if (headerCharRegex.exec(val) !== null) {
            throw new InvalidArgumentError(`invalid ${key} header`);
          } else {
            request2.headers += `${key}: ${val}\r
`;
          }
        }
        __name(processHeader, "processHeader");
        module2.exports = Request2;
      }
    });
    var require_dispatcher = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/dispatcher.js"(exports2, module2) {
        "use strict";
        var EventEmitter32 = require("events");
        var Dispatcher = class extends EventEmitter32 {
          dispatch() {
            throw new Error("not implemented");
          }
          close() {
            throw new Error("not implemented");
          }
          destroy() {
            throw new Error("not implemented");
          }
        };
        __name(Dispatcher, "Dispatcher");
        module2.exports = Dispatcher;
      }
    });
    var require_dispatcher_base = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
        "use strict";
        var Dispatcher = require_dispatcher();
        var {
          ClientDestroyedError,
          ClientClosedError,
          InvalidArgumentError
        } = require_errors();
        var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
        var kDestroyed = Symbol("destroyed");
        var kClosed = Symbol("closed");
        var kOnDestroyed = Symbol("onDestroyed");
        var kOnClosed = Symbol("onClosed");
        var kInterceptedDispatch = Symbol("Intercepted Dispatch");
        var DispatcherBase = class extends Dispatcher {
          constructor() {
            super();
            this[kDestroyed] = false;
            this[kOnDestroyed] = [];
            this[kClosed] = false;
            this[kOnClosed] = [];
          }
          get destroyed() {
            return this[kDestroyed];
          }
          get closed() {
            return this[kClosed];
          }
          get interceptors() {
            return this[kInterceptors];
          }
          set interceptors(newInterceptors) {
            if (newInterceptors) {
              for (let i = newInterceptors.length - 1; i >= 0; i--) {
                const interceptor = this[kInterceptors][i];
                if (typeof interceptor !== "function") {
                  throw new InvalidArgumentError("interceptor must be an function");
                }
              }
            }
            this[kInterceptors] = newInterceptors;
          }
          close(callback) {
            if (callback === void 0) {
              return new Promise((resolve, reject) => {
                this.close((err, data) => {
                  return err ? reject(err) : resolve(data);
                });
              });
            }
            if (typeof callback !== "function") {
              throw new InvalidArgumentError("invalid callback");
            }
            if (this[kDestroyed]) {
              queueMicrotask(() => callback(new ClientDestroyedError(), null));
              return;
            }
            if (this[kClosed]) {
              if (this[kOnClosed]) {
                this[kOnClosed].push(callback);
              } else {
                queueMicrotask(() => callback(null, null));
              }
              return;
            }
            this[kClosed] = true;
            this[kOnClosed].push(callback);
            const onClosed = /* @__PURE__ */ __name(() => {
              const callbacks = this[kOnClosed];
              this[kOnClosed] = null;
              for (let i = 0; i < callbacks.length; i++) {
                callbacks[i](null, null);
              }
            }, "onClosed");
            this[kClose]().then(() => this.destroy()).then(() => {
              queueMicrotask(onClosed);
            });
          }
          destroy(err, callback) {
            if (typeof err === "function") {
              callback = err;
              err = null;
            }
            if (callback === void 0) {
              return new Promise((resolve, reject) => {
                this.destroy(err, (err2, data) => {
                  return err2 ? reject(err2) : resolve(data);
                });
              });
            }
            if (typeof callback !== "function") {
              throw new InvalidArgumentError("invalid callback");
            }
            if (this[kDestroyed]) {
              if (this[kOnDestroyed]) {
                this[kOnDestroyed].push(callback);
              } else {
                queueMicrotask(() => callback(null, null));
              }
              return;
            }
            if (!err) {
              err = new ClientDestroyedError();
            }
            this[kDestroyed] = true;
            this[kOnDestroyed].push(callback);
            const onDestroyed = /* @__PURE__ */ __name(() => {
              const callbacks = this[kOnDestroyed];
              this[kOnDestroyed] = null;
              for (let i = 0; i < callbacks.length; i++) {
                callbacks[i](null, null);
              }
            }, "onDestroyed");
            this[kDestroy](err).then(() => {
              queueMicrotask(onDestroyed);
            });
          }
          [kInterceptedDispatch](opts, handler) {
            if (!this[kInterceptors] || this[kInterceptors].length === 0) {
              this[kInterceptedDispatch] = this[kDispatch];
              return this[kDispatch](opts, handler);
            }
            let dispatch = this[kDispatch].bind(this);
            for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
              dispatch = this[kInterceptors][i](dispatch);
            }
            this[kInterceptedDispatch] = dispatch;
            return dispatch(opts, handler);
          }
          dispatch(opts, handler) {
            if (!handler || typeof handler !== "object") {
              throw new InvalidArgumentError("handler must be an object");
            }
            try {
              if (!opts || typeof opts !== "object") {
                throw new InvalidArgumentError("opts must be an object.");
              }
              if (this[kDestroyed]) {
                throw new ClientDestroyedError();
              }
              if (this[kClosed]) {
                throw new ClientClosedError();
              }
              return this[kInterceptedDispatch](opts, handler);
            } catch (err) {
              if (typeof handler.onError !== "function") {
                throw new InvalidArgumentError("invalid onError method");
              }
              handler.onError(err);
              return false;
            }
          }
        };
        __name(DispatcherBase, "DispatcherBase");
        module2.exports = DispatcherBase;
      }
    });
    var require_connect = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/core/connect.js"(exports2, module2) {
        "use strict";
        var net2 = require("net");
        var assert2 = require("assert");
        var util2 = require_util2();
        var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
        var tls;
        function buildConnector({ maxCachedSessions, socketPath, timeout, ...opts }) {
          if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
            throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
          }
          const options = { path: socketPath, ...opts };
          const sessionCache = /* @__PURE__ */ new Map();
          timeout = timeout == null ? 1e4 : timeout;
          maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;
          return /* @__PURE__ */ __name(function connect({ hostname: hostname3, host, protocol, port, servername, httpSocket }, callback) {
            let socket;
            if (protocol === "https:") {
              if (!tls) {
                tls = require("tls");
              }
              servername = servername || options.servername || util2.getServerName(host) || null;
              const sessionKey = servername || hostname3;
              const session = sessionCache.get(sessionKey) || null;
              assert2(sessionKey);
              socket = tls.connect({
                highWaterMark: 16384,
                ...options,
                servername,
                session,
                socket: httpSocket,
                port: port || 443,
                host: hostname3
              });
              socket.on("session", function(session2) {
                if (maxCachedSessions === 0) {
                  return;
                }
                if (sessionCache.size >= maxCachedSessions) {
                  const { value: oldestKey } = sessionCache.keys().next();
                  sessionCache.delete(oldestKey);
                }
                sessionCache.set(sessionKey, session2);
              }).on("error", function(err) {
                if (sessionKey && err.code !== "UND_ERR_INFO") {
                  sessionCache.delete(sessionKey);
                }
              });
            } else {
              assert2(!httpSocket, "httpSocket can only be sent on TLS update");
              socket = net2.connect({
                highWaterMark: 64 * 1024,
                ...options,
                port: port || 80,
                host: hostname3
              });
            }
            const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
            socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
              cancelTimeout();
              if (callback) {
                const cb = callback;
                callback = null;
                cb(null, this);
              }
            }).on("error", function(err) {
              cancelTimeout();
              if (callback) {
                const cb = callback;
                callback = null;
                cb(err);
              }
            });
            return socket;
          }, "connect");
        }
        __name(buildConnector, "buildConnector");
        function setupTimeout(onConnectTimeout2, timeout) {
          if (!timeout) {
            return () => {
            };
          }
          let s1 = null;
          let s2 = null;
          const timeoutId = setTimeout(() => {
            s1 = setImmediate(() => {
              if (process.platform === "win32") {
                s2 = setImmediate(() => onConnectTimeout2());
              } else {
                onConnectTimeout2();
              }
            });
          }, timeout);
          return () => {
            clearTimeout(timeoutId);
            clearImmediate(s1);
            clearImmediate(s2);
          };
        }
        __name(setupTimeout, "setupTimeout");
        function onConnectTimeout(socket) {
          util2.destroy(socket, new ConnectTimeoutError());
        }
        __name(onConnectTimeout, "onConnectTimeout");
        module2.exports = buildConnector;
      }
    });
    var require_utils2 = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/llhttp/utils.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.enumToMap = void 0;
        function enumToMap(obj) {
          const res = {};
          Object.keys(obj).forEach((key) => {
            const value = obj[key];
            if (typeof value === "number") {
              res[key] = value;
            }
          });
          return res;
        }
        __name(enumToMap, "enumToMap");
        exports2.enumToMap = enumToMap;
      }
    });
    var require_constants2 = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/llhttp/constants.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
        var utils_1 = require_utils2();
        var ERROR;
        (function(ERROR2) {
          ERROR2[ERROR2["OK"] = 0] = "OK";
          ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
          ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
          ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
          ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
          ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
          ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
          ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
          ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
          ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
          ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
          ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
          ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
          ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
          ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
          ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
          ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
          ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
          ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
          ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
          ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
          ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
          ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
          ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
          ERROR2[ERROR2["USER"] = 24] = "USER";
        })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
        var TYPE;
        (function(TYPE2) {
          TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
          TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
          TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
        })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
        var FLAGS;
        (function(FLAGS2) {
          FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
          FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
          FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
          FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
          FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
          FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
          FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
          FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
          FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
        })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
        var LENIENT_FLAGS;
        (function(LENIENT_FLAGS2) {
          LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
          LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
          LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
        })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
        var METHODS;
        (function(METHODS2) {
          METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
          METHODS2[METHODS2["GET"] = 1] = "GET";
          METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
          METHODS2[METHODS2["POST"] = 3] = "POST";
          METHODS2[METHODS2["PUT"] = 4] = "PUT";
          METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
          METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
          METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
          METHODS2[METHODS2["COPY"] = 8] = "COPY";
          METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
          METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
          METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
          METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
          METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
          METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
          METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
          METHODS2[METHODS2["BIND"] = 16] = "BIND";
          METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
          METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
          METHODS2[METHODS2["ACL"] = 19] = "ACL";
          METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
          METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
          METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
          METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
          METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
          METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
          METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
          METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
          METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
          METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
          METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
          METHODS2[METHODS2["LINK"] = 31] = "LINK";
          METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
          METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
          METHODS2[METHODS2["PRI"] = 34] = "PRI";
          METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
          METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
          METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
          METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
          METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
          METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
          METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
          METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
          METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
          METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
          METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
        })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
        exports2.METHODS_HTTP = [
          METHODS.DELETE,
          METHODS.GET,
          METHODS.HEAD,
          METHODS.POST,
          METHODS.PUT,
          METHODS.CONNECT,
          METHODS.OPTIONS,
          METHODS.TRACE,
          METHODS.COPY,
          METHODS.LOCK,
          METHODS.MKCOL,
          METHODS.MOVE,
          METHODS.PROPFIND,
          METHODS.PROPPATCH,
          METHODS.SEARCH,
          METHODS.UNLOCK,
          METHODS.BIND,
          METHODS.REBIND,
          METHODS.UNBIND,
          METHODS.ACL,
          METHODS.REPORT,
          METHODS.MKACTIVITY,
          METHODS.CHECKOUT,
          METHODS.MERGE,
          METHODS["M-SEARCH"],
          METHODS.NOTIFY,
          METHODS.SUBSCRIBE,
          METHODS.UNSUBSCRIBE,
          METHODS.PATCH,
          METHODS.PURGE,
          METHODS.MKCALENDAR,
          METHODS.LINK,
          METHODS.UNLINK,
          METHODS.PRI,
          METHODS.SOURCE
        ];
        exports2.METHODS_ICE = [
          METHODS.SOURCE
        ];
        exports2.METHODS_RTSP = [
          METHODS.OPTIONS,
          METHODS.DESCRIBE,
          METHODS.ANNOUNCE,
          METHODS.SETUP,
          METHODS.PLAY,
          METHODS.PAUSE,
          METHODS.TEARDOWN,
          METHODS.GET_PARAMETER,
          METHODS.SET_PARAMETER,
          METHODS.REDIRECT,
          METHODS.RECORD,
          METHODS.FLUSH,
          METHODS.GET,
          METHODS.POST
        ];
        exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
        exports2.H_METHOD_MAP = {};
        Object.keys(exports2.METHOD_MAP).forEach((key) => {
          if (/^H/.test(key)) {
            exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
          }
        });
        var FINISH;
        (function(FINISH2) {
          FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
          FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
          FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
        })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
        exports2.ALPHA = [];
        for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
          exports2.ALPHA.push(String.fromCharCode(i));
          exports2.ALPHA.push(String.fromCharCode(i + 32));
        }
        exports2.NUM_MAP = {
          0: 0,
          1: 1,
          2: 2,
          3: 3,
          4: 4,
          5: 5,
          6: 6,
          7: 7,
          8: 8,
          9: 9
        };
        exports2.HEX_MAP = {
          0: 0,
          1: 1,
          2: 2,
          3: 3,
          4: 4,
          5: 5,
          6: 6,
          7: 7,
          8: 8,
          9: 9,
          A: 10,
          B: 11,
          C: 12,
          D: 13,
          E: 14,
          F: 15,
          a: 10,
          b: 11,
          c: 12,
          d: 13,
          e: 14,
          f: 15
        };
        exports2.NUM = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9"
        ];
        exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
        exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
        exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
        exports2.STRICT_URL_CHAR = [
          "!",
          '"',
          "$",
          "%",
          "&",
          "'",
          "(",
          ")",
          "*",
          "+",
          ",",
          "-",
          ".",
          "/",
          ":",
          ";",
          "<",
          "=",
          ">",
          "@",
          "[",
          "\\",
          "]",
          "^",
          "_",
          "`",
          "{",
          "|",
          "}",
          "~"
        ].concat(exports2.ALPHANUM);
        exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
        for (let i = 128; i <= 255; i++) {
          exports2.URL_CHAR.push(i);
        }
        exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
        exports2.STRICT_TOKEN = [
          "!",
          "#",
          "$",
          "%",
          "&",
          "'",
          "*",
          "+",
          "-",
          ".",
          "^",
          "_",
          "`",
          "|",
          "~"
        ].concat(exports2.ALPHANUM);
        exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
        exports2.HEADER_CHARS = ["	"];
        for (let i = 32; i <= 255; i++) {
          if (i !== 127) {
            exports2.HEADER_CHARS.push(i);
          }
        }
        exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
        exports2.MAJOR = exports2.NUM_MAP;
        exports2.MINOR = exports2.MAJOR;
        var HEADER_STATE;
        (function(HEADER_STATE2) {
          HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
          HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
          HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
          HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
          HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
          HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
          HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
          HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
          HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
        })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
        exports2.SPECIAL_HEADERS = {
          "connection": HEADER_STATE.CONNECTION,
          "content-length": HEADER_STATE.CONTENT_LENGTH,
          "proxy-connection": HEADER_STATE.CONNECTION,
          "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
          "upgrade": HEADER_STATE.UPGRADE
        };
      }
    });
    var require_RedirectHandler = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/handler/RedirectHandler.js"(exports2, module2) {
        "use strict";
        var util2 = require_util2();
        var { kBodyUsed } = require_symbols();
        var assert2 = require("assert");
        var { InvalidArgumentError } = require_errors();
        var EE = require("events");
        var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
        var kBody = Symbol("body");
        var BodyAsyncIterable = class {
          constructor(body) {
            this[kBody] = body;
            this[kBodyUsed] = false;
          }
          async *[Symbol.asyncIterator]() {
            assert2(!this[kBodyUsed], "disturbed");
            this[kBodyUsed] = true;
            yield* this[kBody];
          }
        };
        __name(BodyAsyncIterable, "BodyAsyncIterable");
        var RedirectHandler = class {
          constructor(dispatch, maxRedirections, opts, handler) {
            if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
              throw new InvalidArgumentError("maxRedirections must be a positive number");
            }
            util2.validateHandler(handler, opts.method, opts.upgrade);
            this.dispatch = dispatch;
            this.location = null;
            this.abort = null;
            this.opts = { ...opts, maxRedirections: 0 };
            this.maxRedirections = maxRedirections;
            this.handler = handler;
            this.history = [];
            if (util2.isStream(this.opts.body)) {
              if (util2.bodyLength(this.opts.body) === 0) {
                this.opts.body.on("data", function() {
                  assert2(false);
                });
              }
              if (typeof this.opts.body.readableDidRead !== "boolean") {
                this.opts.body[kBodyUsed] = false;
                EE.prototype.on.call(this.opts.body, "data", function() {
                  this[kBodyUsed] = true;
                });
              }
            } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
              this.opts.body = new BodyAsyncIterable(this.opts.body);
            } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util2.isIterable(this.opts.body)) {
              this.opts.body = new BodyAsyncIterable(this.opts.body);
            }
          }
          onConnect(abort) {
            this.abort = abort;
            this.handler.onConnect(abort, { history: this.history });
          }
          onUpgrade(statusCode, headers, socket) {
            this.handler.onUpgrade(statusCode, headers, socket);
          }
          onError(error2) {
            this.handler.onError(error2);
          }
          onHeaders(statusCode, headers, resume, statusText) {
            this.location = this.history.length >= this.maxRedirections || util2.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
            if (this.opts.origin) {
              this.history.push(new URL(this.opts.path, this.opts.origin));
            }
            if (!this.location) {
              return this.handler.onHeaders(statusCode, headers, resume, statusText);
            }
            const { origin, pathname, search } = util2.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
            const path7 = search ? `${pathname}${search}` : pathname;
            this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
            this.opts.path = path7;
            this.opts.origin = origin;
            this.opts.maxRedirections = 0;
            if (statusCode === 303 && this.opts.method !== "HEAD") {
              this.opts.method = "GET";
              this.opts.body = null;
            }
          }
          onData(chunk) {
            if (this.location) {
            } else {
              return this.handler.onData(chunk);
            }
          }
          onComplete(trailers) {
            if (this.location) {
              this.location = null;
              this.abort = null;
              this.dispatch(this.opts, this);
            } else {
              this.handler.onComplete(trailers);
            }
          }
          onBodySent(chunk) {
            if (this.handler.onBodySent) {
              this.handler.onBodySent(chunk);
            }
          }
        };
        __name(RedirectHandler, "RedirectHandler");
        function parseLocation(statusCode, headers) {
          if (redirectableStatusCodes.indexOf(statusCode) === -1) {
            return null;
          }
          for (let i = 0; i < headers.length; i += 2) {
            if (headers[i].toString().toLowerCase() === "location") {
              return headers[i + 1];
            }
          }
        }
        __name(parseLocation, "parseLocation");
        function shouldRemoveHeader(header, removeContent, unknownOrigin) {
          return header.length === 4 && header.toString().toLowerCase() === "host" || removeContent && header.toString().toLowerCase().indexOf("content-") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === "authorization" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === "cookie";
        }
        __name(shouldRemoveHeader, "shouldRemoveHeader");
        function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
          const ret = [];
          if (Array.isArray(headers)) {
            for (let i = 0; i < headers.length; i += 2) {
              if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
                ret.push(headers[i], headers[i + 1]);
              }
            }
          } else if (headers && typeof headers === "object") {
            for (const key of Object.keys(headers)) {
              if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
                ret.push(key, headers[key]);
              }
            }
          } else {
            assert2(headers == null, "headers must be an object or an array");
          }
          return ret;
        }
        __name(cleanRequestHeaders, "cleanRequestHeaders");
        module2.exports = RedirectHandler;
      }
    });
    var require_redirectInterceptor = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports2, module2) {
        "use strict";
        var RedirectHandler = require_RedirectHandler();
        function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
          return (dispatch) => {
            return /* @__PURE__ */ __name(function Intercept(opts, handler) {
              const { maxRedirections = defaultMaxRedirections } = opts;
              if (!maxRedirections) {
                return dispatch(opts, handler);
              }
              const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
              opts = { ...opts, maxRedirections: 0 };
              return dispatch(opts, redirectHandler);
            }, "Intercept");
          };
        }
        __name(createRedirectInterceptor, "createRedirectInterceptor");
        module2.exports = createRedirectInterceptor;
      }
    });
    var require_llhttp_wasm = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/llhttp/llhttp.wasm.js"(exports2, module2) {
        module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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f2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQYgEcUGABEYNAiAEQShxRQ0CC0EADwtBAEEDIAApAyBQGyEFCyAFC10BAn9BACEBAkAgAC0AKEEBRg0AIAAvATIiAkGcf2pB5ABJDQAgAkHMAUYNACACQbACRg0AIAAvATAiAEHAAHENAEEBIQEgAEGIBHFBgARGDQAgAEEocUUhAQsgAQuiAQEDfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEDIAAvATAiBEECcUUNAQwCC0EAIQMgAC8BMCIEQQFxRQ0BC0EBIQMgAC0AKEEBRg0AIAAvATIiBUGcf2pB5ABJDQAgBUHMAUYNACAFQbACRg0AIARBwABxDQBBACEDIARBiARxQYAERg0AIARBKHFBAEchAwsgAEEAOwEwIABBADoALyADC5QBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQEgAC8BMCICQQJxRQ0BDAILQQAhASAALwEwIgJBAXFFDQELQQEhASAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC08AIABBGGpCADcDACAAQgA3AwAgAEEwakIANwMAIABBKGpCADcDACAAQSBqQgA3AwAgAEEQakIANwMAIABBCGpCADcDACAAQbwBNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQuICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC9POAQMcfwN+BX8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDyABIRAgASERIAEhEiABIRMgASEUIAEhFSABIRYgASEXIAEhGCABIRkgASEaIAEhGyABIRwgASEdAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIeQX9qDrwBtwEBtgECAwQFBgcICQoLDA0ODxDAAb8BERITtQEUFRYXGBkavQG8ARscHR4fICG0AbMBIiOyAbEBJCUmJygpKissLS4vMDEyMzQ1Njc4OTq4ATs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAQC5AQtBACEeDK8BC0EPIR4MrgELQQ4hHgytAQtBECEeDKwBC0ERIR4MqwELQRQhHgyqAQtBFSEeDKkBC0EWIR4MqAELQRchHgynAQtBGCEeDKYBC0EIIR4MpQELQRkhHgykAQtBGiEeDKMBC0ETIR4MogELQRIhHgyhAQtBGyEeDKABC0EcIR4MnwELQR0hHgyeAQtBHiEeDJ0BC0GqASEeDJwBC0GrASEeDJsBC0EgIR4MmgELQSEhHgyZAQtBIiEeDJgBC0EjIR4MlwELQSQhHgyWAQtBrQEhHgyVAQtBJSEeDJQBC0EpIR4MkwELQQ0hHgySAQtBJiEeDJEBC0EnIR4MkAELQSghHgyPAQtBLiEeDI4BC0EqIR4MjQELQa4BIR4MjAELQQwhHgyLAQtBLyEeDIoBC0ErIR4MiQELQQshHgyIAQtBLCEeDIcBC0EtIR4MhgELQQohHgyFAQtBMSEeDIQBC0EwIR4MgwELQQkhHgyCAQtBHyEeDIEBC0EyIR4MgAELQTMhHgx/C0E0IR4MfgtBNSEeDH0LQTYhHgx8C0E3IR4MewtBOCEeDHoLQTkhHgx5C0E6IR4MeAtBrAEhHgx3C0E7IR4MdgtBPCEeDHULQT0hHgx0C0E+IR4McwtBPyEeDHILQcAAIR4McQtBwQAhHgxwC0HCACEeDG8LQcMAIR4MbgtBxAAhHgxtC0EHIR4MbAtBxQAhHgxrC0EGIR4MagtBxgAhHgxpC0EFIR4MaAtBxwAhHgxnC0EEIR4MZgtByAAhHgxlC0HJACEeDGQLQcoAIR4MYwtBywAhHgxiC0EDIR4MYQtBzAAhHgxgC0HNACEeDF8LQc4AIR4MXgtB0AAhHgxdC0HPACEeDFwLQdEAIR4MWwtB0gAhHgxaC0ECIR4MWQtB0wAhHgxYC0HUACEeDFcLQdUAIR4MVgtB1gAhHgxVC0HXACEeDFQLQdgAIR4MUwtB2QAhHgxSC0HaACEeDFELQdsAIR4MUAtB3AAhHgxPC0HdACEeDE4LQd4AIR4MTQtB3wAhHgxMC0HgACEeDEsLQeEAIR4MSgtB4gAhHgxJC0HjACEeDEgLQeQAIR4MRwtB5QAhHgxGC0HmACEeDEULQecAIR4MRAtB6AAhHgxDC0HpACEeDEILQeoAIR4MQQtB6wAhHgxAC0HsACEeDD8LQe0AIR4MPgtB7gAhHgw9C0HvACEeDDwLQfAAIR4MOwtB8QAhHgw6C0HyACEeDDkLQfMAIR4MOAtB9AAhHgw3C0H1ACEeDDYLQfYAIR4MNQtB9wAhHgw0C0H4ACEeDDMLQfkAIR4MMgtB+gAhHgwxC0H7ACEeDDALQfwAIR4MLwtB/QAhHgwuC0H+ACEeDC0LQf8AIR4MLAtBgAEhHgwrC0GBASEeDCoLQYIBIR4MKQtBgwEhHgwoC0GEASEeDCcLQYUBIR4MJgtBhgEhHgwlC0GHASEeDCQLQYgBIR4MIwtBiQEhHgwiC0GKASEeDCELQYsBIR4MIAtBjAEhHgwfC0GNASEeDB4LQY4BIR4MHQtBjwEhHgwcC0GQASEeDBsLQZEBIR4MGgtBkgEhHgwZC0GTASEeDBgLQZQBIR4MFwtBlQEhHgwWC0GWASEeDBULQZcBIR4MFAtBmAEhHgwTC0GZASEeDBILQZ0BIR4MEQtBmgEhHgwQC0EBIR4MDwtBmwEhHgwOC0GcASEeDA0LQZ4BIR4MDAtBoAEhHgwLC0GfASEeDAoLQaEBIR4MCQtBogEhHgwIC0GjASEeDAcLQaQBIR4MBgtBpQEhHgwFC0GmASEeDAQLQacBIR4MAwtBqAEhHgwCC0GpASEeDAELQa8BIR4LA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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AbsBuwG7AbsBuwG7AbsBuwG7AQG7AQsgCEEBaiEBQdQAIR4MmAILIAhBAWohAUHVACEeDJcCC0HnACEeIAEiIiACRg2mAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB7bOAgABqLQAARw25ASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpwILIABBADYCACAiICZrQQNqIQFBECEeDLYBC0HoACEeIAEiIiACRg2lAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB9rKAgABqLQAARw24ASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpgILIABBADYCACAiICZrQQZqIQFBFiEeDLUBC0HpACEeIAEiIiACRg2kAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB/LKAgABqLQAARw23ASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpQILIABBADYCACAiICZrQQRqIQFBBSEeDLQBCwJAIAEiCCACRw0AQeoAIR4MpAILIAgtAABB2QBHDbUBIAhBAWohAUEIIR4MswELAkAgASIIIAJHDQBB6wAhHgyjAgsCQAJAIAgtAABBsn9qDgMAtgEBtgELIAhBAWohAUHZACEeDJMCCyAIQQFqIQFB2gAhHgySAgsCQCABIgggAkcNAEHsACEeDKICCwJAAkAgCC0AAEG4f2oOCAC1AbUBtQG1AbUBtQEBtQELIAhBAWohAUHYACEeDJICCyAIQQFqIQFB2wAhHgyRAgtB7QAhHiABIiIgAkYNoAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYCzgIAAai0AAEcNswEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKECC0EAIR4gAEEANgIAICIgJmtBA2ohAQywAQtB7gAhHiABIiIgAkYNnwIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYOzgIAAai0AAEcNsgEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKACCyAAQQA2AgAgIiAma0EFaiEBQSMhHgyvAQsCQCABIgggAkcN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ImohJiAeIQggIiEBAkADQCAILQAAIAFBp7OAgABqLQAARw2gASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBgAEhHgyOAgsgAEEANgIAIB4gImtBAmohAUELIR4MnQELAkAgASIIIAJHDQBBgQEhHgyNAgsCQAJAAkACQCAILQAAQVNqDiMAogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAQGiAaIBogGiAaIBAqIBogGiAQOiAQsgCEEBaiEBQekAIR4M/wELIAhBAWohAUHqACEeDP4BCyAIQQFqIQFB7wAhHgz9AQsgCEEBaiEBQfAAIR4M/AELAkAgASIeIAJHDQBBggEhHgyMAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQamzgIAAai0AAEcNngEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYIBIR4MjAILIABBADYCACAeICJrQQVqIQFBGSEeDJsBCwJAIAEiIiACRw0AQYMBIR4MiwILIAIgImsgACgCACImaiEeICIhCCAmIQECQANAIAgtAAAgAUGus4CAAGotAABHDZ0BIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgHjYCAEGDASEeDIsCCyAAQQA2AgBBBiEeICIgJmtBBmohAQyaAQsCQCABIh4gAkcNAEGEASEeDIoCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBtLOAgABqLQAARw2cASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBhAEhHgyKAgsgAEEANgIAIB4gImtBAmohAUEcIR4MmQELAkAgASIeIAJHDQBBhQEhHgyJAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQbazgIAAai0AAEcNmwEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYUBIR4MiQILIABBADYCACAeICJrQQJqIQFBJyEeDJgBCwJAIAEiCCACRw0AQYYBIR4MiAILAkACQCAILQAAQax/ag4CAAGbAQsgCEEBaiEBQfQAIR4M+AELIAhBAWohAUH1ACEeDPcBCwJAIAEiHiAC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IiEBDDELIABBxAA2AhwgACAiNgIUIAAgATYCDEEAIR4MeQsgACgCBCEBIABBADYCBAJAIAAgASAiEKSAgIAAIgENACAiIQEMMQsgAEHFADYCHCAAICI2AhQgACABNgIMQQAhHgx4CyAAKAIEIQEgAEEANgIEAkAgACABICIQpICAgAAiAQ0AICIhAQw1CyAAQdAANgIcIAAgIjYCFCAAIAE2AgxBACEeDHcLIABBADYCHCAAICI2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHYLIABBADYCHCAAIAE2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHULQQAhHiAAQQA2AhwgACAiNgIUIABBv5SAgAA2AhAgAEEHNgIMDHQLIABBADYCHCAAICI2AhQgAEG/lICAADYCECAAQQc2AgxBACEeDHMLIABBADYCHCAAICI2AhQgAEHUjoCAADYCECAAQQc2AgxBACEeDHILIABBADYCHCAAIAE2AhQgAEHBk4CAADYCECAAQQY2AgxBACEeDHELIABBADYCACAiICZrQQZqIQFBJCEeCyAAIB46ACkgASEBDE4LIABBADYCAAtBACEeIABBADYCHCAAIAg2AhQgAEGklICAADYCECAAQQY2AgwMbQsgACgCBCETIABBADYCBCAAIBMgHhCmgICAACITDQEgHkEBaiETC0GdASEeDFsLIABBqgE2AhwgACATNgIMIAAgHkEBajYCFEEAIR4MagsgACgCBCEUIABBADYCBCAAIBQgHhCmgICAACIUDQEgHkEBaiEUC0GaASEeDFgLIABBqwE2AhwgACAUNgIMIAAgHkEBajYCFEEAIR4MZwsgAEEANgIcIAAgFTYCFCAAQfOKgIAANgIQIABBDTYCDEEAIR4MZgsgAEEANgIcIAAgFjYCFCAAQc6NgIAANgIQIABBCTYCDEEAIR4MZQtBASEeCyAAIB46ACsgF0EBaiEWDC4LIABBADYCHCAAIBc2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDGILIABBADYCHCAAIBg2AhQgAEHFioCAADYCECAAQQk2AgxBACEeDGELQQEhHgsgACAeOgAqIBlBAWohGAwsCyAAQQA2AhwgACAZNgIUIABBuI2AgAA2AhAgAEEJNgIMQQAhHgxeCyAAQQA2AhwgACAZNgIUIABBuZuAgAA2AhAgAEEINgIMIABBADYCAEEAIR4MXQsgAEEANgIAC0EAIR4gAEEANgIcIAAgCDYCFCAAQYuUgIAANgIQIABBCDYCDAxbCyAAQQI6ACggAEEANgIAIBsgGWtBA2ohGQw2CyAAQQI6AC8gACAIIAIQo4CAgAAiHg0BQa8BIR4MSQsgAC0AKEF/ag4CHiAfCyAeQRVHDScgAEG7ATYCHCAAIAg2AhQgAEGnkoCAADYCECAAQRU2AgxBACEeDFcLQQAhHgxGC0ECIR4MRQtBDiEeDEQLQRAhHgxDC0EcIR4MQgtBFCEeDEELQRYhHgxAC0EXIR4MPwtBGSEeDD4LQRohHgw9C0E6IR4MPAtBIyEeDDsLQSQhHgw6C0EwIR4MOQtBOyEeDDgLQTwhHgw3C0E+IR4MNgtBPyEeDDULQcAAIR4MNAtBwQAhHgwzC0HFACEeDDILQccAIR4MMQtByAAhHgwwC0HKACEeDC8LQd8AIR4MLgtB4gAhHgwtC0H7ACEeDCwLQYUBIR4MKwtBlwEhHgwqC0GZASEeDCkLQakBIR4MKAtBpAEhHgwnC0GbASEeDCYLQZ4BIR4MJQtBnwEhHgwkC0GhASEeDCMLQaIBIR4MIgtBpwEhHgwhC0GoASEeDCALIABBADYCHCAAIAg2AhQgAEHmi4CAADYCECAAQRA2AgxBACEeDC8LIABBADYCBCAAIB0gHRCqgICAACIBRQ0BIABBLTYCHCAAIAE2AgwgACAdQQFqNgIUQQAhHgwuCyAAKAIEIQggAEEANgIEAkAgACAIIAEQqoCAgAAiCEUNACAAQS42AhwgACAINgIMIAAgAUEBajYCFEEAIR4MLgsgAUEBaiEBDB4LIB1BAWohAQweCyAAQQA2AhwgACAdNgIUIABBuo+AgAA2AhAgAEEENgIMQQAhHgwrCyAAQSk2AhwgACABNgIUIAAgCDYCDEEAIR4MKgsgHEEBaiEBDB4LIABBCjYCHCAAIAE2AhQgAEGRkoCAADYCECAAQRU2AgxBACEeDCgLIABBEDYCHCAAIAE2AhQgAEG+koCAADYCECAAQRU2AgxBACEeDCcLIABBADYCHCAAIB42AhQgAEGIjICAADYCECAAQRQ2AgxBACEeDCYLIABBBDYCHCAAIAE2AhQgAEHWkoCAADYCECAAQRU2AgxBACEeDCULIABBADYCACAIICJrQQVqIRkLQaMBIR4MEwsgAEEANgIAICIgJmtBAmohAUHjACEeDBILIABBADYCACAAQYEEOwEoIBogHmtBAmohAQtB0wAhHgwQCyABIQECQCAALQApQQVHDQBB0gAhHgwQC0HRACEeDA8LQQAhHiAAQQA2AhwgAEG6joCAADYCECAAQQc2AgwgACAiQQFqNgIUDB4LIABBADYCACAmICNrQQJqIQFBNCEeDA0LIAEhAQtBLSEeDAsLAkAgASIdIAJGDQADQAJAIB0tAABBgKKAgABqLQAAIgFBAUYNACABQQJHDQMgHUEBaiEBDAQLIB1BAWoiHSACRw0AC0ExIR4MGwtBMSEeDBoLIABBADoALCAdIQEMAQtBDCEeDAgLQS8hHgwHCyABQQFqIQFBIiEeDAYLQR8hHgwFCyAAQQA2AgAgIyAka0EEaiEBQQYhHgsgACAeOgAsIAEhAUENIR4MAwsgAEEANgIAICYgI2tBB2ohAUELIR4MAgsgAEEANgIACyAAQQA6ACwgHCEBQQkhHgwACwtBACEeIABBADYCHCAAIAE2AhQgAEG4kYCAADYCECAAQQ82AgwMDgtBACEeIABBADYCHCAAIAE2AhQgAEG4kYCAADYCECAAQQ82AgwMDQtBACEeIABBADYCHCAAIAE2AhQgAEGWj4CAADYCECAAQQs2AgwMDAtBACEeIABBADYCHCAAIAE2AhQgAEHxiICAADYCECAAQQs2AgwMCwtBACEeIABBADYCHCAAIAE2AhQgAEGIjYCAADYCECAAQQo2AgwMCgsgAEECNgIcIAAgATYCFCAAQfCSgIAANgIQIABBFjYCDEEAIR4MCQtBASEeDAgLQcYAIR4gASIBIAJGDQcgA0EIaiAAIAEgAkHYpoCAAEEKELmAgIAAIAMoAgwhASADKAIIDgMBBwIACxC/gICAAAALIABBADYCHCAAQYmTgIAANgIQIABBFzYCDCAAIAFBAWo2AhRBACEeDAULIABBADYCHCAAIAE2AhQgAEGek4CAADYCECAAQQk2AgxBACEeDAQLAkAgASIBIAJHDQBBISEeDAQLAkAgAS0AAEEKRg0AIABBADYCHCAAIAE2AhQgAEHujICAADYCECAAQQo2AgxBACEeDAQLIAAoAgQhCCAAQQA2AgQgACAIIAEQqoCAgAAiCA0BIAFBAWohAQtBACEeIABBADYCHCAAIAE2AhQgAEHqkICAADYCECAAQRk2AgwMAgsgAEEgNgIcIAAgCDYCDCAAIAFBAWo2AhRBACEeDAELAkAgASIBIAJHDQBBFCEeDAELIABBiYCAgAA2AgggACABNgIEQRMhHgsgA0EQaiSAgICAACAeC68BAQJ/IAEoAgAhBgJAAkAgAiADRg0AIAQgBmohBCAGIANqIAJrIQcgAiAGQX9zIAVqIgZqIQUDQAJAIAItAAAgBC0AAEYNAEECIQQMAwsCQCAGDQBBACEEIAUhAgwDCyAGQX9qIQYgBEEBaiEEIAJBAWoiAiADRw0ACyAHIQYgAyECCyAAQQE2AgAgASAGNgIAIAAgAjYCBA8LIAFBADYCACAAIAQ2AgAgACACNgIECwoAIAAQu4CAgAALlTcBC38jgICAgABBEGsiASSAgICAAAJAQQAoAqC0gIAADQBBABC+gICAAEGAuISAAGsiAkHZAEkNAEEAIQMCQEEAKALgt4CAACIEDQBBAEJ/NwLst4CAAEEAQoCAhICAgMAANwLkt4CAAEEAIAFBCGpBcHFB2KrVqgVzIgQ2AuC3gIAAQQBBADYC9LeAgABBAEEANgLEt4CAAAtBACACNgLMt4CAAEEAQYC4hIAANgLIt4CAAEEAQYC4hIAANgKYtICAAEEAIAQ2Aqy0gIAAQQBBfzYCqLSAgAADQCADQcS0gIAAaiADQbi0gIAAaiIENgIAIAQgA0GwtICAAGoiBTYCACADQby0gIAAaiAFNgIAIANBzLSAgABqIANBwLSAgABqIgU2AgAgBSAENgIAIANB1LSAgABqIANByLSAgABqIgQ2AgAgBCAFNgIAIANB0LSAgABqIAQ2AgAgA0EgaiIDQYACRw0AC0GAuISAAEF4QYC4hIAAa0EPcUEAQYC4hIAAQQhqQQ9xGyIDaiIEQQRqIAIgA2tBSGoiA0EBcjYCAEEAQQAoAvC3gIAANgKktICAAEEAIAQ2AqC0gIAAQQAgAzYClLSAgAAgAkGAuISAAGpBTGpBODYCAAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAoi0gIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNACADQQFxIARyQQFzIgVBA3QiAEG4tICAAGooAgAiBEEIaiEDAkACQCAEKAIIIgIgAEGwtICAAGoiAEcNAEEAIAZBfiAFd3E2Aoi0gIAADAELIAAgAjYCCCACIAA2AgwLIAQgBUEDdCIFQQNyNgIEIAQgBWpBBGoiBCAEKAIAQQFyNgIADAwLIAJBACgCkLSAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBUEDdCIAQbi0gIAAaigCACIEKAIIIgMgAEGwtICAAGoiAEcNAEEAIAZBfiAFd3EiBjYCiLSAgAAMAQsgACADNgIIIAMgADYCDAsgBEEIaiEDIAQgAkEDcjYCBCAEIAVBA3QiBWogBSACayIFNgIAIAQgAmoiACAFQQFyNgIEAkAgB0UNACAHQQN2IghBA3RBsLSAgABqIQJBACgCnLSAgAAhBAJAAkAgBkEBIAh0IghxDQBBACAGIAhyNgKItICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLQQAgADYCnLSAgABBACAFNgKQtICAAAwMC0EAKAKMtICAACIJRQ0BIAlBACAJa3FBf2oiAyADQQx2QRBxIgN2IgRBBXZBCHEiBSADciAEIAV2IgNBAnZBBHEiBHIgAyAEdiIDQQF2QQJxIgRyIAMgBHYiA0EBdkEBcSIEciADIAR2akECdEG4toCAAGooAgAiACgCBEF4cSACayEEIAAhBQJAA0ACQCAFKAIQIgMNACAFQRRqKAIAIgNFDQILIAMoAgRBeHEgAmsiBSAEIAUgBEkiBRshBCADIAAgBRshACADIQUMAAsLIAAoAhghCgJAIAAoAgwiCCAARg0AQQAoApi0gIAAIAAoAggiA0saIAggAzYCCCADIAg2AgwMCwsCQCAAQRRqIgUoAgAiAw0AIAAoAhAiA0UNAyAAQRBqIQULA0AgBSELIAMiCEEUaiIFKAIAIgMNACAIQRBqIQUgCCgCECIDDQALIAtBADYCAAwKC0F/IQIgAEG/f0sNACAAQRNqIgNBcHEhAkEAKAKMtICAACIHRQ0AQQAhCwJAIAJBgAJJDQBBHyELIAJB////B0sNACADQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgQgBEGA4B9qQRB2QQRxIgR0IgUgBUGAgA9qQRB2QQJxIgV0QQ92IAMgBHIgBXJrIgNBAXQgAiADQRVqdkEBcXJBHGohCwtBACACayEEAkACQAJAAkAgC0ECdEG4toCAAGooAgAiBQ0AQQAhA0EAIQgMAQtBACEDIAJBAEEZIAtBAXZrIAtBH0YbdCEAQQAhCANAAkAgBSgCBEF4cSACayIGIARPDQAgBiEEIAUhCCAGDQBBACEEIAUhCCAFIQMMAwsgAyAFQRRqKAIAIgYgBiAFIABBHXZBBHFqQRBqKAIAIgVGGyADIAYbIQMgAEEBdCEAIAUNAAsLAkAgAyAIcg0AQQAhCEECIAt0IgNBACADa3IgB3EiA0UNAyADQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIFQQV2QQhxIgAgA3IgBSAAdiIDQQJ2QQRxIgVyIAMgBXYiA0EBdkECcSIFciADIAV2IgNBAXZBAXEiBXIgAyAFdmpBAnRBuLaAgABqKAIAIQMLIANFDQELA0AgAygCBEF4cSACayIGIARJIQACQCADKAIQIgUNACADQRRqKAIAIQULIAYgBCAAGyEEIAMgCCAAGyEIIAUhAyAFDQALCyAIRQ0AIARBACgCkLSAgAAgAmtPDQAgCCgCGCELAkAgCCgCDCIAIAhGDQBBACgCmLSAgAAgCCgCCCIDSxogACADNgIIIAMgADYCDAwJCwJAIAhBFGoiBSgCACIDDQAgCCgCECIDRQ0DIAhBEGohBQsDQCAFIQYgAyIAQRRqIgUoAgAiAw0AIABBEGohBSAAKAIQIgMNAAsgBkEANgIADAgLAkBBACgCkLSAgAAiAyACSQ0AQQAoApy0gIAAIQQCQAJAIAMgAmsiBUEQSQ0AIAQgAmoiACAFQQFyNgIEQQAgBTYCkLSAgABBACAANgKctICAACAEIANqIAU2AgAgBCACQQNyNgIEDAELIAQgA0EDcjYCBCADIARqQQRqIgMgAygCAEEBcjYCAEEAQQA2Apy0gIAAQQBBADYCkLSAgAALIARBCGohAwwKCwJAQQAoApS0gIAAIgAgAk0NAEEAKAKgtICAACIDIAJqIgQgACACayIFQQFyNgIEQQAgBTYClLSAgABBACAENgKgtICAACADIAJBA3I2AgQgA0EIaiEDDAoLAkACQEEAKALgt4CAAEUNAEEAKALot4CAACEEDAELQQBCfzcC7LeAgABBAEKAgISAgIDAADcC5LeAgABBACABQQxqQXBxQdiq1aoFczYC4LeAgABBAEEANgL0t4CAAEEAQQA2AsS3gIAAQYCABCEEC0EAIQMCQCAEIAJBxwBqIgdqIgZBACAEayILcSIIIAJLDQBBAEEwNgL4t4CAAAwKCwJAQQAoAsC3gIAAIgNFDQACQEEAKAK4t4CAACIEIAhqIgUgBE0NACAFIANNDQELQQAhA0EAQTA2Avi3gIAADAoLQQAtAMS3gIAAQQRxDQQCQAJAAkBBACgCoLSAgAAiBEUNAEHIt4CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIARLDQMLIAMoAggiAw0ACwtBABC+gICAACIAQX9GDQUgCCEGAkBBACgC5LeAgAAiA0F/aiIEIABxRQ0AIAggAGsgBCAAakEAIANrcWohBgsgBiACTQ0FIAZB/v///wdLDQUCQEEAKALAt4CAACIDRQ0AQQAoAri3gIAAIgQgBmoiBSAETQ0GIAUgA0sNBgsgBhC+gICAACIDIABHDQEMBwsgBiAAayALcSIGQf7///8HSw0EIAYQvoCAgAAiACADKAIAIAMoAgRqRg0DIAAhAwsCQCADQX9GDQAgAkHIAGogBk0NAAJAIAcgBmtBACgC6LeAgAAiBGpBACAEa3EiBEH+////B00NACADIQAMBwsCQCAEEL6AgIAAQX9GDQAgBCAGaiEGIAMhAAwHC0EAIAZrEL6AgIAAGgwECyADIQAgA0F/Rw0FDAMLQQAhCAwHC0EAIQAMBQsgAEF/Rw0CC0EAQQAoAsS3gIAAQQRyNgLEt4CAAAsgCEH+////B0sNASAIEL6AgIAAIQBBABC+gICAACEDIABBf0YNASADQX9GDQEgACADTw0BIAMgAGsiBiACQThqTQ0BC0EAQQAoAri3gIAAIAZqIgM2Ari3gIAAAkAgA0EAKAK8t4CAAE0NAEEAIAM2Ary3gIAACwJAAkACQAJAQQAoAqC0gIAAIgRFDQBByLeAgAAhAwNAIAAgAygCACIFIAMoAgQiCGpGDQIgAygCCCIDDQAMAwsLAkACQEEAKAKYtICAACIDRQ0AIAAgA08NAQtBACAANgKYtICAAAtBACEDQQAgBjYCzLeAgABBACAANgLIt4CAAEEAQX82Aqi0gIAAQQBBACgC4LeAgAA2Aqy0gIAAQQBBADYC1LeAgAADQCADQcS0gIAAaiADQbi0gIAAaiIENgIAIAQgA0GwtICAAGoiBTYCACADQby0gIAAaiAFNgIAIANBzLSAgABqIANBwLSAgABqIgU2AgAgBSAENgIAIANB1LSAgABqIANByLSAgABqIgQ2AgAgBCAFNgIAIANB0LSAgABqIAQ2AgAgA0EgaiIDQYACRw0ACyAAQXggAGtBD3FBACAAQQhqQQ9xGyIDaiIEIAYgA2tBSGoiA0EBcjYCBEEAQQAoAvC3gIAANgKktICAAEEAIAQ2AqC0gIAAQQAgAzYClLSAgAAgBiAAakFMakE4NgIADAILIAMtAAxBCHENACAFIARLDQAgACAETQ0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClLSAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvC3gIAANgKktICAAEEAIAU2ApS0gIAAQQAgADYCoLSAgAAgCyAEakEEakE4NgIADAELAkAgAEEAKAKYtICAACILTw0AQQAgADYCmLSAgAAgACELCyAAIAZqIQhByLeAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAIRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HIt4CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiIGIAJBA3I2AgQgCEF4IAhrQQ9xQQAgCEEIakEPcRtqIgggBiACaiICayEFAkAgBCAIRw0AQQAgAjYCoLSAgABBAEEAKAKUtICAACAFaiIDNgKUtICAACACIANBAXI2AgQMAwsCQEEAKAKctICAACAIRw0AQQAgAjYCnLSAgABBAEEAKAKQtICAACAFaiIDNgKQtICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgCCgCBCIDQQNxQQFHDQAgA0F4cSEHAkACQCADQf8BSw0AIAgoAggiBCADQQN2IgtBA3RBsLSAgABqIgBGGgJAIAgoAgwiAyAERw0AQQBBACgCiLSAgABBfiALd3E2Aoi0gIAADAILIAMgAEYaIAMgBDYCCCAEIAM2AgwMAQsgCCgCGCEJAkACQCAIKAIMIgAgCEYNACALIAgoAggiA0saIAAgAzYCCCADIAA2AgwMAQsCQCAIQRRqIgMoAgAiBA0AIAhBEGoiAygCACIEDQBBACEADAELA0AgAyELIAQiAEEUaiIDKAIAIgQNACAAQRBqIQMgACgCECIEDQALIAtBADYCAAsgCUUNAAJAAkAgCCgCHCIEQQJ0Qbi2gIAAaiIDKAIAIAhHDQAgAyAANgIAIAANAUEAQQAoAoy0gIAAQX4gBHdxNgKMtICAAAwCCyAJQRBBFCAJKAIQIAhGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCCgCFCIDRQ0AIABBFGogAzYCACADIAA2AhgLIAcgBWohBSAIIAdqIQgLIAggCCgCBEF+cTYCBCACIAVqIAU2AgAgAiAFQQFyNgIEAkAgBUH/AUsNACAFQQN2IgRBA3RBsLSAgABqIQMCQAJAQQAoAoi0gIAAIgVBASAEdCIEcQ0AQQAgBSAEcjYCiLSAgAAgAyEEDAELIAMoAgghBAsgBCACNgIMIAMgAjYCCCACIAM2AgwgAiAENgIIDAMLQR8hAwJAIAVB////B0sNACAFQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgQgBEGA4B9qQRB2QQRxIgR0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAMgBHIgAHJrIgNBAXQgBSADQRVqdkEBcXJBHGohAwsgAiADNgIcIAJCADcCECADQQJ0Qbi2gIAAaiEEAkBBACgCjLSAgAAiAEEBIAN0IghxDQAgBCACNgIAQQAgACAIcjYCjLSAgAAgAiAENgIYIAIgAjYCCCACIAI2AgwMAwsgBUEAQRkgA0EBdmsgA0EfRht0IQMgBCgCACEAA0AgACIEKAIEQXhxIAVGDQIgA0EddiEAIANBAXQhAyAEIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAENgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGIANrQUhqIgNBAXI2AgQgCEFMakE4NgIAIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8LeAgAA2AqS0gIAAQQAgCzYCoLSAgABBACADNgKUtICAACAIQRBqQQApAtC3gIAANwIAIAhBACkCyLeAgAA3AghBACAIQQhqNgLQt4CAAEEAIAY2Asy3gIAAQQAgADYCyLeAgABBAEEANgLUt4CAACAIQSRqIQMDQCADQQc2AgAgBSADQQRqIgNLDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgY2AgAgBCAGQQFyNgIEAkAgBkH/AUsNACAGQQN2IgVBA3RBsLSAgABqIQMCQAJAQQAoAoi0gIAAIgBBASAFdCIFcQ0AQQAgACAFcjYCiLSAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIAZB////B0sNACAGQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAMgBXIgAHJrIgNBAXQgBiADQRVqdkEBcXJBHGohAwsgBEIANwIQIARBHGogAzYCACADQQJ0Qbi2gIAAaiEFAkBBACgCjLSAgAAiAEEBIAN0IghxDQAgBSAENgIAQQAgACAIcjYCjLSAgAAgBEEYaiAFNgIAIAQgBDYCCCAEIAQ2AgwMBAsgBkEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEAA0AgACIFKAIEQXhxIAZGDQMgA0EddiEAIANBAXQhAyAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAQ2AgAgBEEYaiAFNgIAIAQgBDYCDCAEIAQ2AggMAwsgBCgCCCIDIAI2AgwgBCACNgIIIAJBADYCGCACIAQ2AgwgAiADNgIICyAGQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBGGpBADYCACAEIAU2AgwgBCADNgIIC0EAKAKUtICAACIDIAJNDQBBACgCoLSAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApS0gIAAQQAgBTYCoLSAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL4t4CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0Qbi2gIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2Aoy0gIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCADIAhqQQRqIgMgAygCAEEBcjYCAAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQQN2IgRBA3RBsLSAgABqIQMCQAJAQQAoAoi0gIAAIgVBASAEdCIEcQ0AQQAgBSAEcjYCiLSAgAAgAyEEDAELIAMoAgghBAsgBCAANgIMIAMgADYCCCAAIAM2AgwgACAENgIIDAELQR8hAwJAIARB////B0sNACAEQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgIgAkGAgA9qQRB2QQJxIgJ0QQ92IAMgBXIgAnJrIgNBAXQgBCADQRVqdkEBcXJBHGohAwsgACADNgIcIABCADcCECADQQJ0Qbi2gIAAaiEFAkAgB0EBIAN0IgJxDQAgBSAANgIAQQAgByACcjYCjLSAgAAgACAFNgIYIAAgADYCCCAAIAA2AgwMAQsgBEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACECAkADQCACIgUoAgRBeHEgBEYNASADQR12IQIgA0EBdCEDIAUgAkEEcWpBEGoiBigCACICDQALIAYgADYCACAAIAU2AhggACAANgIMIAAgADYCCAwBCyAFKAIIIgMgADYCDCAFIAA2AgggAEEANgIYIAAgBTYCDCAAIAM2AggLIAhBCGohAwwBCwJAIApFDQACQAJAIAAgACgCHCIFQQJ0Qbi2gIAAaiIDKAIARw0AIAMgCDYCACAIDQFBACAJQX4gBXdxNgKMtICAAAwCCyAKQRBBFCAKKAIQIABGG2ogCDYCACAIRQ0BCyAIIAo2AhgCQCAAKAIQIgNFDQAgCCADNgIQIAMgCDYCGAsgAEEUaigCACIDRQ0AIAhBFGogAzYCACADIAg2AhgLAkACQCAEQQ9LDQAgACAEIAJqIgNBA3I2AgQgAyAAakEEaiIDIAMoAgBBAXI2AgAMAQsgACACaiIFIARBAXI2AgQgACACQQNyNgIEIAUgBGogBDYCAAJAIAdFDQAgB0EDdiIIQQN0QbC0gIAAaiECQQAoApy0gIAAIQMCQAJAQQEgCHQiCCAGcQ0AQQAgCCAGcjYCiLSAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2Apy0gIAAQQAgBDYCkLSAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQvYCAgAAL8A0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApi0gIAAIgRJDQEgAiAAaiEAAkBBACgCnLSAgAAgAUYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGwtICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKItICAAEF+IAV3cTYCiLSAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAQgASgCCCICSxogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABKAIcIgRBAnRBuLaAgABqIgIoAgAgAUcNACACIAY2AgAgBg0BQQBBACgCjLSAgABBfiAEd3E2Aoy0gIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQtICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgAyABTQ0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkBBACgCoLSAgAAgA0cNAEEAIAE2AqC0gIAAQQBBACgClLSAgAAgAGoiADYClLSAgAAgASAAQQFyNgIEIAFBACgCnLSAgABHDQNBAEEANgKQtICAAEEAQQA2Apy0gIAADwsCQEEAKAKctICAACADRw0AQQAgATYCnLSAgABBAEEAKAKQtICAACAAaiIANgKQtICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsLSAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiLSAgABBfiAFd3E2Aoi0gIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNAEEAKAKYtICAACADKAIIIgJLGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMoAhwiBEECdEG4toCAAGoiAigCACADRw0AIAIgBjYCACAGDQFBAEEAKAKMtICAAEF+IAR3cTYCjLSAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnLSAgABHDQFBACAANgKQtICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEEDdiICQQN0QbC0gIAAaiEAAkACQEEAKAKItICAACIEQQEgAnQiAnENAEEAIAQgAnI2Aoi0gIAAIAAhAgwBCyAAKAIIIQILIAIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgAUIANwIQIAFBHGogAjYCACACQQJ0Qbi2gIAAaiEEAkACQEEAKAKMtICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKMtICAACABQRhqIAQ2AgAgASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAFBGGogBDYCACABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQRhqQQA2AgAgASAENgIMIAEgADYCCAtBAEEAKAKotICAAEF/aiIBQX8gARs2Aqi0gIAACwtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+LeAgABBfw8LIABBEHQPCxC/gICAAAALBAAAAAsLjiwBAEGACAuGLAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgcGFyYW1ldGVycwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABNS0FDVElWSVRZAENPUFkATk9USUZZAFBMQVkAUFVUAENIRUNLT1VUAFBPU1QAUkVQT1JUAEhQRV9JTlZBTElEX0NPTlNUQU5UAEdFVABIUEVfU1RSSUNUAFJFRElSRUNUAENPTk5FQ1QASFBFX0lOVkFMSURfU1RBVFVTAE9QVElPTlMAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASFBFX0lOVkFMSURfVVJMAE1LQ09MAEFDTABIUEVfSU5URVJOQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBQQVVTRQBQVVJHRQBNRVJHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAFBST1BGSU5EAFVO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AAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
      }
    });
    var require_llhttp_simd_wasm = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/llhttp/llhttp_simd.wasm.js"(exports2, module2) {
        module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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ASEeDBELQZoBIR4MEAtBASEeDA8LQZsBIR4MDgtBnAEhHgwNC0GeASEeDAwLQaABIR4MCwtBnwEhHgwKC0GhASEeDAkLQaIBIR4MCAtBowEhHgwHC0GkASEeDAYLQaUBIR4MBQtBpgEhHgwEC0GnASEeDAMLQagBIR4MAgtBqQEhHgwBC0GvASEeCwNAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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IAgtAABBtH9qDggAsgGyAbIBsgGyAbIBAbIBCyAIQQFqIQFB3QAhHgyPAgsgCEEBaiEBQd4AIR4MjgILAkAgASIIIAJHDQBB8AAhHgyeAgsgCC0AAEHFAEcNrwEgCEEBaiEBDN4BC0HxACEeIAEiIiACRg2cAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFBiLOAgABqLQAARw2vASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnQILIABBADYCACAiICZrQQRqIQFBLSEeDKwBC0HyACEeIAEiIiACRg2bAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB0LOAgABqLQAARw2uASABQQhGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnAILIABBADYCACAiICZrQQlqIQFBKSEeDKsBCwJAIAEiASACRw0AQfMAIR4MmwILQQEhHiABLQAAQd8ARw2qASABQQFqIQEM3AELQfQAIR4gASIiIAJGDZkCIAIgImsgACgCACImaiEjICIhCCAmIQEDQCAILQAAIAFBjLOAgABqLQAARw2rASABQQFGDfcBIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADJkCCwJAIAEiHiACRw0AQfUAIR4MmQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGOs4CAAGotAABHDasBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH1ACEeDJkCCyAAQQA2AgAgHiAia0EDaiEBQQIhHgyoAQsCQCABIh4gAkcNAEH2ACEeDJgCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFB8LOAgABqLQAARw2qASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB9gAhHgyYAgsgAEEANgIAIB4gImtBAmohAUEfIR4MpwELAkAgASIeIAJHDQBB9wAhHgyXAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQfKzgIAAai0AAEcNqQEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfcAIR4MlwILIABBADYCACAeICJrQQJq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LwEwQRByOwEwDIcBCyAAQTY2AhwgACABNgIMIAAgHEEBajYCFEEAIR4MoAELIAEtAABBOkcNAiAAKAIEIR4gAEEANgIEIAAgHiABEKiAgIAAIh4NASABQQFqIQELQTEhHgyOAQsgAEE2NgIcIAAgHjYCDCAAIAFBAWo2AhRBACEeDJ0BCyAAQQA2AhwgACABNgIUIABBh46AgAA2AhAgAEEKNgIMQQAhHgycAQsgAUEBaiEBCyAAQYASOwEqIAAgASACEKWAgIAAGiABIQELQawBIR4MiQELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDFALIABBxAA2AhwgACABNgIUIAAgHjYCDEEAIR4MmAELIABBADYCHCAAICI2AhQgAEHlmICAADYCECAAQQc2AgwgAEEANgIAQQAhHgyXAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMTwsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgyWAQtBACEeIABBADYCHCAAIAE2AhQgAEHrjYCAADYCECAAQQk2AgwMlQELQQEhHgsgACAeOgArIAFBAWohASAALQApQSJGDYsBDEwLIABBADYCHCAAIAE2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDJIBCyAAQQA2AhwgACABNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhHgyRAQtBASEeCyAAIB46ACogAUEBaiEBDEoLIABBADYCHCAAIAE2AhQgAEG4jYCAADYCECAAQQk2AgxBACEeDI4BCyAAQQA2AgAgJiAja0EEaiEBAkAgAC0AKUEjTw0AIAEhAQxKCyAAQQA2AhwgACABNgIUIABBr4mAgAA2AhAgAEEINgIMQQAhHgyNAQsgAEEANgIAC0EAIR4gAEEANgIcIAAgATYCFCAAQbmbgIAANgIQIABBCDYCDAyLAQsgAEEANgIAICYgI2tBA2ohAQJAIAAtAClBIUcNACABIQEMRwsgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDEEAIR4MigELIABBADYCACAmICNrQQRqIQECQCAALQApIh5BXWpBC08NACABIQEMRgsCQCAeQQZLDQBBASAedEHKAHFFDQAgASEBDEYLQQAhHiAAQQA2AhwgACAB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HiAAQQA2AhwgACABNgIUIABB6pCAgAA2AhAgAEEZNgIMDAILIABBIDYCHCAAIAg2AgwgACABQQFqNgIUQQAhHgwBCwJAIAEiASACRw0AQRQhHgwBCyAAQYmAgIAANgIIIAAgATYCBEETIR4LIANBEGokgICAgAAgHguvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAELuAgIAAC5U3AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKgtICAAA0AQQAQvoCAgABBgLiEgABrIgJB2QBJDQBBACEDAkBBACgC4LeAgAAiBA0AQQBCfzcC7LeAgABBAEKAgISAgIDAADcC5LeAgABBACABQQhqQXBxQdiq1aoFcyIENgLgt4CAAEEAQQA2AvS3gIAAQQBBADYCxLeAgAALQQAgAjYCzLeAgABBAEGAuISAADYCyLeAgABBAEGAuISAADYCmLSAgABBACAENgKstICAAEEAQX82Aqi0gIAAA0AgA0HEtICAAGogA0G4tICAAGoiBDYCACAEIANBsLSAgABqIgU2AgAgA0G8tICAAGogBTYCACADQcy0gIAAaiADQcC0gIAAaiIFNgIAIAUgBDYCACADQdS0gIAAaiADQci0gIAAaiIENgIAIAQgBTYCACADQdC0gIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgLiEgABBeEGAuISAAGtBD3FBAEGAuISAAEEIakEPcRsiA2oiBEEEaiACIANrQUhqIgNBAXI2AgBBAEEAKALwt4CAADYCpLSAgABBACAENgKgtICAAEEAIAM2ApS0gIAAIAJBgLiEgABqQUxqQTg2AgALAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKItICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQAgA0EBcSAEckEBcyIFQQN0IgBBuLSAgABqKAIAIgRBCGohAwJA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AkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABQRhqIAQ2AgAgASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEYakEANgIAIAEgBDYCDCABIAA2AggLQQBBACgCqLSAgABBf2oiAUF/IAEbNgKotICAAAsLTgACQCAADQA/AEEQdA8LAkAgAEH//wNxDQAgAEF/TA0AAkAgAEEQdkAAIgBBf0cNAEEAQTA2Avi3gIAAQX8PCyAAQRB0DwsQv4CAgAAACwQAAAALC44sAQBBgAgLhiwBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHBhcmFtZXRlcnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AATUtBQ1RJVklUWQBDT1BZAE5PVElGWQBQTEFZAFBVVABDSEVDS09VVABQT1NUAFJFUE9SVABIUEVfSU5WQUxJRF9DT05TVEFOVABHRVQASFBFX1NUUklDVABSRURJUkVDVABDT05ORUNUAEhQRV9JTlZBTElEX1NUQVRVUwBPUFRJT05TAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAEhQRV9JTlZBTElEX1VSTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUAUEFVU0UAUFVSR0UATUVSR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABQUk9QRklORABVTkJJTkQAUkVCSU5EAEhQ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BQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv";
      }
    });
    var require_client = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/client.js"(exports2, module2) {
        "use strict";
        var assert2 = require("assert");
        var net2 = require("net");
        var util2 = require_util2();
        var Request2 = require_request();
        var DispatcherBase = require_dispatcher_base();
        var {
          RequestContentLengthMismatchError,
          ResponseContentLengthMismatchError,
          InvalidArgumentError,
          RequestAbortedError,
          HeadersTimeoutError,
          HeadersOverflowError,
          SocketError,
          InformationalError,
          BodyTimeoutError,
          HTTPParserError
        } = require_errors();
        var buildConnector = require_connect();
        var {
          kUrl,
          kReset,
          kServerName,
          kClient,
          kBusy,
          kParser,
          kConnect,
          kBlocking,
          kResuming,
          kRunning,
          kPending,
          kSize,
          kWriting,
          kQueue,
          kConnected,
          kConnecting,
          kNeedDrain,
          kNoRef,
          kKeepAliveDefaultTimeout,
          kHostHeader,
          kPendingIdx,
          kRunningIdx,
          kError,
          kPipelining,
          kSocket,
          kKeepAliveTimeoutValue,
          kMaxHeadersSize,
          kKeepAliveMaxTimeout,
          kKeepAliveTimeoutThreshold,
          kHeadersTimeout,
          kBodyTimeout,
          kStrictContentLength,
          kConnector,
          kMaxRedirections,
          kMaxRequests,
          kCounter,
          kClose,
          kDestroy,
          kDispatch,
          kInterceptors
        } = require_symbols();
        var kClosedResolve = Symbol("kClosedResolve");
        var channels = {};
        try {
          const diagnosticsChannel = require("diagnostics_channel");
          channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
          channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
          channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
          channels.connected = diagnosticsChannel.channel("undici:client:connected");
        } catch (e) {
          channels.sendHeaders = { hasSubscribers: false };
          channels.beforeConnect = { hasSubscribers: false };
          channels.connectError = { hasSubscribers: false };
          channels.connected = { hasSubscribers: false };
        }
        var Client = class extends DispatcherBase {
          constructor(url2, {
            interceptors,
            maxHeaderSize,
            headersTimeout,
            socketTimeout,
            requestTimeout,
            connectTimeout,
            bodyTimeout,
            idleTimeout,
            keepAlive,
            keepAliveTimeout,
            maxKeepAliveTimeout,
            keepAliveMaxTimeout,
            keepAliveTimeoutThreshold,
            socketPath,
            pipelining,
            tls,
            strictContentLength,
            maxCachedSessions,
            maxRedirections,
            connect: connect2,
            maxRequestsPerClient
          } = {}) {
            super();
            if (keepAlive !== void 0) {
              throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
            }
            if (socketTimeout !== void 0) {
              throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
            }
            if (requestTimeout !== void 0) {
              throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
            }
            if (idleTimeout !== void 0) {
              throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
            }
            if (maxKeepAliveTimeout !== void 0) {
              throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
            }
            if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
              throw new InvalidArgumentError("invalid maxHeaderSize");
            }
            if (socketPath != null && typeof socketPath !== "string") {
              throw new InvalidArgumentError("invalid socketPath");
            }
            if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
              throw new InvalidArgumentError("invalid connectTimeout");
            }
            if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
              throw new InvalidArgumentError("invalid keepAliveTimeout");
            }
            if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
              throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
            }
            if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
              throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
            }
            if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
              throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
            }
            if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
              throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
            }
            if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
              throw new InvalidArgumentError("connect must be a function or an object");
            }
            if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
              throw new InvalidArgumentError("maxRedirections must be a positive number");
            }
            if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
              throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
            }
            if (typeof connect2 !== "function") {
              connect2 = buildConnector({
                ...tls,
                maxCachedSessions,
                socketPath,
                timeout: connectTimeout,
                ...connect2
              });
            }
            this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
            this[kUrl] = util2.parseOrigin(url2);
            this[kConnector] = connect2;
            this[kSocket] = null;
            this[kPipelining] = pipelining != null ? pipelining : 1;
            this[kMaxHeadersSize] = maxHeaderSize || 16384;
            this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
            this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
            this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
            this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
            this[kServerName] = null;
            this[kResuming] = 0;
            this[kNeedDrain] = 0;
            this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
            this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;
            this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;
            this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
            this[kMaxRedirections] = maxRedirections;
            this[kMaxRequests] = maxRequestsPerClient;
            this[kClosedResolve] = null;
            this[kQueue] = [];
            this[kRunningIdx] = 0;
            this[kPendingIdx] = 0;
          }
          get pipelining() {
            return this[kPipelining];
          }
          set pipelining(value) {
            this[kPipelining] = value;
            resume(this, true);
          }
          get [kPending]() {
            return this[kQueue].length - this[kPendingIdx];
          }
          get [kRunning]() {
            return this[kPendingIdx] - this[kRunningIdx];
          }
          get [kSize]() {
            return this[kQueue].length - this[kRunningIdx];
          }
          get [kConnected]() {
            return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
          }
          get [kBusy]() {
            const socket = this[kSocket];
            return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
          }
          [kConnect](cb) {
            connect(this);
            this.once("connect", cb);
          }
          [kDispatch](opts, handler) {
            const origin = opts.origin || this[kUrl].origin;
            const request2 = new Request2(origin, opts, handler);
            this[kQueue].push(request2);
            if (this[kResuming]) {
            } else if (util2.bodyLength(request2.body) == null && util2.isIterable(request2.body)) {
              this[kResuming] = 1;
              process.nextTick(resume, this);
            } else {
              resume(this, true);
            }
            if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
              this[kNeedDrain] = 2;
            }
            return this[kNeedDrain] < 2;
          }
          async [kClose]() {
            return new Promise((resolve) => {
              if (!this[kSize]) {
                this.destroy(resolve);
              } else {
                this[kClosedResolve] = resolve;
              }
            });
          }
          async [kDestroy](err) {
            return new Promise((resolve) => {
              const requests = this[kQueue].splice(this[kPendingIdx]);
              for (let i = 0; i < requests.length; i++) {
                const request2 = requests[i];
                errorRequest(this, request2, err);
              }
              const callback = /* @__PURE__ */ __name(() => {
                if (this[kClosedResolve]) {
                  this[kClosedResolve]();
                  this[kClosedResolve] = null;
                }
                resolve();
              }, "callback");
              if (!this[kSocket]) {
                queueMicrotask(callback);
              } else {
                util2.destroy(this[kSocket].on("close", callback), err);
              }
              resume(this);
            });
          }
        };
        __name(Client, "Client");
        var constants = require_constants2();
        var createRedirectInterceptor = require_redirectInterceptor();
        var EMPTY_BUF = Buffer.alloc(0);
        async function lazyllhttp() {
          const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
          let mod2;
          try {
            mod2 = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
          } catch (e) {
            mod2 = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
          }
          return await WebAssembly.instantiate(mod2, {
            env: {
              wasm_on_url: (p, at, len) => {
                return 0;
              },
              wasm_on_status: (p, at, len) => {
                assert2.strictEqual(currentParser.ptr, p);
                const start = at - currentBufferPtr;
                const end = start + len;
                return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;
              },
              wasm_on_message_begin: (p) => {
                assert2.strictEqual(currentParser.ptr, p);
                return currentParser.onMessageBegin() || 0;
              },
              wasm_on_header_field: (p, at, len) => {
                assert2.strictEqual(currentParser.ptr, p);
                const start = at - currentBufferPtr;
                const end = start + len;
                return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;
              },
              wasm_on_header_value: (p, at, len) => {
                assert2.strictEqual(currentParser.ptr, p);
                const start = at - currentBufferPtr;
                const end = start + len;
                return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;
              },
              wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
                assert2.strictEqual(currentParser.ptr, p);
                return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
              },
              wasm_on_body: (p, at, len) => {
                assert2.strictEqual(currentParser.ptr, p);
                const start = at - currentBufferPtr;
                const end = start + len;
                return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;
              },
              wasm_on_message_complete: (p) => {
                assert2.strictEqual(currentParser.ptr, p);
                return currentParser.onMessageComplete() || 0;
              }
            }
          });
        }
        __name(lazyllhttp, "lazyllhttp");
        var llhttpInstance = null;
        var llhttpPromise = lazyllhttp().catch(() => {
        });
        var currentParser = null;
        var currentBufferRef = null;
        var currentBufferSize = 0;
        var currentBufferPtr = null;
        var TIMEOUT_HEADERS = 1;
        var TIMEOUT_BODY = 2;
        var TIMEOUT_IDLE = 3;
        var Parser = class {
          constructor(client2, socket, { exports: exports22 }) {
            assert2(Number.isFinite(client2[kMaxHeadersSize]) && client2[kMaxHeadersSize] > 0);
            this.llhttp = exports22;
            this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
            this.client = client2;
            this.socket = socket;
            this.timeout = null;
            this.timeoutValue = null;
            this.timeoutType = null;
            this.statusCode = null;
            this.statusText = "";
            this.upgrade = false;
            this.headers = [];
            this.headersSize = 0;
            this.headersMaxSize = client2[kMaxHeadersSize];
            this.shouldKeepAlive = false;
            this.paused = false;
            this.resume = this.resume.bind(this);
            this.bytesRead = 0;
            this.keepAlive = "";
            this.contentLength = "";
          }
          setTimeout(value, type) {
            this.timeoutType = type;
            if (value !== this.timeoutValue) {
              clearTimeout(this.timeout);
              if (value) {
                this.timeout = setTimeout(onParserTimeout, value, this);
                if (this.timeout.unref) {
                  this.timeout.unref();
                }
              } else {
                this.timeout = null;
              }
              this.timeoutValue = value;
            } else if (this.timeout) {
              if (this.timeout.refresh) {
                this.timeout.refresh();
              }
            }
          }
          resume() {
            if (this.socket.destroyed || !this.paused) {
              return;
            }
            assert2(this.ptr != null);
            assert2(currentParser == null);
            this.llhttp.llhttp_resume(this.ptr);
            assert2(this.timeoutType === TIMEOUT_BODY);
            if (this.timeout) {
              if (this.timeout.refresh) {
                this.timeout.refresh();
              }
            }
            this.paused = false;
            this.execute(this.socket.read() || EMPTY_BUF);
            this.readMore();
          }
          readMore() {
            while (!this.paused && this.ptr) {
              const chunk = this.socket.read();
              if (chunk === null) {
                break;
              }
              this.execute(chunk);
            }
          }
          execute(data) {
            assert2(this.ptr != null);
            assert2(currentParser == null);
            assert2(!this.paused);
            const { socket, llhttp } = this;
            if (data.length > currentBufferSize) {
              if (currentBufferPtr) {
                llhttp.free(currentBufferPtr);
              }
              currentBufferSize = Math.ceil(data.length / 4096) * 4096;
              currentBufferPtr = llhttp.malloc(currentBufferSize);
            }
            new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
            try {
              let ret;
              try {
                currentBufferRef = data;
                currentParser = this;
                ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
              } catch (err) {
                throw err;
              } finally {
                currentParser = null;
                currentBufferRef = null;
              }
              const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
              if (ret === constants.ERROR.PAUSED_UPGRADE) {
                this.onUpgrade(data.slice(offset));
              } else if (ret === constants.ERROR.PAUSED) {
                this.paused = true;
                socket.unshift(data.slice(offset));
              } else if (ret !== constants.ERROR.OK) {
                const ptr = llhttp.llhttp_get_error_reason(this.ptr);
                let message = "";
                if (ptr) {
                  const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
                  message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();
                }
                throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
              }
            } catch (err) {
              util2.destroy(socket, err);
            }
          }
          finish() {
            try {
              try {
                currentParser = this;
              } finally {
                currentParser = null;
              }
            } catch (err) {
              util2.destroy(this.socket, err);
            }
          }
          destroy() {
            assert2(this.ptr != null);
            assert2(currentParser == null);
            this.llhttp.llhttp_free(this.ptr);
            this.ptr = null;
            clearTimeout(this.timeout);
            this.timeout = null;
            this.timeoutValue = null;
            this.timeoutType = null;
            this.paused = false;
          }
          onStatus(buf) {
            this.statusText = buf.toString();
          }
          onMessageBegin() {
            const { socket, client: client2 } = this;
            if (socket.destroyed) {
              return -1;
            }
            const request2 = client2[kQueue][client2[kRunningIdx]];
            if (!request2) {
              return -1;
            }
          }
          onHeaderField(buf) {
            const len = this.headers.length;
            if ((len & 1) === 0) {
              this.headers.push(buf);
            } else {
              this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
            }
            this.trackHeader(buf.length);
          }
          onHeaderValue(buf) {
            let len = this.headers.length;
            if ((len & 1) === 1) {
              this.headers.push(buf);
              len += 1;
            } else {
              this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
            }
            const key = this.headers[len - 2];
            if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
              this.keepAlive += buf.toString();
            } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
              this.contentLength += buf.toString();
            }
            this.trackHeader(buf.length);
          }
          trackHeader(len) {
            this.headersSize += len;
            if (this.headersSize >= this.headersMaxSize) {
              util2.destroy(this.socket, new HeadersOverflowError());
            }
          }
          onUpgrade(head) {
            const { upgrade, client: client2, socket, headers, statusCode } = this;
            assert2(upgrade);
            const request2 = client2[kQueue][client2[kRunningIdx]];
            assert2(request2);
            assert2(!socket.destroyed);
            assert2(socket === client2[kSocket]);
            assert2(!this.paused);
            assert2(request2.upgrade || request2.method === "CONNECT");
            this.statusCode = null;
            this.statusText = "";
            this.shouldKeepAlive = null;
            assert2(this.headers.length % 2 === 0);
            this.headers = [];
            this.headersSize = 0;
            socket.unshift(head);
            socket[kParser].destroy();
            socket[kParser] = null;
            socket[kClient] = null;
            socket[kError] = null;
            socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
            client2[kSocket] = null;
            client2[kQueue][client2[kRunningIdx]++] = null;
            client2.emit("disconnect", client2[kUrl], [client2], new InformationalError("upgrade"));
            try {
              request2.onUpgrade(statusCode, headers, socket);
            } catch (err) {
              util2.destroy(socket, err);
            }
            resume(client2);
          }
          onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
            const { client: client2, socket, headers, statusText } = this;
            if (socket.destroyed) {
              return -1;
            }
            const request2 = client2[kQueue][client2[kRunningIdx]];
            if (!request2) {
              return -1;
            }
            assert2(!this.upgrade);
            assert2(this.statusCode < 200);
            if (statusCode === 100) {
              util2.destroy(socket, new SocketError("bad response", util2.getSocketInfo(socket)));
              return -1;
            }
            if (upgrade && !request2.upgrade) {
              util2.destroy(socket, new SocketError("bad upgrade", util2.getSocketInfo(socket)));
              return -1;
            }
            assert2.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
            this.statusCode = statusCode;
            this.shouldKeepAlive = shouldKeepAlive;
            if (this.statusCode >= 200) {
              const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client2[kBodyTimeout];
              this.setTimeout(bodyTimeout, TIMEOUT_BODY);
            } else if (this.timeout) {
              if (this.timeout.refresh) {
                this.timeout.refresh();
              }
            }
            if (request2.method === "CONNECT") {
              assert2(client2[kRunning] === 1);
              this.upgrade = true;
              return 2;
            }
            if (upgrade) {
              assert2(client2[kRunning] === 1);
              this.upgrade = true;
              return 2;
            }
            assert2(this.headers.length % 2 === 0);
            this.headers = [];
            this.headersSize = 0;
            if (shouldKeepAlive && client2[kPipelining]) {
              const keepAliveTimeout = this.keepAlive ? util2.parseKeepAliveTimeout(this.keepAlive) : null;
              if (keepAliveTimeout != null) {
                const timeout = Math.min(
                  keepAliveTimeout - client2[kKeepAliveTimeoutThreshold],
                  client2[kKeepAliveMaxTimeout]
                );
                if (timeout <= 0) {
                  socket[kReset] = true;
                } else {
                  client2[kKeepAliveTimeoutValue] = timeout;
                }
              } else {
                client2[kKeepAliveTimeoutValue] = client2[kKeepAliveDefaultTimeout];
              }
            } else {
              socket[kReset] = true;
            }
            let pause;
            try {
              pause = request2.onHeaders(statusCode, headers, this.resume, statusText) === false;
            } catch (err) {
              util2.destroy(socket, err);
              return -1;
            }
            if (request2.method === "HEAD") {
              assert2(socket[kReset]);
              return 1;
            }
            if (statusCode < 200) {
              return 1;
            }
            if (socket[kBlocking]) {
              socket[kBlocking] = false;
              resume(client2);
            }
            return pause ? constants.ERROR.PAUSED : 0;
          }
          onBody(buf) {
            const { client: client2, socket, statusCode } = this;
            if (socket.destroyed) {
              return -1;
            }
            const request2 = client2[kQueue][client2[kRunningIdx]];
            assert2(request2);
            assert2.strictEqual(this.timeoutType, TIMEOUT_BODY);
            if (this.timeout) {
              if (this.timeout.refresh) {
                this.timeout.refresh();
              }
            }
            assert2(statusCode >= 200);
            this.bytesRead += buf.length;
            try {
              if (request2.onData(buf) === false) {
                return constants.ERROR.PAUSED;
              }
            } catch (err) {
              util2.destroy(socket, err);
              return -1;
            }
          }
          onMessageComplete() {
            const { client: client2, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
            if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
              return -1;
            }
            if (upgrade) {
              return;
            }
            const request2 = client2[kQueue][client2[kRunningIdx]];
            assert2(request2);
            assert2(statusCode >= 100);
            this.statusCode = null;
            this.statusText = "";
            this.bytesRead = 0;
            this.contentLength = "";
            this.keepAlive = "";
            assert2(this.headers.length % 2 === 0);
            this.headers = [];
            this.headersSize = 0;
            if (statusCode < 200) {
              return;
            }
            if (request2.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
              util2.destroy(socket, new ResponseContentLengthMismatchError());
              return -1;
            }
            try {
              request2.onComplete(headers);
            } catch (err) {
              errorRequest(client2, request2, err);
            }
            client2[kQueue][client2[kRunningIdx]++] = null;
            if (socket[kWriting]) {
              assert2.strictEqual(client2[kRunning], 0);
              util2.destroy(socket, new InformationalError("reset"));
              return constants.ERROR.PAUSED;
            } else if (!shouldKeepAlive) {
              util2.destroy(socket, new InformationalError("reset"));
              return constants.ERROR.PAUSED;
            } else if (socket[kReset] && client2[kRunning] === 0) {
              util2.destroy(socket, new InformationalError("reset"));
              return constants.ERROR.PAUSED;
            } else if (client2[kPipelining] === 1) {
              setImmediate(resume, client2);
            } else {
              resume(client2);
            }
          }
        };
        __name(Parser, "Parser");
        function onParserTimeout(parser) {
          const { socket, timeoutType, client: client2 } = parser;
          if (timeoutType === TIMEOUT_HEADERS) {
            if (!socket[kWriting] || socket.writableNeedDrain || client2[kRunning] > 1) {
              assert2(!parser.paused, "cannot be paused while waiting for headers");
              util2.destroy(socket, new HeadersTimeoutError());
            }
          } else if (timeoutType === TIMEOUT_BODY) {
            if (!parser.paused) {
              util2.destroy(socket, new BodyTimeoutError());
            }
          } else if (timeoutType === TIMEOUT_IDLE) {
            assert2(client2[kRunning] === 0 && client2[kKeepAliveTimeoutValue]);
            util2.destroy(socket, new InformationalError("socket idle timeout"));
          }
        }
        __name(onParserTimeout, "onParserTimeout");
        function onSocketReadable() {
          const { [kParser]: parser } = this;
          parser.readMore();
        }
        __name(onSocketReadable, "onSocketReadable");
        function onSocketError(err) {
          const { [kParser]: parser } = this;
          assert2(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
          if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
            parser.finish();
            return;
          }
          this[kError] = err;
          onError(this[kClient], err);
        }
        __name(onSocketError, "onSocketError");
        function onError(client2, err) {
          if (client2[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
            assert2(client2[kPendingIdx] === client2[kRunningIdx]);
            const requests = client2[kQueue].splice(client2[kRunningIdx]);
            for (let i = 0; i < requests.length; i++) {
              const request2 = requests[i];
              errorRequest(client2, request2, err);
            }
            assert2(client2[kSize] === 0);
          }
        }
        __name(onError, "onError");
        function onSocketEnd() {
          const { [kParser]: parser } = this;
          if (parser.statusCode && !parser.shouldKeepAlive) {
            parser.finish();
            return;
          }
          util2.destroy(this, new SocketError("other side closed", util2.getSocketInfo(this)));
        }
        __name(onSocketEnd, "onSocketEnd");
        function onSocketClose() {
          const { [kClient]: client2 } = this;
          this[kParser].destroy();
          this[kParser] = null;
          const err = this[kError] || new SocketError("closed", util2.getSocketInfo(this));
          client2[kSocket] = null;
          if (client2.destroyed) {
            assert2(client2[kPending] === 0);
            const requests = client2[kQueue].splice(client2[kRunningIdx]);
            for (let i = 0; i < requests.length; i++) {
              const request2 = requests[i];
              errorRequest(client2, request2, err);
            }
          } else if (client2[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
            const request2 = client2[kQueue][client2[kRunningIdx]];
            client2[kQueue][client2[kRunningIdx]++] = null;
            errorRequest(client2, request2, err);
          }
          client2[kPendingIdx] = client2[kRunningIdx];
          assert2(client2[kRunning] === 0);
          client2.emit("disconnect", client2[kUrl], [client2], err);
          resume(client2);
        }
        __name(onSocketClose, "onSocketClose");
        async function connect(client2) {
          assert2(!client2[kConnecting]);
          assert2(!client2[kSocket]);
          let { host, hostname: hostname3, protocol, port } = client2[kUrl];
          if (hostname3[0] === "[") {
            const idx = hostname3.indexOf("]");
            assert2(idx !== -1);
            const ip = hostname3.substr(1, idx - 1);
            assert2(net2.isIP(ip));
            hostname3 = ip;
          }
          client2[kConnecting] = true;
          if (channels.beforeConnect.hasSubscribers) {
            channels.beforeConnect.publish({
              connectParams: {
                host,
                hostname: hostname3,
                protocol,
                port,
                servername: client2[kServerName]
              },
              connector: client2[kConnector]
            });
          }
          try {
            const socket = await new Promise((resolve, reject) => {
              client2[kConnector]({
                host,
                hostname: hostname3,
                protocol,
                port,
                servername: client2[kServerName]
              }, (err, socket2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(socket2);
                }
              });
            });
            if (!llhttpInstance) {
              llhttpInstance = await llhttpPromise;
              llhttpPromise = null;
            }
            client2[kConnecting] = false;
            assert2(socket);
            client2[kSocket] = socket;
            socket[kNoRef] = false;
            socket[kWriting] = false;
            socket[kReset] = false;
            socket[kBlocking] = false;
            socket[kError] = null;
            socket[kParser] = new Parser(client2, socket, llhttpInstance);
            socket[kClient] = client2;
            socket[kCounter] = 0;
            socket[kMaxRequests] = client2[kMaxRequests];
            socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
            if (channels.connected.hasSubscribers) {
              channels.connected.publish({
                connectParams: {
                  host,
                  hostname: hostname3,
                  protocol,
                  port,
                  servername: client2[kServerName]
                },
                connector: client2[kConnector],
                socket
              });
            }
            client2.emit("connect", client2[kUrl], [client2]);
          } catch (err) {
            client2[kConnecting] = false;
            if (channels.connectError.hasSubscribers) {
              channels.connectError.publish({
                connectParams: {
                  host,
                  hostname: hostname3,
                  protocol,
                  port,
                  servername: client2[kServerName]
                },
                connector: client2[kConnector],
                error: err
              });
            }
            if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
              assert2(client2[kRunning] === 0);
              while (client2[kPending] > 0 && client2[kQueue][client2[kPendingIdx]].servername === client2[kServerName]) {
                const request2 = client2[kQueue][client2[kPendingIdx]++];
                errorRequest(client2, request2, err);
              }
            } else {
              onError(client2, err);
            }
            client2.emit("connectionError", client2[kUrl], [client2], err);
          }
          resume(client2);
        }
        __name(connect, "connect");
        function emitDrain(client2) {
          client2[kNeedDrain] = 0;
          client2.emit("drain", client2[kUrl], [client2]);
        }
        __name(emitDrain, "emitDrain");
        function resume(client2, sync) {
          if (client2[kResuming] === 2) {
            return;
          }
          client2[kResuming] = 2;
          _resume(client2, sync);
          client2[kResuming] = 0;
          if (client2[kRunningIdx] > 256) {
            client2[kQueue].splice(0, client2[kRunningIdx]);
            client2[kPendingIdx] -= client2[kRunningIdx];
            client2[kRunningIdx] = 0;
          }
        }
        __name(resume, "resume");
        function _resume(client2, sync) {
          while (true) {
            if (client2.destroyed) {
              assert2(client2[kPending] === 0);
              return;
            }
            if (client2.closed && !client2[kSize]) {
              client2.destroy();
              return;
            }
            const socket = client2[kSocket];
            if (socket) {
              if (client2[kSize] === 0) {
                if (!socket[kNoRef] && socket.unref) {
                  socket.unref();
                  socket[kNoRef] = true;
                }
              } else if (socket[kNoRef] && socket.ref) {
                socket.ref();
                socket[kNoRef] = false;
              }
              if (client2[kSize] === 0) {
                if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
                  socket[kParser].setTimeout(client2[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
                }
              } else if (client2[kRunning] > 0 && socket[kParser].statusCode < 200) {
                if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
                  const request3 = client2[kQueue][client2[kRunningIdx]];
                  const headersTimeout = request3.headersTimeout != null ? request3.headersTimeout : client2[kHeadersTimeout];
                  socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
                }
              }
            }
            if (client2[kBusy]) {
              client2[kNeedDrain] = 2;
            } else if (client2[kNeedDrain] === 2) {
              if (sync) {
                client2[kNeedDrain] = 1;
                process.nextTick(emitDrain, client2);
              } else {
                emitDrain(client2);
              }
              continue;
            }
            if (client2[kPending] === 0) {
              return;
            }
            if (client2[kRunning] >= (client2[kPipelining] || 1)) {
              return;
            }
            const request2 = client2[kQueue][client2[kPendingIdx]];
            if (client2[kUrl].protocol === "https:" && client2[kServerName] !== request2.servername) {
              if (client2[kRunning] > 0) {
                return;
              }
              client2[kServerName] = request2.servername;
              if (socket && socket.servername !== request2.servername) {
                util2.destroy(socket, new InformationalError("servername changed"));
                return;
              }
            }
            if (client2[kConnecting]) {
              return;
            }
            if (!socket) {
              connect(client2);
              continue;
            }
            if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
              return;
            }
            if (client2[kRunning] > 0 && !request2.idempotent) {
              return;
            }
            if (client2[kRunning] > 0 && (request2.upgrade || request2.method === "CONNECT")) {
              return;
            }
            if (util2.isStream(request2.body) && util2.bodyLength(request2.body) === 0) {
              request2.body.on("data", function() {
                assert2(false);
              }).on("error", function(err) {
                errorRequest(client2, request2, err);
              }).on("end", function() {
                util2.destroy(this);
              });
              request2.body = null;
            }
            if (client2[kRunning] > 0 && (util2.isStream(request2.body) || util2.isAsyncIterable(request2.body))) {
              return;
            }
            if (!request2.aborted && write(client2, request2)) {
              client2[kPendingIdx]++;
            } else {
              client2[kQueue].splice(client2[kPendingIdx], 1);
            }
          }
        }
        __name(_resume, "_resume");
        function write(client2, request2) {
          const { body, method, path: path7, host, upgrade, headers, blocking } = request2;
          const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
          if (body && typeof body.read === "function") {
            body.read(0);
          }
          let contentLength = util2.bodyLength(body);
          if (contentLength === null) {
            contentLength = request2.contentLength;
          }
          if (contentLength === 0 && !expectsPayload) {
            contentLength = null;
          }
          if (request2.contentLength !== null && request2.contentLength !== contentLength) {
            if (client2[kStrictContentLength]) {
              errorRequest(client2, request2, new RequestContentLengthMismatchError());
              return false;
            }
            process.emitWarning(new RequestContentLengthMismatchError());
          }
          const socket = client2[kSocket];
          try {
            request2.onConnect((err) => {
              if (request2.aborted || request2.completed) {
                return;
              }
              errorRequest(client2, request2, err || new RequestAbortedError());
              util2.destroy(socket, new InformationalError("aborted"));
            });
          } catch (err) {
            errorRequest(client2, request2, err);
          }
          if (request2.aborted) {
            return false;
          }
          if (method === "HEAD") {
            socket[kReset] = true;
          }
          if (upgrade || method === "CONNECT") {
            socket[kReset] = true;
          }
          if (client2[kMaxRequests] && socket[kCounter]++ >= client2[kMaxRequests]) {
            socket[kReset] = true;
          }
          if (blocking) {
            socket[kBlocking] = true;
          }
          let header = `${method} ${path7} HTTP/1.1\r
`;
          if (typeof host === "string") {
            header += `host: ${host}\r
`;
          } else {
            header += client2[kHostHeader];
          }
          if (upgrade) {
            header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
          } else if (client2[kPipelining]) {
            header += "connection: keep-alive\r\n";
          } else {
            header += "connection: close\r\n";
          }
          if (headers) {
            header += headers;
          }
          if (channels.sendHeaders.hasSubscribers) {
            channels.sendHeaders.publish({ request: request2, headers: header, socket });
          }
          if (!body) {
            if (contentLength === 0) {
              socket.write(`${header}content-length: 0\r
\r
`, "ascii");
            } else {
              assert2(contentLength === null, "no body must not have content length");
              socket.write(`${header}\r
`, "ascii");
            }
            request2.onRequestSent();
          } else if (util2.isBuffer(body)) {
            assert2(contentLength === body.byteLength, "buffer body must have content length");
            socket.cork();
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
            socket.write(body);
            socket.uncork();
            request2.onBodySent(body);
            request2.onRequestSent();
            if (!expectsPayload) {
              socket[kReset] = true;
            }
          } else if (util2.isBlobLike(body)) {
            if (typeof body.stream === "function") {
              writeIterable({ body: body.stream(), client: client2, request: request2, socket, contentLength, header, expectsPayload });
            } else {
              writeBlob({ body, client: client2, request: request2, socket, contentLength, header, expectsPayload });
            }
          } else if (util2.isStream(body)) {
            writeStream({ body, client: client2, request: request2, socket, contentLength, header, expectsPayload });
          } else if (util2.isIterable(body)) {
            writeIterable({ body, client: client2, request: request2, socket, contentLength, header, expectsPayload });
          } else {
            assert2(false);
          }
          return true;
        }
        __name(write, "write");
        function writeStream({ body, client: client2, request: request2, socket, contentLength, header, expectsPayload }) {
          assert2(contentLength !== 0 || client2[kRunning] === 0, "stream body cannot be pipelined");
          let finished = false;
          const writer = new AsyncWriter({ socket, request: request2, contentLength, client: client2, expectsPayload, header });
          const onData = /* @__PURE__ */ __name(function(chunk) {
            try {
              assert2(!finished);
              if (!writer.write(chunk) && this.pause) {
                this.pause();
              }
            } catch (err) {
              util2.destroy(this, err);
            }
          }, "onData");
          const onDrain = /* @__PURE__ */ __name(function() {
            assert2(!finished);
            if (body.resume) {
              body.resume();
            }
          }, "onDrain");
          const onAbort = /* @__PURE__ */ __name(function() {
            onFinished(new RequestAbortedError());
          }, "onAbort");
          const onFinished = /* @__PURE__ */ __name(function(err) {
            if (finished) {
              return;
            }
            finished = true;
            assert2(socket.destroyed || socket[kWriting] && client2[kRunning] <= 1);
            socket.off("drain", onDrain).off("error", onFinished);
            body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
            if (!err) {
              try {
                writer.end();
              } catch (er) {
                err = er;
              }
            }
            writer.destroy(err);
            if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
              util2.destroy(body, err);
            } else {
              util2.destroy(body);
            }
          }, "onFinished");
          body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
          if (body.resume) {
            body.resume();
          }
          socket.on("drain", onDrain).on("error", onFinished);
        }
        __name(writeStream, "writeStream");
        async function writeBlob({ body, client: client2, request: request2, socket, contentLength, header, expectsPayload }) {
          assert2(contentLength === body.size, "blob body must have content length");
          try {
            if (contentLength != null && contentLength !== body.size) {
              throw new RequestContentLengthMismatchError();
            }
            const buffer = Buffer.from(await body.arrayBuffer());
            socket.cork();
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
            socket.write(buffer);
            socket.uncork();
            request2.onBodySent(buffer);
            request2.onRequestSent();
            if (!expectsPayload) {
              socket[kReset] = true;
            }
            resume(client2);
          } catch (err) {
            util2.destroy(socket, err);
          }
        }
        __name(writeBlob, "writeBlob");
        async function writeIterable({ body, client: client2, request: request2, socket, contentLength, header, expectsPayload }) {
          assert2(contentLength !== 0 || client2[kRunning] === 0, "iterator body cannot be pipelined");
          let callback = null;
          function onDrain() {
            if (callback) {
              const cb = callback;
              callback = null;
              cb();
            }
          }
          __name(onDrain, "onDrain");
          const waitForDrain = /* @__PURE__ */ __name(() => new Promise((resolve, reject) => {
            assert2(callback === null);
            if (socket[kError]) {
              reject(socket[kError]);
            } else {
              callback = resolve;
            }
          }), "waitForDrain");
          socket.on("close", onDrain).on("drain", onDrain);
          const writer = new AsyncWriter({ socket, request: request2, contentLength, client: client2, expectsPayload, header });
          try {
            for await (const chunk of body) {
              if (socket[kError]) {
                throw socket[kError];
              }
              if (!writer.write(chunk)) {
                await waitForDrain();
              }
            }
            writer.end();
          } catch (err) {
            writer.destroy(err);
          } finally {
            socket.off("close", onDrain).off("drain", onDrain);
          }
        }
        __name(writeIterable, "writeIterable");
        var AsyncWriter = class {
          constructor({ socket, request: request2, contentLength, client: client2, expectsPayload, header }) {
            this.socket = socket;
            this.request = request2;
            this.contentLength = contentLength;
            this.client = client2;
            this.bytesWritten = 0;
            this.expectsPayload = expectsPayload;
            this.header = header;
            socket[kWriting] = true;
          }
          write(chunk) {
            const { socket, request: request2, contentLength, client: client2, bytesWritten, expectsPayload, header } = this;
            if (socket[kError]) {
              throw socket[kError];
            }
            if (socket.destroyed) {
              return false;
            }
            const len = Buffer.byteLength(chunk);
            if (!len) {
              return true;
            }
            if (contentLength !== null && bytesWritten + len > contentLength) {
              if (client2[kStrictContentLength]) {
                throw new RequestContentLengthMismatchError();
              }
              process.emitWarning(new RequestContentLengthMismatchError());
            }
            if (bytesWritten === 0) {
              if (!expectsPayload) {
                socket[kReset] = true;
              }
              if (contentLength === null) {
                socket.write(`${header}transfer-encoding: chunked\r
`, "ascii");
              } else {
                socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
              }
            }
            if (contentLength === null) {
              socket.write(`\r
${len.toString(16)}\r
`, "ascii");
            }
            this.bytesWritten += len;
            const ret = socket.write(chunk);
            request2.onBodySent(chunk);
            if (!ret) {
              if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
                if (socket[kParser].timeout.refresh) {
                  socket[kParser].timeout.refresh();
                }
              }
            }
            return ret;
          }
          end() {
            const { socket, contentLength, client: client2, bytesWritten, expectsPayload, header, request: request2 } = this;
            request2.onRequestSent();
            socket[kWriting] = false;
            if (socket[kError]) {
              throw socket[kError];
            }
            if (socket.destroyed) {
              return;
            }
            if (bytesWritten === 0) {
              if (expectsPayload) {
                socket.write(`${header}content-length: 0\r
\r
`, "ascii");
              } else {
                socket.write(`${header}\r
`, "ascii");
              }
            } else if (contentLength === null) {
              socket.write("\r\n0\r\n\r\n", "ascii");
            }
            if (contentLength !== null && bytesWritten !== contentLength) {
              if (client2[kStrictContentLength]) {
                throw new RequestContentLengthMismatchError();
              } else {
                process.emitWarning(new RequestContentLengthMismatchError());
              }
            }
            if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
              if (socket[kParser].timeout.refresh) {
                socket[kParser].timeout.refresh();
              }
            }
            resume(client2);
          }
          destroy(err) {
            const { socket, client: client2 } = this;
            socket[kWriting] = false;
            if (err) {
              assert2(client2[kRunning] <= 1, "pipeline should only contain this request");
              util2.destroy(socket, err);
            }
          }
        };
        __name(AsyncWriter, "AsyncWriter");
        function errorRequest(client2, request2, err) {
          try {
            request2.onError(err);
            assert2(request2.aborted);
          } catch (err2) {
            client2.emit("error", err2);
          }
        }
        __name(errorRequest, "errorRequest");
        module2.exports = Client;
      }
    });
    var require_fixed_queue = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
        "use strict";
        var kSize = 2048;
        var kMask = kSize - 1;
        var FixedCircularBuffer = class {
          constructor() {
            this.bottom = 0;
            this.top = 0;
            this.list = new Array(kSize);
            this.next = null;
          }
          isEmpty() {
            return this.top === this.bottom;
          }
          isFull() {
            return (this.top + 1 & kMask) === this.bottom;
          }
          push(data) {
            this.list[this.top] = data;
            this.top = this.top + 1 & kMask;
          }
          shift() {
            const nextItem = this.list[this.bottom];
            if (nextItem === void 0)
              return null;
            this.list[this.bottom] = void 0;
            this.bottom = this.bottom + 1 & kMask;
            return nextItem;
          }
        };
        __name(FixedCircularBuffer, "FixedCircularBuffer");
        module2.exports = /* @__PURE__ */ __name(class FixedQueue {
          constructor() {
            this.head = this.tail = new FixedCircularBuffer();
          }
          isEmpty() {
            return this.head.isEmpty();
          }
          push(data) {
            if (this.head.isFull()) {
              this.head = this.head.next = new FixedCircularBuffer();
            }
            this.head.push(data);
          }
          shift() {
            const tail = this.tail;
            const next = tail.shift();
            if (tail.isEmpty() && tail.next !== null) {
              this.tail = tail.next;
            }
            return next;
          }
        }, "FixedQueue");
      }
    });
    var require_pool_stats = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/pool-stats.js"(exports2, module2) {
        var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
        var kPool = Symbol("pool");
        var PoolStats = class {
          constructor(pool) {
            this[kPool] = pool;
          }
          get connected() {
            return this[kPool][kConnected];
          }
          get free() {
            return this[kPool][kFree];
          }
          get pending() {
            return this[kPool][kPending];
          }
          get queued() {
            return this[kPool][kQueued];
          }
          get running() {
            return this[kPool][kRunning];
          }
          get size() {
            return this[kPool][kSize];
          }
        };
        __name(PoolStats, "PoolStats");
        module2.exports = PoolStats;
      }
    });
    var require_pool_base = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/pool-base.js"(exports2, module2) {
        "use strict";
        var DispatcherBase = require_dispatcher_base();
        var FixedQueue = require_fixed_queue();
        var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
        var PoolStats = require_pool_stats();
        var kClients = Symbol("clients");
        var kNeedDrain = Symbol("needDrain");
        var kQueue = Symbol("queue");
        var kClosedResolve = Symbol("closed resolve");
        var kOnDrain = Symbol("onDrain");
        var kOnConnect = Symbol("onConnect");
        var kOnDisconnect = Symbol("onDisconnect");
        var kOnConnectionError = Symbol("onConnectionError");
        var kGetDispatcher = Symbol("get dispatcher");
        var kAddClient = Symbol("add client");
        var kRemoveClient = Symbol("remove client");
        var kStats = Symbol("stats");
        var PoolBase = class extends DispatcherBase {
          constructor() {
            super();
            this[kQueue] = new FixedQueue();
            this[kClients] = [];
            this[kQueued] = 0;
            const pool = this;
            this[kOnDrain] = /* @__PURE__ */ __name(function onDrain(origin, targets) {
              const queue = pool[kQueue];
              let needDrain = false;
              while (!needDrain) {
                const item = queue.shift();
                if (!item) {
                  break;
                }
                pool[kQueued]--;
                needDrain = !this.dispatch(item.opts, item.handler);
              }
              this[kNeedDrain] = needDrain;
              if (!this[kNeedDrain] && pool[kNeedDrain]) {
                pool[kNeedDrain] = false;
                pool.emit("drain", origin, [pool, ...targets]);
              }
              if (pool[kClosedResolve] && queue.isEmpty()) {
                Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
              }
            }, "onDrain");
            this[kOnConnect] = (origin, targets) => {
              pool.emit("connect", origin, [pool, ...targets]);
            };
            this[kOnDisconnect] = (origin, targets, err) => {
              pool.emit("disconnect", origin, [pool, ...targets], err);
            };
            this[kOnConnectionError] = (origin, targets, err) => {
              pool.emit("connectionError", origin, [pool, ...targets], err);
            };
            this[kStats] = new PoolStats(this);
          }
          get [kBusy]() {
            return this[kNeedDrain];
          }
          get [kConnected]() {
            return this[kClients].filter((client2) => client2[kConnected]).length;
          }
          get [kFree]() {
            return this[kClients].filter((client2) => client2[kConnected] && !client2[kNeedDrain]).length;
          }
          get [kPending]() {
            let ret = this[kQueued];
            for (const { [kPending]: pending } of this[kClients]) {
              ret += pending;
            }
            return ret;
          }
          get [kRunning]() {
            let ret = 0;
            for (const { [kRunning]: running } of this[kClients]) {
              ret += running;
            }
            return ret;
          }
          get [kSize]() {
            let ret = this[kQueued];
            for (const { [kSize]: size } of this[kClients]) {
              ret += size;
            }
            return ret;
          }
          get stats() {
            return this[kStats];
          }
          async [kClose]() {
            if (this[kQueue].isEmpty()) {
              return Promise.all(this[kClients].map((c) => c.close()));
            } else {
              return new Promise((resolve) => {
                this[kClosedResolve] = resolve;
              });
            }
          }
          async [kDestroy](err) {
            while (true) {
              const item = this[kQueue].shift();
              if (!item) {
                break;
              }
              item.handler.onError(err);
            }
            return Promise.all(this[kClients].map((c) => c.destroy(err)));
          }
          [kDispatch](opts, handler) {
            const dispatcher = this[kGetDispatcher]();
            if (!dispatcher) {
              this[kNeedDrain] = true;
              this[kQueue].push({ opts, handler });
              this[kQueued]++;
            } else if (!dispatcher.dispatch(opts, handler)) {
              dispatcher[kNeedDrain] = true;
              this[kNeedDrain] = !this[kGetDispatcher]();
            }
            return !this[kNeedDrain];
          }
          [kAddClient](client2) {
            client2.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
            this[kClients].push(client2);
            if (this[kNeedDrain]) {
              process.nextTick(() => {
                if (this[kNeedDrain]) {
                  this[kOnDrain](client2[kUrl], [this, client2]);
                }
              });
            }
            return this;
          }
          [kRemoveClient](client2) {
            client2.close(() => {
              const idx = this[kClients].indexOf(client2);
              if (idx !== -1) {
                this[kClients].splice(idx, 1);
              }
            });
            this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
          }
        };
        __name(PoolBase, "PoolBase");
        module2.exports = {
          PoolBase,
          kClients,
          kNeedDrain,
          kAddClient,
          kRemoveClient,
          kGetDispatcher
        };
      }
    });
    var require_pool = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/pool.js"(exports2, module2) {
        "use strict";
        var {
          PoolBase,
          kClients,
          kNeedDrain,
          kAddClient,
          kGetDispatcher
        } = require_pool_base();
        var Client = require_client();
        var {
          InvalidArgumentError
        } = require_errors();
        var util2 = require_util2();
        var { kUrl, kInterceptors } = require_symbols();
        var buildConnector = require_connect();
        var kOptions = Symbol("options");
        var kConnections = Symbol("connections");
        var kFactory = Symbol("factory");
        function defaultFactory(origin, opts) {
          return new Client(origin, opts);
        }
        __name(defaultFactory, "defaultFactory");
        var Pool = class extends PoolBase {
          constructor(origin, {
            connections,
            factory = defaultFactory,
            connect,
            connectTimeout,
            tls,
            maxCachedSessions,
            socketPath,
            ...options
          } = {}) {
            super();
            if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
              throw new InvalidArgumentError("invalid connections");
            }
            if (typeof factory !== "function") {
              throw new InvalidArgumentError("factory must be a function.");
            }
            if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
              throw new InvalidArgumentError("connect must be a function or an object");
            }
            if (typeof connect !== "function") {
              connect = buildConnector({
                ...tls,
                maxCachedSessions,
                socketPath,
                timeout: connectTimeout == null ? 1e4 : connectTimeout,
                ...connect
              });
            }
            this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
            this[kConnections] = connections || null;
            this[kUrl] = util2.parseOrigin(origin);
            this[kOptions] = { ...util2.deepClone(options), connect };
            this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
            this[kFactory] = factory;
          }
          [kGetDispatcher]() {
            let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
            if (dispatcher) {
              return dispatcher;
            }
            if (!this[kConnections] || this[kClients].length < this[kConnections]) {
              dispatcher = this[kFactory](this[kUrl], this[kOptions]);
              this[kAddClient](dispatcher);
            }
            return dispatcher;
          }
        };
        __name(Pool, "Pool");
        module2.exports = Pool;
      }
    });
    var require_balanced_pool = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
        "use strict";
        var {
          BalancedPoolMissingUpstreamError,
          InvalidArgumentError
        } = require_errors();
        var {
          PoolBase,
          kClients,
          kNeedDrain,
          kAddClient,
          kRemoveClient,
          kGetDispatcher
        } = require_pool_base();
        var Pool = require_pool();
        var { kUrl, kInterceptors } = require_symbols();
        var { parseOrigin } = require_util2();
        var kFactory = Symbol("factory");
        var kOptions = Symbol("options");
        var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
        var kCurrentWeight = Symbol("kCurrentWeight");
        var kIndex = Symbol("kIndex");
        var kWeight = Symbol("kWeight");
        var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
        var kErrorPenalty = Symbol("kErrorPenalty");
        function getGreatestCommonDivisor(a, b) {
          if (b === 0)
            return a;
          return getGreatestCommonDivisor(b, a % b);
        }
        __name(getGreatestCommonDivisor, "getGreatestCommonDivisor");
        function defaultFactory(origin, opts) {
          return new Pool(origin, opts);
        }
        __name(defaultFactory, "defaultFactory");
        var BalancedPool = class extends PoolBase {
          constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
            super();
            this[kOptions] = opts;
            this[kIndex] = -1;
            this[kCurrentWeight] = 0;
            this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
            this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
            if (!Array.isArray(upstreams)) {
              upstreams = [upstreams];
            }
            if (typeof factory !== "function") {
              throw new InvalidArgumentError("factory must be a function.");
            }
            this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
            this[kFactory] = factory;
            for (const upstream of upstreams) {
              this.addUpstream(upstream);
            }
            this._updateBalancedPoolStats();
          }
          addUpstream(upstream) {
            const upstreamOrigin = parseOrigin(upstream).origin;
            if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
              return this;
            }
            const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
            this[kAddClient](pool);
            pool.on("connect", () => {
              pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
            });
            pool.on("connectionError", () => {
              pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
              this._updateBalancedPoolStats();
            });
            pool.on("disconnect", (...args) => {
              const err = args[2];
              if (err && err.code === "UND_ERR_SOCKET") {
                pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
                this._updateBalancedPoolStats();
              }
            });
            for (const client2 of this[kClients]) {
              client2[kWeight] = this[kMaxWeightPerServer];
            }
            this._updateBalancedPoolStats();
            return this;
          }
          _updateBalancedPoolStats() {
            this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
          }
          removeUpstream(upstream) {
            const upstreamOrigin = parseOrigin(upstream).origin;
            const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
            if (pool) {
              this[kRemoveClient](pool);
            }
            return this;
          }
          get upstreams() {
            return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
          }
          [kGetDispatcher]() {
            if (this[kClients].length === 0) {
              throw new BalancedPoolMissingUpstreamError();
            }
            const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
            if (!dispatcher) {
              return;
            }
            const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
            if (allClientsBusy) {
              return;
            }
            let counter = 0;
            let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
            while (counter++ < this[kClients].length) {
              this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
              const pool = this[kClients][this[kIndex]];
              if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
                maxWeightIndex = this[kIndex];
              }
              if (this[kIndex] === 0) {
                this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
                if (this[kCurrentWeight] <= 0) {
                  this[kCurrentWeight] = this[kMaxWeightPerServer];
                }
              }
              if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
                return pool;
              }
            }
            this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
            this[kIndex] = maxWeightIndex;
            return this[kClients][maxWeightIndex];
          }
        };
        __name(BalancedPool, "BalancedPool");
        module2.exports = BalancedPool;
      }
    });
    var require_dispatcher_weakref = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
        "use strict";
        var { kConnected, kSize } = require_symbols();
        var CompatWeakRef = class {
          constructor(value) {
            this.value = value;
          }
          deref() {
            return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
          }
        };
        __name(CompatWeakRef, "CompatWeakRef");
        var CompatFinalizer = class {
          constructor(finalizer) {
            this.finalizer = finalizer;
          }
          register(dispatcher, key) {
            dispatcher.on("disconnect", () => {
              if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
                this.finalizer(key);
              }
            });
          }
        };
        __name(CompatFinalizer, "CompatFinalizer");
        module2.exports = function() {
          return {
            WeakRef: global.WeakRef || CompatWeakRef,
            FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
          };
        };
      }
    });
    var require_agent = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/agent.js"(exports2, module2) {
        "use strict";
        var { InvalidArgumentError } = require_errors();
        var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
        var DispatcherBase = require_dispatcher_base();
        var Pool = require_pool();
        var Client = require_client();
        var util2 = require_util2();
        var createRedirectInterceptor = require_redirectInterceptor();
        var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
        var kOnConnect = Symbol("onConnect");
        var kOnDisconnect = Symbol("onDisconnect");
        var kOnConnectionError = Symbol("onConnectionError");
        var kMaxRedirections = Symbol("maxRedirections");
        var kOnDrain = Symbol("onDrain");
        var kFactory = Symbol("factory");
        var kFinalizer = Symbol("finalizer");
        var kOptions = Symbol("options");
        function defaultFactory(origin, opts) {
          return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
        }
        __name(defaultFactory, "defaultFactory");
        var Agent = class extends DispatcherBase {
          constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
            super();
            if (typeof factory !== "function") {
              throw new InvalidArgumentError("factory must be a function.");
            }
            if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
              throw new InvalidArgumentError("connect must be a function or an object");
            }
            if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
              throw new InvalidArgumentError("maxRedirections must be a positive number");
            }
            if (connect && typeof connect !== "function") {
              connect = { ...connect };
            }
            this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
            this[kOptions] = { ...util2.deepClone(options), connect };
            this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
            this[kMaxRedirections] = maxRedirections;
            this[kFactory] = factory;
            this[kClients] = /* @__PURE__ */ new Map();
            this[kFinalizer] = new FinalizationRegistry((key) => {
              const ref = this[kClients].get(key);
              if (ref !== void 0 && ref.deref() === void 0) {
                this[kClients].delete(key);
              }
            });
            const agent = this;
            this[kOnDrain] = (origin, targets) => {
              agent.emit("drain", origin, [agent, ...targets]);
            };
            this[kOnConnect] = (origin, targets) => {
              agent.emit("connect", origin, [agent, ...targets]);
            };
            this[kOnDisconnect] = (origin, targets, err) => {
              agent.emit("disconnect", origin, [agent, ...targets], err);
            };
            this[kOnConnectionError] = (origin, targets, err) => {
              agent.emit("connectionError", origin, [agent, ...targets], err);
            };
          }
          get [kRunning]() {
            let ret = 0;
            for (const ref of this[kClients].values()) {
              const client2 = ref.deref();
              if (client2) {
                ret += client2[kRunning];
              }
            }
            return ret;
          }
          [kDispatch](opts, handler) {
            let key;
            if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
              key = String(opts.origin);
            } else {
              throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
            }
            const ref = this[kClients].get(key);
            let dispatcher = ref ? ref.deref() : null;
            if (!dispatcher) {
              dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
              this[kClients].set(key, new WeakRef2(dispatcher));
              this[kFinalizer].register(dispatcher, key);
            }
            return dispatcher.dispatch(opts, handler);
          }
          async [kClose]() {
            const closePromises = [];
            for (const ref of this[kClients].values()) {
              const client2 = ref.deref();
              if (client2) {
                closePromises.push(client2.close());
              }
            }
            await Promise.all(closePromises);
          }
          async [kDestroy](err) {
            const destroyPromises = [];
            for (const ref of this[kClients].values()) {
              const client2 = ref.deref();
              if (client2) {
                destroyPromises.push(client2.destroy(err));
              }
            }
            await Promise.all(destroyPromises);
          }
        };
        __name(Agent, "Agent");
        module2.exports = Agent;
      }
    });
    var require_readable = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/api/readable.js"(exports2, module2) {
        "use strict";
        var assert2 = require("assert");
        var { Readable } = require("stream");
        var { RequestAbortedError, NotSupportedError } = require_errors();
        var util2 = require_util2();
        var { ReadableStreamFrom, toUSVString } = require_util2();
        var Blob2;
        var kConsume = Symbol("kConsume");
        var kReading = Symbol("kReading");
        var kBody = Symbol("kBody");
        var kAbort = Symbol("abort");
        var kContentType = Symbol("kContentType");
        module2.exports = /* @__PURE__ */ __name(class BodyReadable extends Readable {
          constructor(resume, abort, contentType = "") {
            super({
              autoDestroy: true,
              read: resume,
              highWaterMark: 64 * 1024
            });
            this._readableState.dataEmitted = false;
            this[kAbort] = abort;
            this[kConsume] = null;
            this[kBody] = null;
            this[kContentType] = contentType;
            this[kReading] = false;
          }
          destroy(err) {
            if (this.destroyed) {
              return this;
            }
            if (!err && !this._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (err) {
              this[kAbort]();
            }
            return super.destroy(err);
          }
          emit(ev, ...args) {
            if (ev === "data") {
              this._readableState.dataEmitted = true;
            } else if (ev === "error") {
              this._readableState.errorEmitted = true;
            }
            return super.emit(ev, ...args);
          }
          on(ev, ...args) {
            if (ev === "data" || ev === "readable") {
              this[kReading] = true;
            }
            return super.on(ev, ...args);
          }
          addListener(ev, ...args) {
            return this.on(ev, ...args);
          }
          off(ev, ...args) {
            const ret = super.off(ev, ...args);
            if (ev === "data" || ev === "readable") {
              this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
            }
            return ret;
          }
          removeListener(ev, ...args) {
            return this.off(ev, ...args);
          }
          push(chunk) {
            if (this[kConsume] && chunk !== null && this.readableLength === 0) {
              consumePush(this[kConsume], chunk);
              return this[kReading] ? super.push(chunk) : true;
            }
            return super.push(chunk);
          }
          async text() {
            return consume(this, "text");
          }
          async json() {
            return consume(this, "json");
          }
          async blob() {
            return consume(this, "blob");
          }
          async arrayBuffer() {
            return consume(this, "arrayBuffer");
          }
          async formData() {
            throw new NotSupportedError();
          }
          get bodyUsed() {
            return util2.isDisturbed(this);
          }
          get body() {
            if (!this[kBody]) {
              this[kBody] = ReadableStreamFrom(this);
              if (this[kConsume]) {
                this[kBody].getReader();
                assert2(this[kBody].locked);
              }
            }
            return this[kBody];
          }
          async dump(opts) {
            let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
            try {
              for await (const chunk of this) {
                limit -= Buffer.byteLength(chunk);
                if (limit < 0) {
                  return;
                }
              }
            } catch (e) {
            }
          }
        }, "BodyReadable");
        function isLocked(self2) {
          return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
        }
        __name(isLocked, "isLocked");
        function isUnusable(self2) {
          return util2.isDisturbed(self2) || isLocked(self2);
        }
        __name(isUnusable, "isUnusable");
        async function consume(stream22, type) {
          if (isUnusable(stream22)) {
            throw new TypeError("unusable");
          }
          assert2(!stream22[kConsume]);
          return new Promise((resolve, reject) => {
            stream22[kConsume] = {
              type,
              stream: stream22,
              resolve,
              reject,
              length: 0,
              body: []
            };
            stream22.on("error", function(err) {
              consumeFinish(this[kConsume], err);
            }).on("close", function() {
              if (this[kConsume].body !== null) {
                consumeFinish(this[kConsume], new RequestAbortedError());
              }
            });
            process.nextTick(consumeStart, stream22[kConsume]);
          });
        }
        __name(consume, "consume");
        function consumeStart(consume2) {
          if (consume2.body === null) {
            return;
          }
          const { _readableState: state } = consume2.stream;
          for (const chunk of state.buffer) {
            consumePush(consume2, chunk);
          }
          if (state.endEmitted) {
            consumeEnd(this[kConsume]);
          } else {
            consume2.stream.on("end", function() {
              consumeEnd(this[kConsume]);
            });
          }
          consume2.stream.resume();
          while (consume2.stream.read() != null) {
          }
        }
        __name(consumeStart, "consumeStart");
        function consumeEnd(consume2) {
          const { type, body, resolve, stream: stream22, length } = consume2;
          try {
            if (type === "text") {
              resolve(toUSVString(Buffer.concat(body)));
            } else if (type === "json") {
              resolve(JSON.parse(Buffer.concat(body)));
            } else if (type === "arrayBuffer") {
              const dst = new Uint8Array(length);
              let pos = 0;
              for (const buf of body) {
                dst.set(buf, pos);
                pos += buf.byteLength;
              }
              resolve(dst);
            } else if (type === "blob") {
              if (!Blob2) {
                Blob2 = require("buffer").Blob;
              }
              resolve(new Blob2(body, { type: stream22[kContentType] }));
            }
            consumeFinish(consume2);
          } catch (err) {
            stream22.destroy(err);
          }
        }
        __name(consumeEnd, "consumeEnd");
        function consumePush(consume2, chunk) {
          consume2.length += chunk.length;
          consume2.body.push(chunk);
        }
        __name(consumePush, "consumePush");
        function consumeFinish(consume2, err) {
          if (consume2.body === null) {
            return;
          }
          if (err) {
            consume2.reject(err);
          } else {
            consume2.resolve();
          }
          consume2.type = null;
          consume2.stream = null;
          consume2.resolve = null;
          consume2.reject = null;
          consume2.length = 0;
          consume2.body = null;
        }
        __name(consumeFinish, "consumeFinish");
      }
    });
    var require_abort_signal = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
        var { RequestAbortedError } = require_errors();
        var kListener = Symbol("kListener");
        var kSignal = Symbol("kSignal");
        function abort(self2) {
          if (self2.abort) {
            self2.abort();
          } else {
            self2.onError(new RequestAbortedError());
          }
        }
        __name(abort, "abort");
        function addSignal(self2, signal) {
          self2[kSignal] = null;
          self2[kListener] = null;
          if (!signal) {
            return;
          }
          if (signal.aborted) {
            abort(self2);
            return;
          }
          self2[kSignal] = signal;
          self2[kListener] = () => {
            abort(self2);
          };
          if ("addEventListener" in self2[kSignal]) {
            self2[kSignal].addEventListener("abort", self2[kListener]);
          } else {
            self2[kSignal].addListener("abort", self2[kListener]);
          }
        }
        __name(addSignal, "addSignal");
        function removeSignal(self2) {
          if (!self2[kSignal]) {
            return;
          }
          if ("removeEventListener" in self2[kSignal]) {
            self2[kSignal].removeEventListener("abort", self2[kListener]);
          } else {
            self2[kSignal].removeListener("abort", self2[kListener]);
          }
          self2[kSignal] = null;
          self2[kListener] = null;
        }
        __name(removeSignal, "removeSignal");
        module2.exports = {
          addSignal,
          removeSignal
        };
      }
    });
    var require_api_request = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/api/api-request.js"(exports2, module2) {
        "use strict";
        var Readable = require_readable();
        var {
          InvalidArgumentError,
          RequestAbortedError,
          ResponseStatusCodeError
        } = require_errors();
        var util2 = require_util2();
        var { AsyncResource: AsyncResource2 } = require("async_hooks");
        var { addSignal, removeSignal } = require_abort_signal();
        var RequestHandler2 = class extends AsyncResource2 {
          constructor(opts, callback) {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
            try {
              if (typeof callback !== "function") {
                throw new InvalidArgumentError("invalid callback");
              }
              if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
                throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
              }
              if (method === "CONNECT") {
                throw new InvalidArgumentError("invalid method");
              }
              if (onInfo && typeof onInfo !== "function") {
                throw new InvalidArgumentError("invalid onInfo callback");
              }
              super("UNDICI_REQUEST");
            } catch (err) {
              if (util2.isStream(body)) {
                util2.destroy(body.on("error", util2.nop), err);
              }
              throw err;
            }
            this.responseHeaders = responseHeaders || null;
            this.opaque = opaque || null;
            this.callback = callback;
            this.res = null;
            this.abort = null;
            this.body = body;
            this.trailers = {};
            this.context = null;
            this.onInfo = onInfo || null;
            this.throwOnError = throwOnError;
            if (util2.isStream(body)) {
              body.on("error", (err) => {
                this.onError(err);
              });
            }
            addSignal(this, signal);
          }
          onConnect(abort, context3) {
            if (!this.callback) {
              throw new RequestAbortedError();
            }
            this.abort = abort;
            this.context = context3;
          }
          onHeaders(statusCode, rawHeaders, resume, statusMessage) {
            const { callback, opaque, abort, context: context3 } = this;
            if (statusCode < 200) {
              if (this.onInfo) {
                const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
                this.onInfo({ statusCode, headers: headers2 });
              }
              return;
            }
            const parsedHeaders = util2.parseHeaders(rawHeaders);
            const contentType = parsedHeaders["content-type"];
            const body = new Readable(resume, abort, contentType);
            this.callback = null;
            this.res = body;
            const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            if (callback !== null) {
              if (this.throwOnError && statusCode >= 400) {
                this.runInAsyncScope(
                  getResolveErrorBodyCallback,
                  null,
                  { callback, body, contentType, statusCode, statusMessage, headers }
                );
                return;
              }
              this.runInAsyncScope(callback, null, null, {
                statusCode,
                headers,
                trailers: this.trailers,
                opaque,
                body,
                context: context3
              });
            }
          }
          onData(chunk) {
            const { res } = this;
            return res.push(chunk);
          }
          onComplete(trailers) {
            const { res } = this;
            removeSignal(this);
            util2.parseHeaders(trailers, this.trailers);
            res.push(null);
          }
          onError(err) {
            const { res, callback, body, opaque } = this;
            removeSignal(this);
            if (callback) {
              this.callback = null;
              queueMicrotask(() => {
                this.runInAsyncScope(callback, null, err, { opaque });
              });
            }
            if (res) {
              this.res = null;
              queueMicrotask(() => {
                util2.destroy(res, err);
              });
            }
            if (body) {
              this.body = null;
              util2.destroy(body, err);
            }
          }
        };
        __name(RequestHandler2, "RequestHandler");
        async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
          if (statusCode === 204 || !contentType) {
            body.dump();
            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
            return;
          }
          try {
            if (contentType.startsWith("application/json")) {
              const payload = await body.json();
              process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
              return;
            }
            if (contentType.startsWith("text/")) {
              const payload = await body.text();
              process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
              return;
            }
          } catch (err) {
          }
          body.dump();
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        }
        __name(getResolveErrorBodyCallback, "getResolveErrorBodyCallback");
        function request2(opts, callback) {
          if (callback === void 0) {
            return new Promise((resolve, reject) => {
              request2.call(this, opts, (err, data) => {
                return err ? reject(err) : resolve(data);
              });
            });
          }
          try {
            this.dispatch(opts, new RequestHandler2(opts, callback));
          } catch (err) {
            if (typeof callback !== "function") {
              throw err;
            }
            const opaque = opts && opts.opaque;
            queueMicrotask(() => callback(err, { opaque }));
          }
        }
        __name(request2, "request");
        module2.exports = request2;
      }
    });
    var require_api_stream = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
        "use strict";
        var { finished } = require("stream");
        var {
          InvalidArgumentError,
          InvalidReturnValueError,
          RequestAbortedError
        } = require_errors();
        var util2 = require_util2();
        var { AsyncResource: AsyncResource2 } = require("async_hooks");
        var { addSignal, removeSignal } = require_abort_signal();
        var StreamHandler = class extends AsyncResource2 {
          constructor(opts, factory, callback) {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            const { signal, method, opaque, body, onInfo, responseHeaders } = opts;
            try {
              if (typeof callback !== "function") {
                throw new InvalidArgumentError("invalid callback");
              }
              if (typeof factory !== "function") {
                throw new InvalidArgumentError("invalid factory");
              }
              if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
                throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
              }
              if (method === "CONNECT") {
                throw new InvalidArgumentError("invalid method");
              }
              if (onInfo && typeof onInfo !== "function") {
                throw new InvalidArgumentError("invalid onInfo callback");
              }
              super("UNDICI_STREAM");
            } catch (err) {
              if (util2.isStream(body)) {
                util2.destroy(body.on("error", util2.nop), err);
              }
              throw err;
            }
            this.responseHeaders = responseHeaders || null;
            this.opaque = opaque || null;
            this.factory = factory;
            this.callback = callback;
            this.res = null;
            this.abort = null;
            this.context = null;
            this.trailers = null;
            this.body = body;
            this.onInfo = onInfo || null;
            if (util2.isStream(body)) {
              body.on("error", (err) => {
                this.onError(err);
              });
            }
            addSignal(this, signal);
          }
          onConnect(abort, context3) {
            if (!this.callback) {
              throw new RequestAbortedError();
            }
            this.abort = abort;
            this.context = context3;
          }
          onHeaders(statusCode, rawHeaders, resume) {
            const { factory, opaque, context: context3 } = this;
            if (statusCode < 200) {
              if (this.onInfo) {
                const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
                this.onInfo({ statusCode, headers: headers2 });
              }
              return;
            }
            this.factory = null;
            const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            const res = this.runInAsyncScope(factory, null, {
              statusCode,
              headers,
              opaque,
              context: context3
            });
            if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
              throw new InvalidReturnValueError("expected Writable");
            }
            res.on("drain", resume);
            finished(res, { readable: false }, (err) => {
              const { callback, res: res2, opaque: opaque2, trailers, abort } = this;
              this.res = null;
              if (err || !res2.readable) {
                util2.destroy(res2, err);
              }
              this.callback = null;
              this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
              if (err) {
                abort();
              }
            });
            this.res = res;
            const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
            return needDrain !== true;
          }
          onData(chunk) {
            const { res } = this;
            return res.write(chunk);
          }
          onComplete(trailers) {
            const { res } = this;
            removeSignal(this);
            this.trailers = util2.parseHeaders(trailers);
            res.end();
          }
          onError(err) {
            const { res, callback, opaque, body } = this;
            removeSignal(this);
            this.factory = null;
            if (res) {
              this.res = null;
              util2.destroy(res, err);
            } else if (callback) {
              this.callback = null;
              queueMicrotask(() => {
                this.runInAsyncScope(callback, null, err, { opaque });
              });
            }
            if (body) {
              this.body = null;
              util2.destroy(body, err);
            }
          }
        };
        __name(StreamHandler, "StreamHandler");
        function stream22(opts, factory, callback) {
          if (callback === void 0) {
            return new Promise((resolve, reject) => {
              stream22.call(this, opts, factory, (err, data) => {
                return err ? reject(err) : resolve(data);
              });
            });
          }
          try {
            this.dispatch(opts, new StreamHandler(opts, factory, callback));
          } catch (err) {
            if (typeof callback !== "function") {
              throw err;
            }
            const opaque = opts && opts.opaque;
            queueMicrotask(() => callback(err, { opaque }));
          }
        }
        __name(stream22, "stream");
        module2.exports = stream22;
      }
    });
    var require_api_pipeline = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
        "use strict";
        var {
          Readable,
          Duplex: Duplex2,
          PassThrough
        } = require("stream");
        var {
          InvalidArgumentError,
          InvalidReturnValueError,
          RequestAbortedError
        } = require_errors();
        var util2 = require_util2();
        var { AsyncResource: AsyncResource2 } = require("async_hooks");
        var { addSignal, removeSignal } = require_abort_signal();
        var assert2 = require("assert");
        var kResume = Symbol("resume");
        var PipelineRequest = class extends Readable {
          constructor() {
            super({ autoDestroy: true });
            this[kResume] = null;
          }
          _read() {
            const { [kResume]: resume } = this;
            if (resume) {
              this[kResume] = null;
              resume();
            }
          }
          _destroy(err, callback) {
            this._read();
            callback(err);
          }
        };
        __name(PipelineRequest, "PipelineRequest");
        var PipelineResponse = class extends Readable {
          constructor(resume) {
            super({ autoDestroy: true });
            this[kResume] = resume;
          }
          _read() {
            this[kResume]();
          }
          _destroy(err, callback) {
            if (!err && !this._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            callback(err);
          }
        };
        __name(PipelineResponse, "PipelineResponse");
        var PipelineHandler = class extends AsyncResource2 {
          constructor(opts, handler) {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            if (typeof handler !== "function") {
              throw new InvalidArgumentError("invalid handler");
            }
            const { signal, method, opaque, onInfo, responseHeaders } = opts;
            if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
              throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
            }
            if (method === "CONNECT") {
              throw new InvalidArgumentError("invalid method");
            }
            if (onInfo && typeof onInfo !== "function") {
              throw new InvalidArgumentError("invalid onInfo callback");
            }
            super("UNDICI_PIPELINE");
            this.opaque = opaque || null;
            this.responseHeaders = responseHeaders || null;
            this.handler = handler;
            this.abort = null;
            this.context = null;
            this.onInfo = onInfo || null;
            this.req = new PipelineRequest().on("error", util2.nop);
            this.ret = new Duplex2({
              readableObjectMode: opts.objectMode,
              autoDestroy: true,
              read: () => {
                const { body } = this;
                if (body && body.resume) {
                  body.resume();
                }
              },
              write: (chunk, encoding, callback) => {
                const { req } = this;
                if (req.push(chunk, encoding) || req._readableState.destroyed) {
                  callback();
                } else {
                  req[kResume] = callback;
                }
              },
              destroy: (err, callback) => {
                const { body, req, res, ret, abort } = this;
                if (!err && !ret._readableState.endEmitted) {
                  err = new RequestAbortedError();
                }
                if (abort && err) {
                  abort();
                }
                util2.destroy(body, err);
                util2.destroy(req, err);
                util2.destroy(res, err);
                removeSignal(this);
                callback(err);
              }
            }).on("prefinish", () => {
              const { req } = this;
              req.push(null);
            });
            this.res = null;
            addSignal(this, signal);
          }
          onConnect(abort, context3) {
            const { ret, res } = this;
            assert2(!res, "pipeline cannot be retried");
            if (ret.destroyed) {
              throw new RequestAbortedError();
            }
            this.abort = abort;
            this.context = context3;
          }
          onHeaders(statusCode, rawHeaders, resume) {
            const { opaque, handler, context: context3 } = this;
            if (statusCode < 200) {
              if (this.onInfo) {
                const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
                this.onInfo({ statusCode, headers });
              }
              return;
            }
            this.res = new PipelineResponse(resume);
            let body;
            try {
              this.handler = null;
              const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
              body = this.runInAsyncScope(handler, null, {
                statusCode,
                headers,
                opaque,
                body: this.res,
                context: context3
              });
            } catch (err) {
              this.res.on("error", util2.nop);
              throw err;
            }
            if (!body || typeof body.on !== "function") {
              throw new InvalidReturnValueError("expected Readable");
            }
            body.on("data", (chunk) => {
              const { ret, body: body2 } = this;
              if (!ret.push(chunk) && body2.pause) {
                body2.pause();
              }
            }).on("error", (err) => {
              const { ret } = this;
              util2.destroy(ret, err);
            }).on("end", () => {
              const { ret } = this;
              ret.push(null);
            }).on("close", () => {
              const { ret } = this;
              if (!ret._readableState.ended) {
                util2.destroy(ret, new RequestAbortedError());
              }
            });
            this.body = body;
          }
          onData(chunk) {
            const { res } = this;
            return res.push(chunk);
          }
          onComplete(trailers) {
            const { res } = this;
            res.push(null);
          }
          onError(err) {
            const { ret } = this;
            this.handler = null;
            util2.destroy(ret, err);
          }
        };
        __name(PipelineHandler, "PipelineHandler");
        function pipeline(opts, handler) {
          try {
            const pipelineHandler = new PipelineHandler(opts, handler);
            this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
            return pipelineHandler.ret;
          } catch (err) {
            return new PassThrough().destroy(err);
          }
        }
        __name(pipeline, "pipeline");
        module2.exports = pipeline;
      }
    });
    var require_api_upgrade = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
        "use strict";
        var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
        var { AsyncResource: AsyncResource2 } = require("async_hooks");
        var util2 = require_util2();
        var { addSignal, removeSignal } = require_abort_signal();
        var assert2 = require("assert");
        var UpgradeHandler = class extends AsyncResource2 {
          constructor(opts, callback) {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            if (typeof callback !== "function") {
              throw new InvalidArgumentError("invalid callback");
            }
            const { signal, opaque, responseHeaders } = opts;
            if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
              throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
            }
            super("UNDICI_UPGRADE");
            this.responseHeaders = responseHeaders || null;
            this.opaque = opaque || null;
            this.callback = callback;
            this.abort = null;
            this.context = null;
            addSignal(this, signal);
          }
          onConnect(abort, context3) {
            if (!this.callback) {
              throw new RequestAbortedError();
            }
            this.abort = abort;
            this.context = null;
          }
          onHeaders() {
            throw new SocketError("bad upgrade", null);
          }
          onUpgrade(statusCode, rawHeaders, socket) {
            const { callback, opaque, context: context3 } = this;
            assert2.strictEqual(statusCode, 101);
            removeSignal(this);
            this.callback = null;
            const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            this.runInAsyncScope(callback, null, null, {
              headers,
              socket,
              opaque,
              context: context3
            });
          }
          onError(err) {
            const { callback, opaque } = this;
            removeSignal(this);
            if (callback) {
              this.callback = null;
              queueMicrotask(() => {
                this.runInAsyncScope(callback, null, err, { opaque });
              });
            }
          }
        };
        __name(UpgradeHandler, "UpgradeHandler");
        function upgrade(opts, callback) {
          if (callback === void 0) {
            return new Promise((resolve, reject) => {
              upgrade.call(this, opts, (err, data) => {
                return err ? reject(err) : resolve(data);
              });
            });
          }
          try {
            const upgradeHandler = new UpgradeHandler(opts, callback);
            this.dispatch({
              ...opts,
              method: opts.method || "GET",
              upgrade: opts.protocol || "Websocket"
            }, upgradeHandler);
          } catch (err) {
            if (typeof callback !== "function") {
              throw err;
            }
            const opaque = opts && opts.opaque;
            queueMicrotask(() => callback(err, { opaque }));
          }
        }
        __name(upgrade, "upgrade");
        module2.exports = upgrade;
      }
    });
    var require_api_connect = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
        "use strict";
        var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
        var { AsyncResource: AsyncResource2 } = require("async_hooks");
        var util2 = require_util2();
        var { addSignal, removeSignal } = require_abort_signal();
        var ConnectHandler = class extends AsyncResource2 {
          constructor(opts, callback) {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            if (typeof callback !== "function") {
              throw new InvalidArgumentError("invalid callback");
            }
            const { signal, opaque, responseHeaders } = opts;
            if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
              throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
            }
            super("UNDICI_CONNECT");
            this.opaque = opaque || null;
            this.responseHeaders = responseHeaders || null;
            this.callback = callback;
            this.abort = null;
            addSignal(this, signal);
          }
          onConnect(abort, context3) {
            if (!this.callback) {
              throw new RequestAbortedError();
            }
            this.abort = abort;
            this.context = context3;
          }
          onHeaders() {
            throw new SocketError("bad connect", null);
          }
          onUpgrade(statusCode, rawHeaders, socket) {
            const { callback, opaque, context: context3 } = this;
            removeSignal(this);
            this.callback = null;
            const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              socket,
              opaque,
              context: context3
            });
          }
          onError(err) {
            const { callback, opaque } = this;
            removeSignal(this);
            if (callback) {
              this.callback = null;
              queueMicrotask(() => {
                this.runInAsyncScope(callback, null, err, { opaque });
              });
            }
          }
        };
        __name(ConnectHandler, "ConnectHandler");
        function connect(opts, callback) {
          if (callback === void 0) {
            return new Promise((resolve, reject) => {
              connect.call(this, opts, (err, data) => {
                return err ? reject(err) : resolve(data);
              });
            });
          }
          try {
            const connectHandler = new ConnectHandler(opts, callback);
            this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
          } catch (err) {
            if (typeof callback !== "function") {
              throw err;
            }
            const opaque = opts && opts.opaque;
            queueMicrotask(() => callback(err, { opaque }));
          }
        }
        __name(connect, "connect");
        module2.exports = connect;
      }
    });
    var require_api = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/api/index.js"(exports2, module2) {
        "use strict";
        module2.exports.request = require_api_request();
        module2.exports.stream = require_api_stream();
        module2.exports.pipeline = require_api_pipeline();
        module2.exports.upgrade = require_api_upgrade();
        module2.exports.connect = require_api_connect();
      }
    });
    var require_mock_errors = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
        "use strict";
        var { UndiciError } = require_errors();
        var MockNotMatchedError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, MockNotMatchedError);
            this.name = "MockNotMatchedError";
            this.message = message || "The request does not match any registered mock dispatches";
            this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
          }
        };
        __name(MockNotMatchedError, "MockNotMatchedError");
        module2.exports = {
          MockNotMatchedError
        };
      }
    });
    var require_mock_symbols = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
        "use strict";
        module2.exports = {
          kAgent: Symbol("agent"),
          kOptions: Symbol("options"),
          kFactory: Symbol("factory"),
          kDispatches: Symbol("dispatches"),
          kDispatchKey: Symbol("dispatch key"),
          kDefaultHeaders: Symbol("default headers"),
          kDefaultTrailers: Symbol("default trailers"),
          kContentLength: Symbol("content length"),
          kMockAgent: Symbol("mock agent"),
          kMockAgentSet: Symbol("mock agent set"),
          kMockAgentGet: Symbol("mock agent get"),
          kMockDispatch: Symbol("mock dispatch"),
          kClose: Symbol("close"),
          kOriginalClose: Symbol("original agent close"),
          kOrigin: Symbol("origin"),
          kIsMockActive: Symbol("is mock active"),
          kNetConnect: Symbol("net connect"),
          kGetNetConnect: Symbol("get net connect"),
          kConnected: Symbol("connected")
        };
      }
    });
    var require_mock_utils = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
        "use strict";
        var { MockNotMatchedError } = require_mock_errors();
        var {
          kDispatches,
          kMockAgent,
          kOriginalDispatch,
          kOrigin,
          kGetNetConnect
        } = require_mock_symbols();
        var { buildURL: buildURL2, nop } = require_util2();
        var { STATUS_CODES } = require("http");
        function matchValue(match, value) {
          if (typeof match === "string") {
            return match === value;
          }
          if (match instanceof RegExp) {
            return match.test(value);
          }
          if (typeof match === "function") {
            return match(value) === true;
          }
          return false;
        }
        __name(matchValue, "matchValue");
        function lowerCaseEntries(headers) {
          return Object.fromEntries(
            Object.entries(headers).map(([headerName, headerValue]) => {
              return [headerName.toLocaleLowerCase(), headerValue];
            })
          );
        }
        __name(lowerCaseEntries, "lowerCaseEntries");
        function getHeaderByName(headers, key) {
          if (Array.isArray(headers)) {
            for (let i = 0; i < headers.length; i += 2) {
              if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
                return headers[i + 1];
              }
            }
            return void 0;
          } else if (typeof headers.get === "function") {
            return headers.get(key);
          } else {
            return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
          }
        }
        __name(getHeaderByName, "getHeaderByName");
        function buildHeadersFromArray(headers) {
          const clone2 = headers.slice();
          const entries2 = [];
          for (let index = 0; index < clone2.length; index += 2) {
            entries2.push([clone2[index], clone2[index + 1]]);
          }
          return Object.fromEntries(entries2);
        }
        __name(buildHeadersFromArray, "buildHeadersFromArray");
        function matchHeaders(mockDispatch2, headers) {
          if (typeof mockDispatch2.headers === "function") {
            if (Array.isArray(headers)) {
              headers = buildHeadersFromArray(headers);
            }
            return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
          }
          if (typeof mockDispatch2.headers === "undefined") {
            return true;
          }
          if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
            return false;
          }
          for (const [matchHeaderName, matchHeaderValue2] of Object.entries(mockDispatch2.headers)) {
            const headerValue = getHeaderByName(headers, matchHeaderName);
            if (!matchValue(matchHeaderValue2, headerValue)) {
              return false;
            }
          }
          return true;
        }
        __name(matchHeaders, "matchHeaders");
        function safeUrl(path7) {
          if (typeof path7 !== "string") {
            return path7;
          }
          const pathSegments = path7.split("?");
          if (pathSegments.length !== 2) {
            return path7;
          }
          const qp = new URLSearchParams(pathSegments.pop());
          qp.sort();
          return [...pathSegments, qp.toString()].join("?");
        }
        __name(safeUrl, "safeUrl");
        function matchKey(mockDispatch2, { path: path7, method, body, headers }) {
          const pathMatch = matchValue(mockDispatch2.path, path7);
          const methodMatch = matchValue(mockDispatch2.method, method);
          const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
          const headersMatch = matchHeaders(mockDispatch2, headers);
          return pathMatch && methodMatch && bodyMatch && headersMatch;
        }
        __name(matchKey, "matchKey");
        function getResponseData(data) {
          if (Buffer.isBuffer(data)) {
            return data;
          } else if (typeof data === "object") {
            return JSON.stringify(data);
          } else {
            return data.toString();
          }
        }
        __name(getResponseData, "getResponseData");
        function getMockDispatch(mockDispatches, key) {
          const basePath = key.query ? buildURL2(key.path, key.query) : key.path;
          const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
          let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path7 }) => matchValue(safeUrl(path7), resolvedPath));
          if (matchedMockDispatches.length === 0) {
            throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
          }
          matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
          if (matchedMockDispatches.length === 0) {
            throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
          }
          matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
          if (matchedMockDispatches.length === 0) {
            throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
          }
          matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
          if (matchedMockDispatches.length === 0) {
            throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
          }
          return matchedMockDispatches[0];
        }
        __name(getMockDispatch, "getMockDispatch");
        function addMockDispatch(mockDispatches, key, data) {
          const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
          const replyData = typeof data === "function" ? { callback: data } : { ...data };
          const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
          mockDispatches.push(newMockDispatch);
          return newMockDispatch;
        }
        __name(addMockDispatch, "addMockDispatch");
        function deleteMockDispatch(mockDispatches, key) {
          const index = mockDispatches.findIndex((dispatch) => {
            if (!dispatch.consumed) {
              return false;
            }
            return matchKey(dispatch, key);
          });
          if (index !== -1) {
            mockDispatches.splice(index, 1);
          }
        }
        __name(deleteMockDispatch, "deleteMockDispatch");
        function buildKey(opts) {
          const { path: path7, method, body, headers, query: query2 } = opts;
          return {
            path: path7,
            method,
            body,
            headers,
            query: query2
          };
        }
        __name(buildKey, "buildKey");
        function generateKeyValues(data) {
          return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], []);
        }
        __name(generateKeyValues, "generateKeyValues");
        function getStatusText(statusCode) {
          return STATUS_CODES[statusCode] || "unknown";
        }
        __name(getStatusText, "getStatusText");
        async function getResponse(body) {
          const buffers = [];
          for await (const data of body) {
            buffers.push(data);
          }
          return Buffer.concat(buffers).toString("utf8");
        }
        __name(getResponse, "getResponse");
        function mockDispatch(opts, handler) {
          const key = buildKey(opts);
          const mockDispatch2 = getMockDispatch(this[kDispatches], key);
          mockDispatch2.timesInvoked++;
          if (mockDispatch2.data.callback) {
            mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
          }
          const { data: { statusCode, data, headers, trailers, error: error2 }, delay: delay2, persist } = mockDispatch2;
          const { timesInvoked, times } = mockDispatch2;
          mockDispatch2.consumed = !persist && timesInvoked >= times;
          mockDispatch2.pending = timesInvoked < times;
          if (error2 !== null) {
            deleteMockDispatch(this[kDispatches], key);
            handler.onError(error2);
            return true;
          }
          if (typeof delay2 === "number" && delay2 > 0) {
            setTimeout(() => {
              handleReply(this[kDispatches]);
            }, delay2);
          } else {
            handleReply(this[kDispatches]);
          }
          function handleReply(mockDispatches) {
            const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
            const responseData = getResponseData(
              typeof data === "function" ? data({ ...opts, headers: optsHeaders }) : data
            );
            const responseHeaders = generateKeyValues(headers);
            const responseTrailers = generateKeyValues(trailers);
            handler.abort = nop;
            handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
            handler.onData(Buffer.from(responseData));
            handler.onComplete(responseTrailers);
            deleteMockDispatch(mockDispatches, key);
          }
          __name(handleReply, "handleReply");
          function resume() {
          }
          __name(resume, "resume");
          return true;
        }
        __name(mockDispatch, "mockDispatch");
        function buildMockDispatch() {
          const agent = this[kMockAgent];
          const origin = this[kOrigin];
          const originalDispatch = this[kOriginalDispatch];
          return /* @__PURE__ */ __name(function dispatch(opts, handler) {
            if (agent.isMockActive) {
              try {
                mockDispatch.call(this, opts, handler);
              } catch (error2) {
                if (error2 instanceof MockNotMatchedError) {
                  const netConnect = agent[kGetNetConnect]();
                  if (netConnect === false) {
                    throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
                  }
                  if (checkNetConnect(netConnect, origin)) {
                    originalDispatch.call(this, opts, handler);
                  } else {
                    throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
                  }
                } else {
                  throw error2;
                }
              }
            } else {
              originalDispatch.call(this, opts, handler);
            }
          }, "dispatch");
        }
        __name(buildMockDispatch, "buildMockDispatch");
        function checkNetConnect(netConnect, origin) {
          const url2 = new URL(origin);
          if (netConnect === true) {
            return true;
          } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url2.host))) {
            return true;
          }
          return false;
        }
        __name(checkNetConnect, "checkNetConnect");
        function buildMockOptions(opts) {
          if (opts) {
            const { agent, ...mockOptions } = opts;
            return mockOptions;
          }
        }
        __name(buildMockOptions, "buildMockOptions");
        module2.exports = {
          getResponseData,
          getMockDispatch,
          addMockDispatch,
          deleteMockDispatch,
          buildKey,
          generateKeyValues,
          matchValue,
          getResponse,
          getStatusText,
          mockDispatch,
          buildMockDispatch,
          checkNetConnect,
          buildMockOptions,
          getHeaderByName
        };
      }
    });
    var require_mock_interceptor = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
        "use strict";
        var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
        var {
          kDispatches,
          kDispatchKey,
          kDefaultHeaders,
          kDefaultTrailers,
          kContentLength,
          kMockDispatch
        } = require_mock_symbols();
        var { InvalidArgumentError } = require_errors();
        var { buildURL: buildURL2 } = require_util2();
        var MockScope = class {
          constructor(mockDispatch) {
            this[kMockDispatch] = mockDispatch;
          }
          delay(waitInMs) {
            if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
              throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
            }
            this[kMockDispatch].delay = waitInMs;
            return this;
          }
          persist() {
            this[kMockDispatch].persist = true;
            return this;
          }
          times(repeatTimes) {
            if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
              throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
            }
            this[kMockDispatch].times = repeatTimes;
            return this;
          }
        };
        __name(MockScope, "MockScope");
        var MockInterceptor = class {
          constructor(opts, mockDispatches) {
            if (typeof opts !== "object") {
              throw new InvalidArgumentError("opts must be an object");
            }
            if (typeof opts.path === "undefined") {
              throw new InvalidArgumentError("opts.path must be defined");
            }
            if (typeof opts.method === "undefined") {
              opts.method = "GET";
            }
            if (typeof opts.path === "string") {
              if (opts.query) {
                opts.path = buildURL2(opts.path, opts.query);
              } else {
                const parsedURL = new URL(opts.path, "data://");
                opts.path = parsedURL.pathname + parsedURL.search;
              }
            }
            if (typeof opts.method === "string") {
              opts.method = opts.method.toUpperCase();
            }
            this[kDispatchKey] = buildKey(opts);
            this[kDispatches] = mockDispatches;
            this[kDefaultHeaders] = {};
            this[kDefaultTrailers] = {};
            this[kContentLength] = false;
          }
          createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
            const responseData = getResponseData(data);
            const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
            const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
            const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
            return { statusCode, data, headers, trailers };
          }
          validateReplyParameters(statusCode, data, responseOptions) {
            if (typeof statusCode === "undefined") {
              throw new InvalidArgumentError("statusCode must be defined");
            }
            if (typeof data === "undefined") {
              throw new InvalidArgumentError("data must be defined");
            }
            if (typeof responseOptions !== "object") {
              throw new InvalidArgumentError("responseOptions must be an object");
            }
          }
          reply(replyData) {
            if (typeof replyData === "function") {
              const wrappedDefaultsCallback = /* @__PURE__ */ __name((opts) => {
                const resolvedData = replyData(opts);
                if (typeof resolvedData !== "object") {
                  throw new InvalidArgumentError("reply options callback must return an object");
                }
                const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
                this.validateReplyParameters(statusCode2, data2, responseOptions2);
                return {
                  ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
                };
              }, "wrappedDefaultsCallback");
              const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
              return new MockScope(newMockDispatch2);
            }
            const [statusCode, data = "", responseOptions = {}] = [...arguments];
            this.validateReplyParameters(statusCode, data, responseOptions);
            const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
            const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
            return new MockScope(newMockDispatch);
          }
          replyWithError(error2) {
            if (typeof error2 === "undefined") {
              throw new InvalidArgumentError("error must be defined");
            }
            const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 });
            return new MockScope(newMockDispatch);
          }
          defaultReplyHeaders(headers) {
            if (typeof headers === "undefined") {
              throw new InvalidArgumentError("headers must be defined");
            }
            this[kDefaultHeaders] = headers;
            return this;
          }
          defaultReplyTrailers(trailers) {
            if (typeof trailers === "undefined") {
              throw new InvalidArgumentError("trailers must be defined");
            }
            this[kDefaultTrailers] = trailers;
            return this;
          }
          replyContentLength() {
            this[kContentLength] = true;
            return this;
          }
        };
        __name(MockInterceptor, "MockInterceptor");
        module2.exports.MockInterceptor = MockInterceptor;
        module2.exports.MockScope = MockScope;
      }
    });
    var require_mock_client = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
        "use strict";
        var { promisify: promisify4 } = require("util");
        var Client = require_client();
        var { buildMockDispatch } = require_mock_utils();
        var {
          kDispatches,
          kMockAgent,
          kClose,
          kOriginalClose,
          kOrigin,
          kOriginalDispatch,
          kConnected
        } = require_mock_symbols();
        var { MockInterceptor } = require_mock_interceptor();
        var Symbols = require_symbols();
        var { InvalidArgumentError } = require_errors();
        var MockClient = class extends Client {
          constructor(origin, opts) {
            super(origin, opts);
            if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
              throw new InvalidArgumentError("Argument opts.agent must implement Agent");
            }
            this[kMockAgent] = opts.agent;
            this[kOrigin] = origin;
            this[kDispatches] = [];
            this[kConnected] = 1;
            this[kOriginalDispatch] = this.dispatch;
            this[kOriginalClose] = this.close.bind(this);
            this.dispatch = buildMockDispatch.call(this);
            this.close = this[kClose];
          }
          get [Symbols.kConnected]() {
            return this[kConnected];
          }
          intercept(opts) {
            return new MockInterceptor(opts, this[kDispatches]);
          }
          async [kClose]() {
            await promisify4(this[kOriginalClose])();
            this[kConnected] = 0;
            this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
          }
        };
        __name(MockClient, "MockClient");
        module2.exports = MockClient;
      }
    });
    var require_mock_pool = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
        "use strict";
        var { promisify: promisify4 } = require("util");
        var Pool = require_pool();
        var { buildMockDispatch } = require_mock_utils();
        var {
          kDispatches,
          kMockAgent,
          kClose,
          kOriginalClose,
          kOrigin,
          kOriginalDispatch,
          kConnected
        } = require_mock_symbols();
        var { MockInterceptor } = require_mock_interceptor();
        var Symbols = require_symbols();
        var { InvalidArgumentError } = require_errors();
        var MockPool = class extends Pool {
          constructor(origin, opts) {
            super(origin, opts);
            if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
              throw new InvalidArgumentError("Argument opts.agent must implement Agent");
            }
            this[kMockAgent] = opts.agent;
            this[kOrigin] = origin;
            this[kDispatches] = [];
            this[kConnected] = 1;
            this[kOriginalDispatch] = this.dispatch;
            this[kOriginalClose] = this.close.bind(this);
            this.dispatch = buildMockDispatch.call(this);
            this.close = this[kClose];
          }
          get [Symbols.kConnected]() {
            return this[kConnected];
          }
          intercept(opts) {
            return new MockInterceptor(opts, this[kDispatches]);
          }
          async [kClose]() {
            await promisify4(this[kOriginalClose])();
            this[kConnected] = 0;
            this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
          }
        };
        __name(MockPool, "MockPool");
        module2.exports = MockPool;
      }
    });
    var require_pluralizer = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
        "use strict";
        var singulars = {
          pronoun: "it",
          is: "is",
          was: "was",
          this: "this"
        };
        var plurals = {
          pronoun: "they",
          is: "are",
          was: "were",
          this: "these"
        };
        module2.exports = /* @__PURE__ */ __name(class Pluralizer {
          constructor(singular, plural) {
            this.singular = singular;
            this.plural = plural;
          }
          pluralize(count2) {
            const one = count2 === 1;
            const keys2 = one ? singulars : plurals;
            const noun = one ? this.singular : this.plural;
            return { ...keys2, count: count2, noun };
          }
        }, "Pluralizer");
      }
    });
    var require_pending_interceptors_formatter = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
        "use strict";
        var { Transform } = require("stream");
        var { Console } = require("console");
        module2.exports = /* @__PURE__ */ __name(class PendingInterceptorsFormatter {
          constructor({ disableColors } = {}) {
            this.transform = new Transform({
              transform(chunk, _enc, cb) {
                cb(null, chunk);
              }
            });
            this.logger = new Console({
              stdout: this.transform,
              inspectOptions: {
                colors: !disableColors && !process.env.CI
              }
            });
          }
          format(pendingInterceptors) {
            const withPrettyHeaders = pendingInterceptors.map(
              ({ method, path: path7, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
                Method: method,
                Origin: origin,
                Path: path7,
                "Status code": statusCode,
                Persistent: persist ? "\u2705" : "\u274C",
                Invocations: timesInvoked,
                Remaining: persist ? Infinity : times - timesInvoked
              })
            );
            this.logger.table(withPrettyHeaders);
            return this.transform.read().toString();
          }
        }, "PendingInterceptorsFormatter");
      }
    });
    var require_mock_agent = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
        "use strict";
        var { kClients } = require_symbols();
        var Agent = require_agent();
        var {
          kAgent,
          kMockAgentSet,
          kMockAgentGet,
          kDispatches,
          kIsMockActive,
          kNetConnect,
          kGetNetConnect,
          kOptions,
          kFactory
        } = require_mock_symbols();
        var MockClient = require_mock_client();
        var MockPool = require_mock_pool();
        var { matchValue, buildMockOptions } = require_mock_utils();
        var { InvalidArgumentError, UndiciError } = require_errors();
        var Dispatcher = require_dispatcher();
        var Pluralizer = require_pluralizer();
        var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
        var FakeWeakRef = class {
          constructor(value) {
            this.value = value;
          }
          deref() {
            return this.value;
          }
        };
        __name(FakeWeakRef, "FakeWeakRef");
        var MockAgent = class extends Dispatcher {
          constructor(opts) {
            super(opts);
            this[kNetConnect] = true;
            this[kIsMockActive] = true;
            if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
              throw new InvalidArgumentError("Argument opts.agent must implement Agent");
            }
            const agent = opts && opts.agent ? opts.agent : new Agent(opts);
            this[kAgent] = agent;
            this[kClients] = agent[kClients];
            this[kOptions] = buildMockOptions(opts);
          }
          get(origin) {
            let dispatcher = this[kMockAgentGet](origin);
            if (!dispatcher) {
              dispatcher = this[kFactory](origin);
              this[kMockAgentSet](origin, dispatcher);
            }
            return dispatcher;
          }
          dispatch(opts, handler) {
            this.get(opts.origin);
            return this[kAgent].dispatch(opts, handler);
          }
          async close() {
            await this[kAgent].close();
            this[kClients].clear();
          }
          deactivate() {
            this[kIsMockActive] = false;
          }
          activate() {
            this[kIsMockActive] = true;
          }
          enableNetConnect(matcher) {
            if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
              if (Array.isArray(this[kNetConnect])) {
                this[kNetConnect].push(matcher);
              } else {
                this[kNetConnect] = [matcher];
              }
            } else if (typeof matcher === "undefined") {
              this[kNetConnect] = true;
            } else {
              throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
            }
          }
          disableNetConnect() {
            this[kNetConnect] = false;
          }
          get isMockActive() {
            return this[kIsMockActive];
          }
          [kMockAgentSet](origin, dispatcher) {
            this[kClients].set(origin, new FakeWeakRef(dispatcher));
          }
          [kFactory](origin) {
            const mockOptions = Object.assign({ agent: this }, this[kOptions]);
            return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
          }
          [kMockAgentGet](origin) {
            const ref = this[kClients].get(origin);
            if (ref) {
              return ref.deref();
            }
            if (typeof origin !== "string") {
              const dispatcher = this[kFactory]("http://localhost:9999");
              this[kMockAgentSet](origin, dispatcher);
              return dispatcher;
            }
            for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
              const nonExplicitDispatcher = nonExplicitRef.deref();
              if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
                const dispatcher = this[kFactory](origin);
                this[kMockAgentSet](origin, dispatcher);
                dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
                return dispatcher;
              }
            }
          }
          [kGetNetConnect]() {
            return this[kNetConnect];
          }
          pendingInterceptors() {
            const mockAgentClients = this[kClients];
            return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
          }
          assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
            const pending = this.pendingInterceptors();
            if (pending.length === 0) {
              return;
            }
            const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
            throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
          }
        };
        __name(MockAgent, "MockAgent");
        module2.exports = MockAgent;
      }
    });
    var require_proxy_agent = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
        "use strict";
        var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
        var { URL: URL32 } = require("url");
        var Agent = require_agent();
        var Client = require_client();
        var DispatcherBase = require_dispatcher_base();
        var { InvalidArgumentError, RequestAbortedError } = require_errors();
        var buildConnector = require_connect();
        var kAgent = Symbol("proxy agent");
        var kClient = Symbol("proxy client");
        var kProxyHeaders = Symbol("proxy headers");
        var kRequestTls = Symbol("request tls settings");
        var kProxyTls = Symbol("proxy tls settings");
        var kConnectEndpoint = Symbol("connect endpoint function");
        function defaultProtocolPort(protocol) {
          return protocol === "https:" ? 443 : 80;
        }
        __name(defaultProtocolPort, "defaultProtocolPort");
        function buildProxyOptions(opts) {
          if (typeof opts === "string") {
            opts = { uri: opts };
          }
          if (!opts || !opts.uri) {
            throw new InvalidArgumentError("Proxy opts.uri is mandatory");
          }
          return {
            uri: opts.uri,
            protocol: opts.protocol || "https"
          };
        }
        __name(buildProxyOptions, "buildProxyOptions");
        var ProxyAgent = class extends DispatcherBase {
          constructor(opts) {
            super(opts);
            this[kProxy] = buildProxyOptions(opts);
            this[kAgent] = new Agent(opts);
            this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
            if (typeof opts === "string") {
              opts = { uri: opts };
            }
            if (!opts || !opts.uri) {
              throw new InvalidArgumentError("Proxy opts.uri is mandatory");
            }
            this[kRequestTls] = opts.requestTls;
            this[kProxyTls] = opts.proxyTls;
            this[kProxyHeaders] = {};
            if (opts.auth) {
              this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
            }
            const resolvedUrl = new URL32(opts.uri);
            const { origin, port, host } = resolvedUrl;
            const connect = buildConnector({ ...opts.proxyTls });
            this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
            this[kClient] = new Client(resolvedUrl, { connect });
            this[kAgent] = new Agent({
              ...opts,
              connect: async (opts2, callback) => {
                let requestedHost = opts2.host;
                if (!opts2.port) {
                  requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
                }
                try {
                  const { socket, statusCode } = await this[kClient].connect({
                    origin,
                    port,
                    path: requestedHost,
                    signal: opts2.signal,
                    headers: {
                      ...this[kProxyHeaders],
                      host
                    }
                  });
                  if (statusCode !== 200) {
                    socket.on("error", () => {
                    }).destroy();
                    callback(new RequestAbortedError("Proxy response !== 200 when HTTP Tunneling"));
                  }
                  if (opts2.protocol !== "https:") {
                    callback(null, socket);
                    return;
                  }
                  let servername;
                  if (this[kRequestTls]) {
                    servername = this[kRequestTls].servername;
                  } else {
                    servername = opts2.servername;
                  }
                  this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
                } catch (err) {
                  callback(err);
                }
              }
            });
          }
          dispatch(opts, handler) {
            const { host } = new URL32(opts.origin);
            const headers = buildHeaders2(opts.headers);
            throwIfProxyAuthIsSent(headers);
            return this[kAgent].dispatch(
              {
                ...opts,
                headers: {
                  ...headers,
                  host
                }
              },
              handler
            );
          }
          async [kClose]() {
            await this[kAgent].close();
            await this[kClient].close();
          }
          async [kDestroy]() {
            await this[kAgent].destroy();
            await this[kClient].destroy();
          }
        };
        __name(ProxyAgent, "ProxyAgent");
        function buildHeaders2(headers) {
          if (Array.isArray(headers)) {
            const headersPair = {};
            for (let i = 0; i < headers.length; i += 2) {
              headersPair[headers[i]] = headers[i + 1];
            }
            return headersPair;
          }
          return headers;
        }
        __name(buildHeaders2, "buildHeaders");
        function throwIfProxyAuthIsSent(headers) {
          const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
          if (existProxyAuth) {
            throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
          }
        }
        __name(throwIfProxyAuthIsSent, "throwIfProxyAuthIsSent");
        module2.exports = ProxyAgent;
      }
    });
    var require_global = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/global.js"(exports2, module2) {
        "use strict";
        var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
        var { InvalidArgumentError } = require_errors();
        var Agent = require_agent();
        if (getGlobalDispatcher() === void 0) {
          setGlobalDispatcher(new Agent());
        }
        function setGlobalDispatcher(agent) {
          if (!agent || typeof agent.dispatch !== "function") {
            throw new InvalidArgumentError("Argument agent must implement Agent");
          }
          Object.defineProperty(globalThis, globalDispatcher, {
            value: agent,
            writable: true,
            enumerable: false,
            configurable: false
          });
        }
        __name(setGlobalDispatcher, "setGlobalDispatcher");
        function getGlobalDispatcher() {
          return globalThis[globalDispatcher];
        }
        __name(getGlobalDispatcher, "getGlobalDispatcher");
        module2.exports = {
          setGlobalDispatcher,
          getGlobalDispatcher
        };
      }
    });
    var require_DecoratorHandler = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/handler/DecoratorHandler.js"(exports2, module2) {
        "use strict";
        module2.exports = /* @__PURE__ */ __name(class DecoratorHandler {
          constructor(handler) {
            this.handler = handler;
          }
          onConnect(...args) {
            return this.handler.onConnect(...args);
          }
          onError(...args) {
            return this.handler.onError(...args);
          }
          onUpgrade(...args) {
            return this.handler.onUpgrade(...args);
          }
          onHeaders(...args) {
            return this.handler.onHeaders(...args);
          }
          onData(...args) {
            return this.handler.onData(...args);
          }
          onComplete(...args) {
            return this.handler.onComplete(...args);
          }
          onBodySent(...args) {
            return this.handler.onBodySent(...args);
          }
        }, "DecoratorHandler");
      }
    });
    var require_headers = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
        "use strict";
        var { kHeadersList } = require_symbols();
        var { kGuard } = require_symbols2();
        var { kEnumerableProperty } = require_util2();
        var {
          makeIterator,
          isValidHeaderName: isValidHeaderName2,
          isValidHeaderValue
        } = require_util3();
        var { webidl } = require_webidl();
        var kHeadersMap = Symbol("headers map");
        var kHeadersSortedMap = Symbol("headers map sorted");
        function headerValueNormalize(potentialValue) {
          return potentialValue.replace(
            /^[\r\n\t ]+|[\r\n\t ]+$/g,
            ""
          );
        }
        __name(headerValueNormalize, "headerValueNormalize");
        function fill(headers, object) {
          if (Array.isArray(object)) {
            for (const header of object) {
              if (header.length !== 2) {
                webidl.errors.exception({
                  header: "Headers constructor",
                  message: `expected name/value pair to be length 2, found ${header.length}.`
                });
              }
              headers.append(header[0], header[1]);
            }
          } else if (typeof object === "object" && object !== null) {
            for (const [key, value] of Object.entries(object)) {
              headers.append(key, value);
            }
          } else {
            webidl.errors.conversionFailed({
              prefix: "Headers constructor",
              argument: "Argument 1",
              types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
            });
          }
        }
        __name(fill, "fill");
        var HeadersList = class {
          constructor(init2) {
            if (init2 instanceof HeadersList) {
              this[kHeadersMap] = new Map(init2[kHeadersMap]);
              this[kHeadersSortedMap] = init2[kHeadersSortedMap];
            } else {
              this[kHeadersMap] = new Map(init2);
              this[kHeadersSortedMap] = null;
            }
          }
          contains(name) {
            name = name.toLowerCase();
            return this[kHeadersMap].has(name);
          }
          clear() {
            this[kHeadersMap].clear();
            this[kHeadersSortedMap] = null;
          }
          append(name, value) {
            this[kHeadersSortedMap] = null;
            name = name.toLowerCase();
            const exists4 = this[kHeadersMap].get(name);
            if (exists4) {
              this[kHeadersMap].set(name, `${exists4}, ${value}`);
            } else {
              this[kHeadersMap].set(name, `${value}`);
            }
          }
          set(name, value) {
            this[kHeadersSortedMap] = null;
            name = name.toLowerCase();
            return this[kHeadersMap].set(name, value);
          }
          delete(name) {
            this[kHeadersSortedMap] = null;
            name = name.toLowerCase();
            return this[kHeadersMap].delete(name);
          }
          get(name) {
            var _a32;
            name = name.toLowerCase();
            if (!this.contains(name)) {
              return null;
            }
            return (_a32 = this[kHeadersMap].get(name)) != null ? _a32 : null;
          }
          has(name) {
            name = name.toLowerCase();
            return this[kHeadersMap].has(name);
          }
          keys() {
            return this[kHeadersMap].keys();
          }
          values() {
            return this[kHeadersMap].values();
          }
          entries() {
            return this[kHeadersMap].entries();
          }
          [Symbol.iterator]() {
            return this[kHeadersMap][Symbol.iterator]();
          }
        };
        __name(HeadersList, "HeadersList");
        var Headers = class {
          constructor(init2 = void 0) {
            this[kHeadersList] = new HeadersList();
            this[kGuard] = "none";
            if (init2 !== void 0) {
              init2 = webidl.converters.HeadersInit(init2);
              fill(this, init2);
            }
          }
          get [Symbol.toStringTag]() {
            return this.constructor.name;
          }
          append(name, value) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 2) {
              throw new TypeError(
                `Failed to execute 'append' on 'Headers': 2 arguments required, but only ${arguments.length} present.`
              );
            }
            name = webidl.converters.ByteString(name);
            value = webidl.converters.ByteString(value);
            value = headerValueNormalize(value);
            if (!isValidHeaderName2(name)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.append",
                value: name,
                type: "header name"
              });
            } else if (!isValidHeaderValue(value)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.append",
                value,
                type: "header value"
              });
            }
            if (this[kGuard] === "immutable") {
              throw new TypeError("immutable");
            } else if (this[kGuard] === "request-no-cors") {
            }
            return this[kHeadersList].append(name, value);
          }
          delete(name) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to execute 'delete' on 'Headers': 1 argument required, but only ${arguments.length} present.`
              );
            }
            name = webidl.converters.ByteString(name);
            if (!isValidHeaderName2(name)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.delete",
                value: name,
                type: "header name"
              });
            }
            if (this[kGuard] === "immutable") {
              throw new TypeError("immutable");
            } else if (this[kGuard] === "request-no-cors") {
            }
            if (!this[kHeadersList].contains(name)) {
              return;
            }
            return this[kHeadersList].delete(name);
          }
          get(name) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to execute 'get' on 'Headers': 1 argument required, but only ${arguments.length} present.`
              );
            }
            name = webidl.converters.ByteString(name);
            if (!isValidHeaderName2(name)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.get",
                value: name,
                type: "header name"
              });
            }
            return this[kHeadersList].get(name);
          }
          has(name) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to execute 'has' on 'Headers': 1 argument required, but only ${arguments.length} present.`
              );
            }
            name = webidl.converters.ByteString(name);
            if (!isValidHeaderName2(name)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.has",
                value: name,
                type: "header name"
              });
            }
            return this[kHeadersList].contains(name);
          }
          set(name, value) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 2) {
              throw new TypeError(
                `Failed to execute 'set' on 'Headers': 2 arguments required, but only ${arguments.length} present.`
              );
            }
            name = webidl.converters.ByteString(name);
            value = webidl.converters.ByteString(value);
            value = headerValueNormalize(value);
            if (!isValidHeaderName2(name)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.set",
                value: name,
                type: "header name"
              });
            } else if (!isValidHeaderValue(value)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.set",
                value,
                type: "header value"
              });
            }
            if (this[kGuard] === "immutable") {
              throw new TypeError("immutable");
            } else if (this[kGuard] === "request-no-cors") {
            }
            return this[kHeadersList].set(name, value);
          }
          get [kHeadersSortedMap]() {
            if (!this[kHeadersList][kHeadersSortedMap]) {
              this[kHeadersList][kHeadersSortedMap] = new Map([...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1));
            }
            return this[kHeadersList][kHeadersSortedMap];
          }
          keys() {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(this[kHeadersSortedMap].keys(), "Headers");
          }
          values() {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(this[kHeadersSortedMap].values(), "Headers");
          }
          entries() {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(this[kHeadersSortedMap].entries(), "Headers");
          }
          forEach(callbackFn, thisArg = globalThis) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${arguments.length} present.`
              );
            }
            if (typeof callbackFn !== "function") {
              throw new TypeError(
                "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
              );
            }
            for (const [key, value] of this) {
              callbackFn.apply(thisArg, [value, key, this]);
            }
          }
          [Symbol.for("nodejs.util.inspect.custom")]() {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kHeadersList];
          }
        };
        __name(Headers, "Headers");
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        Object.defineProperties(Headers.prototype, {
          append: kEnumerableProperty,
          delete: kEnumerableProperty,
          get: kEnumerableProperty,
          has: kEnumerableProperty,
          set: kEnumerableProperty,
          keys: kEnumerableProperty,
          values: kEnumerableProperty,
          entries: kEnumerableProperty,
          forEach: kEnumerableProperty
        });
        webidl.converters.HeadersInit = function(V) {
          if (webidl.util.Type(V) === "Object") {
            if (V[Symbol.iterator]) {
              return webidl.converters["sequence<sequence<ByteString>>"](V);
            }
            return webidl.converters["record<ByteString, ByteString>"](V);
          }
          webidl.errors.conversionFailed({
            prefix: "Headers constructor",
            argument: "Argument 1",
            types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
          });
        };
        module2.exports = {
          fill,
          Headers,
          HeadersList
        };
      }
    });
    var require_global2 = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/global.js"(exports2, module2) {
        "use strict";
        var globalOrigin = Symbol.for("undici.globalOrigin.1");
        function getGlobalOrigin() {
          return globalThis[globalOrigin];
        }
        __name(getGlobalOrigin, "getGlobalOrigin");
        function setGlobalOrigin(newOrigin) {
          if (newOrigin !== void 0 && typeof newOrigin !== "string" && !(newOrigin instanceof URL)) {
            throw new Error("Invalid base url");
          }
          if (newOrigin === void 0) {
            Object.defineProperty(globalThis, globalOrigin, {
              value: void 0,
              writable: true,
              enumerable: false,
              configurable: false
            });
            return;
          }
          const parsedURL = new URL(newOrigin);
          if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
            throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
          }
          Object.defineProperty(globalThis, globalOrigin, {
            value: parsedURL,
            writable: true,
            enumerable: false,
            configurable: false
          });
        }
        __name(setGlobalOrigin, "setGlobalOrigin");
        module2.exports = {
          getGlobalOrigin,
          setGlobalOrigin
        };
      }
    });
    var require_response = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/response.js"(exports2, module2) {
        "use strict";
        var { Headers, HeadersList, fill } = require_headers();
        var { extractBody, cloneBody, mixinBody } = require_body();
        var util2 = require_util2();
        var { kEnumerableProperty } = util2;
        var {
          responseURL,
          isValidReasonPhrase,
          isCancelled,
          isAborted,
          isBlobLike,
          serializeJavascriptValueToJSONString,
          isErrorLike
        } = require_util3();
        var {
          redirectStatus,
          nullBodyStatus,
          DOMException
        } = require_constants();
        var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
        var { webidl } = require_webidl();
        var { FormData: FormData4 } = require_formdata();
        var { getGlobalOrigin } = require_global2();
        var { kHeadersList } = require_symbols();
        var assert2 = require("assert");
        var { types: types2 } = require("util");
        var ReadableStream2 = globalThis.ReadableStream || require("stream/web").ReadableStream;
        var Response2 = class {
          static error() {
            const relevantRealm = { settingsObject: {} };
            const responseObject = new Response2();
            responseObject[kState] = makeNetworkError();
            responseObject[kRealm] = relevantRealm;
            responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
            responseObject[kHeaders][kGuard] = "immutable";
            responseObject[kHeaders][kRealm] = relevantRealm;
            return responseObject;
          }
          static json(data, init2 = {}) {
            if (arguments.length === 0) {
              throw new TypeError(
                "Failed to execute 'json' on 'Response': 1 argument required, but 0 present."
              );
            }
            if (init2 !== null) {
              init2 = webidl.converters.ResponseInit(init2);
            }
            const bytes = new TextEncoder("utf-8").encode(
              serializeJavascriptValueToJSONString(data)
            );
            const body = extractBody(bytes);
            const relevantRealm = { settingsObject: {} };
            const responseObject = new Response2();
            responseObject[kRealm] = relevantRealm;
            responseObject[kHeaders][kGuard] = "response";
            responseObject[kHeaders][kRealm] = relevantRealm;
            initializeResponse(responseObject, init2, { body: body[0], type: "application/json" });
            return responseObject;
          }
          static redirect(url2, status = 302) {
            const relevantRealm = { settingsObject: {} };
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`
              );
            }
            url2 = webidl.converters.USVString(url2);
            status = webidl.converters["unsigned short"](status);
            let parsedURL;
            try {
              parsedURL = new URL(url2, getGlobalOrigin());
            } catch (err) {
              throw Object.assign(new TypeError("Failed to parse URL from " + url2), {
                cause: err
              });
            }
            if (!redirectStatus.includes(status)) {
              throw new RangeError("Invalid status code");
            }
            const responseObject = new Response2();
            responseObject[kRealm] = relevantRealm;
            responseObject[kHeaders][kGuard] = "immutable";
            responseObject[kHeaders][kRealm] = relevantRealm;
            responseObject[kState].status = status;
            const value = parsedURL.toString();
            responseObject[kState].headersList.append("location", value);
            return responseObject;
          }
          constructor(body = null, init2 = {}) {
            if (body !== null) {
              body = webidl.converters.BodyInit(body);
            }
            init2 = webidl.converters.ResponseInit(init2);
            this[kRealm] = { settingsObject: {} };
            this[kState] = makeResponse({});
            this[kHeaders] = new Headers();
            this[kHeaders][kGuard] = "response";
            this[kHeaders][kHeadersList] = this[kState].headersList;
            this[kHeaders][kRealm] = this[kRealm];
            let bodyWithType = null;
            if (body != null) {
              const [extractedBody, type] = extractBody(body);
              bodyWithType = { body: extractedBody, type };
            }
            initializeResponse(this, init2, bodyWithType);
          }
          get [Symbol.toStringTag]() {
            return this.constructor.name;
          }
          get type() {
            if (!(this instanceof Response2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].type;
          }
          get url() {
            if (!(this instanceof Response2)) {
              throw new TypeError("Illegal invocation");
            }
            let url2 = responseURL(this[kState]);
            if (url2 == null) {
              return "";
            }
            if (url2.hash) {
              url2 = new URL(url2);
              url2.hash = "";
            }
            return url2.toString();
          }
          get redirected() {
            if (!(this instanceof Response2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].urlList.length > 1;
          }
          get status() {
            if (!(this instanceof Response2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].status;
          }
          get ok() {
            if (!(this instanceof Response2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].status >= 200 && this[kState].status <= 299;
          }
          get statusText() {
            if (!(this instanceof Response2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].statusText;
          }
          get headers() {
            if (!(this instanceof Response2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kHeaders];
          }
          clone() {
            if (!(this instanceof Response2)) {
              throw new TypeError("Illegal invocation");
            }
            if (this.bodyUsed || this.body && this.body.locked) {
              webidl.errors.exception({
                header: "Response.clone",
                message: "Body has already been consumed."
              });
            }
            const clonedResponse = cloneResponse2(this[kState]);
            const clonedResponseObject = new Response2();
            clonedResponseObject[kState] = clonedResponse;
            clonedResponseObject[kRealm] = this[kRealm];
            clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
            clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
            clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
            return clonedResponseObject;
          }
        };
        __name(Response2, "Response");
        mixinBody(Response2);
        Object.defineProperties(Response2.prototype, {
          type: kEnumerableProperty,
          url: kEnumerableProperty,
          status: kEnumerableProperty,
          ok: kEnumerableProperty,
          redirected: kEnumerableProperty,
          statusText: kEnumerableProperty,
          headers: kEnumerableProperty,
          clone: kEnumerableProperty
        });
        function cloneResponse2(response) {
          if (response.internalResponse) {
            return filterResponse(
              cloneResponse2(response.internalResponse),
              response.type
            );
          }
          const newResponse = makeResponse({ ...response, body: null });
          if (response.body != null) {
            newResponse.body = cloneBody(response.body);
          }
          return newResponse;
        }
        __name(cloneResponse2, "cloneResponse");
        function makeResponse(init2) {
          return {
            aborted: false,
            rangeRequested: false,
            timingAllowPassed: false,
            requestIncludesCredentials: false,
            type: "default",
            status: 200,
            timingInfo: null,
            cacheState: "",
            statusText: "",
            ...init2,
            headersList: init2.headersList ? new HeadersList(init2.headersList) : new HeadersList(),
            urlList: init2.urlList ? [...init2.urlList] : []
          };
        }
        __name(makeResponse, "makeResponse");
        function makeNetworkError(reason) {
          const isError2 = isErrorLike(reason);
          return makeResponse({
            type: "error",
            status: 0,
            error: isError2 ? reason : new Error(reason ? String(reason) : reason, {
              cause: isError2 ? reason : void 0
            }),
            aborted: reason && reason.name === "AbortError"
          });
        }
        __name(makeNetworkError, "makeNetworkError");
        function makeFilteredResponse(response, state) {
          state = {
            internalResponse: response,
            ...state
          };
          return new Proxy(response, {
            get(target, p) {
              return p in state ? state[p] : target[p];
            },
            set(target, p, value) {
              assert2(!(p in state));
              target[p] = value;
              return true;
            }
          });
        }
        __name(makeFilteredResponse, "makeFilteredResponse");
        function filterResponse(response, type) {
          if (type === "basic") {
            return makeFilteredResponse(response, {
              type: "basic",
              headersList: response.headersList
            });
          } else if (type === "cors") {
            return makeFilteredResponse(response, {
              type: "cors",
              headersList: response.headersList
            });
          } else if (type === "opaque") {
            return makeFilteredResponse(response, {
              type: "opaque",
              urlList: Object.freeze([]),
              status: 0,
              statusText: "",
              body: null
            });
          } else if (type === "opaqueredirect") {
            return makeFilteredResponse(response, {
              type: "opaqueredirect",
              status: 0,
              statusText: "",
              headersList: [],
              body: null
            });
          } else {
            assert2(false);
          }
        }
        __name(filterResponse, "filterResponse");
        function makeAppropriateNetworkError(fetchParams) {
          assert2(isCancelled(fetchParams));
          return isAborted(fetchParams) ? makeNetworkError(new DOMException("The operation was aborted.", "AbortError")) : makeNetworkError(fetchParams.controller.terminated.reason);
        }
        __name(makeAppropriateNetworkError, "makeAppropriateNetworkError");
        function initializeResponse(response, init2, body) {
          if (init2.status !== null && (init2.status < 200 || init2.status > 599)) {
            throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
          }
          if ("statusText" in init2 && init2.statusText != null) {
            if (!isValidReasonPhrase(String(init2.statusText))) {
              throw new TypeError("Invalid statusText");
            }
          }
          if ("status" in init2 && init2.status != null) {
            response[kState].status = init2.status;
          }
          if ("statusText" in init2 && init2.statusText != null) {
            response[kState].statusText = init2.statusText;
          }
          if ("headers" in init2 && init2.headers != null) {
            fill(response[kState].headersList, init2.headers);
          }
          if (body) {
            if (nullBodyStatus.includes(response.status)) {
              webidl.errors.exception({
                header: "Response constructor",
                message: "Invalid response status code."
              });
            }
            response[kState].body = body.body;
            if (body.type != null && !response[kState].headersList.has("Content-Type")) {
              response[kState].headersList.append("content-type", body.type);
            }
          }
        }
        __name(initializeResponse, "initializeResponse");
        webidl.converters.ReadableStream = webidl.interfaceConverter(
          ReadableStream2
        );
        webidl.converters.FormData = webidl.interfaceConverter(
          FormData4
        );
        webidl.converters.URLSearchParams = webidl.interfaceConverter(
          URLSearchParams
        );
        webidl.converters.XMLHttpRequestBodyInit = function(V) {
          if (typeof V === "string") {
            return webidl.converters.USVString(V);
          }
          if (isBlobLike(V)) {
            return webidl.converters.Blob(V, { strict: false });
          }
          if (types2.isAnyArrayBuffer(V) || types2.isTypedArray(V) || types2.isDataView(V)) {
            return webidl.converters.BufferSource(V);
          }
          if (util2.isFormDataLike(V)) {
            return webidl.converters.FormData(V, { strict: false });
          }
          if (V instanceof URLSearchParams) {
            return webidl.converters.URLSearchParams(V);
          }
          return webidl.converters.DOMString(V);
        };
        webidl.converters.BodyInit = function(V) {
          if (V instanceof ReadableStream2) {
            return webidl.converters.ReadableStream(V);
          }
          if (V == null ? void 0 : V[Symbol.asyncIterator]) {
            return V;
          }
          return webidl.converters.XMLHttpRequestBodyInit(V);
        };
        webidl.converters.ResponseInit = webidl.dictionaryConverter([
          {
            key: "status",
            converter: webidl.converters["unsigned short"],
            defaultValue: 200
          },
          {
            key: "statusText",
            converter: webidl.converters.ByteString,
            defaultValue: ""
          },
          {
            key: "headers",
            converter: webidl.converters.HeadersInit
          }
        ]);
        module2.exports = {
          makeNetworkError,
          makeResponse,
          makeAppropriateNetworkError,
          filterResponse,
          Response: Response2
        };
      }
    });
    var require_request2 = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/request.js"(exports2, module2) {
        "use strict";
        var { extractBody, mixinBody, cloneBody } = require_body();
        var { Headers, fill: fillHeaders, HeadersList } = require_headers();
        var { FinalizationRegistry } = require_dispatcher_weakref()();
        var util2 = require_util2();
        var {
          isValidHTTPToken,
          sameOrigin,
          normalizeMethod
        } = require_util3();
        var {
          forbiddenMethods,
          corsSafeListedMethods,
          referrerPolicy,
          requestRedirect,
          requestMode,
          requestCredentials,
          requestCache
        } = require_constants();
        var { kEnumerableProperty } = util2;
        var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
        var { webidl } = require_webidl();
        var { getGlobalOrigin } = require_global2();
        var { kHeadersList } = require_symbols();
        var assert2 = require("assert");
        var TransformStream;
        var kInit = Symbol("init");
        var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
          signal.removeEventListener("abort", abort);
        });
        var Request2 = class {
          constructor(input, init2 = {}) {
            var _a32, _b22;
            if (input === kInit) {
              return;
            }
            if (arguments.length < 1) {
              throw new TypeError(
                `Failed to construct 'Request': 1 argument required, but only ${arguments.length} present.`
              );
            }
            input = webidl.converters.RequestInfo(input);
            init2 = webidl.converters.RequestInit(init2);
            this[kRealm] = {
              settingsObject: {
                baseUrl: getGlobalOrigin()
              }
            };
            let request2 = null;
            let fallbackMode = null;
            const baseUrl = this[kRealm].settingsObject.baseUrl;
            let signal = null;
            if (typeof input === "string") {
              let parsedURL;
              try {
                parsedURL = new URL(input, baseUrl);
              } catch (err) {
                throw new TypeError("Failed to parse URL from " + input, { cause: err });
              }
              if (parsedURL.username || parsedURL.password) {
                throw new TypeError(
                  "Request cannot be constructed from a URL that includes credentials: " + input
                );
              }
              request2 = makeRequest({ urlList: [parsedURL] });
              fallbackMode = "cors";
            } else {
              assert2(input instanceof Request2);
              request2 = input[kState];
              signal = input[kSignal];
            }
            const origin = this[kRealm].settingsObject.origin;
            let window2 = "client";
            if (((_b22 = (_a32 = request2.window) == null ? void 0 : _a32.constructor) == null ? void 0 : _b22.name) === "EnvironmentSettingsObject" && sameOrigin(request2.window, origin)) {
              window2 = request2.window;
            }
            if (init2.window !== void 0 && init2.window != null) {
              throw new TypeError(`'window' option '${window2}' must be null`);
            }
            if (init2.window !== void 0) {
              window2 = "no-window";
            }
            request2 = makeRequest({
              method: request2.method,
              headersList: request2.headersList,
              unsafeRequest: request2.unsafeRequest,
              client: this[kRealm].settingsObject,
              window: window2,
              priority: request2.priority,
              origin: request2.origin,
              referrer: request2.referrer,
              referrerPolicy: request2.referrerPolicy,
              mode: request2.mode,
              credentials: request2.credentials,
              cache: request2.cache,
              redirect: request2.redirect,
              integrity: request2.integrity,
              keepalive: request2.keepalive,
              reloadNavigation: request2.reloadNavigation,
              historyNavigation: request2.historyNavigation,
              urlList: [...request2.urlList]
            });
            if (Object.keys(init2).length > 0) {
              if (request2.mode === "navigate") {
                request2.mode = "same-origin";
              }
              request2.reloadNavigation = false;
              request2.historyNavigation = false;
              request2.origin = "client";
              request2.referrer = "client";
              request2.referrerPolicy = "";
              request2.url = request2.urlList[request2.urlList.length - 1];
              request2.urlList = [request2.url];
            }
            if (init2.referrer !== void 0) {
              const referrer = init2.referrer;
              if (referrer === "") {
                request2.referrer = "no-referrer";
              } else {
                let parsedReferrer;
                try {
                  parsedReferrer = new URL(referrer, baseUrl);
                } catch (err) {
                  throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
                }
                request2.referrer = parsedReferrer;
              }
            }
            if (init2.referrerPolicy !== void 0) {
              request2.referrerPolicy = init2.referrerPolicy;
              if (!referrerPolicy.includes(request2.referrerPolicy)) {
                throw new TypeError(
                  `Failed to construct 'Request': The provided value '${request2.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`
                );
              }
            }
            let mode;
            if (init2.mode !== void 0) {
              mode = init2.mode;
              if (!requestMode.includes(mode)) {
                throw new TypeError(
                  `Failed to construct 'Request': The provided value '${request2.mode}' is not a valid enum value of type RequestMode.`
                );
              }
            } else {
              mode = fallbackMode;
            }
            if (mode === "navigate") {
              webidl.errors.exception({
                header: "Request constructor",
                message: "invalid request mode navigate."
              });
            }
            if (mode != null) {
              request2.mode = mode;
            }
            if (init2.credentials !== void 0) {
              request2.credentials = init2.credentials;
              if (!requestCredentials.includes(request2.credentials)) {
                throw new TypeError(
                  `Failed to construct 'Request': The provided value '${request2.credentials}' is not a valid enum value of type RequestCredentials.`
                );
              }
            }
            if (init2.cache !== void 0) {
              request2.cache = init2.cache;
              if (!requestCache.includes(request2.cache)) {
                throw new TypeError(
                  `Failed to construct 'Request': The provided value '${request2.cache}' is not a valid enum value of type RequestCache.`
                );
              }
            }
            if (request2.cache === "only-if-cached" && request2.mode !== "same-origin") {
              throw new TypeError(
                "'only-if-cached' can be set only with 'same-origin' mode"
              );
            }
            if (init2.redirect !== void 0) {
              request2.redirect = init2.redirect;
              if (!requestRedirect.includes(request2.redirect)) {
                throw new TypeError(
                  `Failed to construct 'Request': The provided value '${request2.redirect}' is not a valid enum value of type RequestRedirect.`
                );
              }
            }
            if (init2.integrity !== void 0 && init2.integrity != null) {
              request2.integrity = String(init2.integrity);
            }
            if (init2.keepalive !== void 0) {
              request2.keepalive = Boolean(init2.keepalive);
            }
            if (init2.method !== void 0) {
              let method = init2.method;
              if (!isValidHTTPToken(init2.method)) {
                throw TypeError(`'${init2.method}' is not a valid HTTP method.`);
              }
              if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {
                throw TypeError(`'${init2.method}' HTTP method is unsupported.`);
              }
              method = normalizeMethod(init2.method);
              request2.method = method;
            }
            if (init2.signal !== void 0) {
              signal = init2.signal;
            }
            this[kState] = request2;
            const ac = new AbortController();
            this[kSignal] = ac.signal;
            this[kSignal][kRealm] = this[kRealm];
            if (signal != null) {
              if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
                throw new TypeError(
                  "Failed to construct 'Request': member signal is not of type AbortSignal."
                );
              }
              if (signal.aborted) {
                ac.abort(signal.reason);
              } else {
                const abort = /* @__PURE__ */ __name(() => ac.abort(signal.reason), "abort");
                signal.addEventListener("abort", abort, { once: true });
                requestFinalizer.register(this, { signal, abort });
              }
            }
            this[kHeaders] = new Headers();
            this[kHeaders][kHeadersList] = request2.headersList;
            this[kHeaders][kGuard] = "request";
            this[kHeaders][kRealm] = this[kRealm];
            if (mode === "no-cors") {
              if (!corsSafeListedMethods.includes(request2.method)) {
                throw new TypeError(
                  `'${request2.method} is unsupported in no-cors mode.`
                );
              }
              this[kHeaders][kGuard] = "request-no-cors";
            }
            if (Object.keys(init2).length !== 0) {
              let headers = new Headers(this[kHeaders]);
              if (init2.headers !== void 0) {
                headers = init2.headers;
              }
              this[kHeaders][kHeadersList].clear();
              if (headers.constructor.name === "Headers") {
                for (const [key, val] of headers) {
                  this[kHeaders].append(key, val);
                }
              } else {
                fillHeaders(this[kHeaders], headers);
              }
            }
            const inputBody = input instanceof Request2 ? input[kState].body : null;
            if ((init2.body !== void 0 && init2.body != null || inputBody != null) && (request2.method === "GET" || request2.method === "HEAD")) {
              throw new TypeError("Request with GET/HEAD method cannot have body.");
            }
            let initBody = null;
            if (init2.body !== void 0 && init2.body != null) {
              const [extractedBody, contentType] = extractBody(
                init2.body,
                request2.keepalive
              );
              initBody = extractedBody;
              if (contentType && !this[kHeaders].has("content-type")) {
                this[kHeaders].append("content-type", contentType);
              }
            }
            const inputOrInitBody = initBody != null ? initBody : inputBody;
            if (inputOrInitBody != null && inputOrInitBody.source == null) {
              if (request2.mode !== "same-origin" && request2.mode !== "cors") {
                throw new TypeError(
                  'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
                );
              }
              request2.useCORSPreflightFlag = true;
            }
            let finalBody = inputOrInitBody;
            if (initBody == null && inputBody != null) {
              if (util2.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
                throw new TypeError(
                  "Cannot construct a Request with a Request object that has already been used."
                );
              }
              if (!TransformStream) {
                TransformStream = require("stream/web").TransformStream;
              }
              const identityTransform = new TransformStream();
              inputBody.stream.pipeThrough(identityTransform);
              finalBody = {
                source: inputBody.source,
                length: inputBody.length,
                stream: identityTransform.readable
              };
            }
            this[kState].body = finalBody;
          }
          get [Symbol.toStringTag]() {
            return this.constructor.name;
          }
          get method() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].method;
          }
          get url() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].url.toString();
          }
          get headers() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kHeaders];
          }
          get destination() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].destination;
          }
          get referrer() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            if (this[kState].referrer === "no-referrer") {
              return "";
            }
            if (this[kState].referrer === "client") {
              return "about:client";
            }
            return this[kState].referrer.toString();
          }
          get referrerPolicy() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].referrerPolicy;
          }
          get mode() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].mode;
          }
          get credentials() {
            return this[kState].credentials;
          }
          get cache() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].cache;
          }
          get redirect() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].redirect;
          }
          get integrity() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].integrity;
          }
          get keepalive() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].keepalive;
          }
          get isReloadNavigation() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].reloadNavigation;
          }
          get isHistoryNavigation() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].historyNavigation;
          }
          get signal() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kSignal];
          }
          clone() {
            var _a32;
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            if (this.bodyUsed || ((_a32 = this.body) == null ? void 0 : _a32.locked)) {
              throw new TypeError("unusable");
            }
            const clonedRequest = cloneRequest(this[kState]);
            const clonedRequestObject = new Request2(kInit);
            clonedRequestObject[kState] = clonedRequest;
            clonedRequestObject[kRealm] = this[kRealm];
            clonedRequestObject[kHeaders] = new Headers();
            clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
            clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
            clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
            const ac = new AbortController();
            if (this.signal.aborted) {
              ac.abort(this.signal.reason);
            } else {
              this.signal.addEventListener(
                "abort",
                () => {
                  ac.abort(this.signal.reason);
                },
                { once: true }
              );
            }
            clonedRequestObject[kSignal] = ac.signal;
            return clonedRequestObject;
          }
        };
        __name(Request2, "Request");
        mixinBody(Request2);
        function makeRequest(init2) {
          const request2 = {
            method: "GET",
            localURLsOnly: false,
            unsafeRequest: false,
            body: null,
            client: null,
            reservedClient: null,
            replacesClientId: "",
            window: "client",
            keepalive: false,
            serviceWorkers: "all",
            initiator: "",
            destination: "",
            priority: null,
            origin: "client",
            policyContainer: "client",
            referrer: "client",
            referrerPolicy: "",
            mode: "no-cors",
            useCORSPreflightFlag: false,
            credentials: "same-origin",
            useCredentials: false,
            cache: "default",
            redirect: "follow",
            integrity: "",
            cryptoGraphicsNonceMetadata: "",
            parserMetadata: "",
            reloadNavigation: false,
            historyNavigation: false,
            userActivation: false,
            taintedOrigin: false,
            redirectCount: 0,
            responseTainting: "basic",
            preventNoCacheCacheControlHeaderModification: false,
            done: false,
            timingAllowFailed: false,
            ...init2,
            headersList: init2.headersList ? new HeadersList(init2.headersList) : new HeadersList()
          };
          request2.url = request2.urlList[0];
          return request2;
        }
        __name(makeRequest, "makeRequest");
        function cloneRequest(request2) {
          const newRequest = makeRequest({ ...request2, body: null });
          if (request2.body != null) {
            newRequest.body = cloneBody(request2.body);
          }
          return newRequest;
        }
        __name(cloneRequest, "cloneRequest");
        Object.defineProperties(Request2.prototype, {
          method: kEnumerableProperty,
          url: kEnumerableProperty,
          headers: kEnumerableProperty,
          redirect: kEnumerableProperty,
          clone: kEnumerableProperty,
          signal: kEnumerableProperty
        });
        webidl.converters.Request = webidl.interfaceConverter(
          Request2
        );
        webidl.converters.RequestInfo = function(V) {
          if (typeof V === "string") {
            return webidl.converters.USVString(V);
          }
          if (V instanceof Request2) {
            return webidl.converters.Request(V);
          }
          return webidl.converters.USVString(V);
        };
        webidl.converters.AbortSignal = webidl.interfaceConverter(
          AbortSignal
        );
        webidl.converters.RequestInit = webidl.dictionaryConverter([
          {
            key: "method",
            converter: webidl.converters.ByteString
          },
          {
            key: "headers",
            converter: webidl.converters.HeadersInit
          },
          {
            key: "body",
            converter: webidl.nullableConverter(
              webidl.converters.BodyInit
            )
          },
          {
            key: "referrer",
            converter: webidl.converters.USVString
          },
          {
            key: "referrerPolicy",
            converter: webidl.converters.DOMString,
            allowedValues: [
              "",
              "no-referrer",
              "no-referrer-when-downgrade",
              "same-origin",
              "origin",
              "strict-origin",
              "origin-when-cross-origin",
              "strict-origin-when-cross-origin",
              "unsafe-url"
            ]
          },
          {
            key: "mode",
            converter: webidl.converters.DOMString,
            allowedValues: [
              "same-origin",
              "cors",
              "no-cors",
              "navigate",
              "websocket"
            ]
          },
          {
            key: "credentials",
            converter: webidl.converters.DOMString,
            allowedValues: [
              "omit",
              "same-origin",
              "include"
            ]
          },
          {
            key: "cache",
            converter: webidl.converters.DOMString,
            allowedValues: [
              "default",
              "no-store",
              "reload",
              "no-cache",
              "force-cache",
              "only-if-cached"
            ]
          },
          {
            key: "redirect",
            converter: webidl.converters.DOMString,
            allowedValues: [
              "follow",
              "error",
              "manual"
            ]
          },
          {
            key: "integrity",
            converter: webidl.converters.DOMString
          },
          {
            key: "keepalive",
            converter: webidl.converters.boolean
          },
          {
            key: "signal",
            converter: webidl.nullableConverter(
              (signal) => webidl.converters.AbortSignal(
                signal,
                { strict: false }
              )
            )
          },
          {
            key: "window",
            converter: webidl.converters.any
          }
        ]);
        module2.exports = { Request: Request2, makeRequest };
      }
    });
    var require_dataURL = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
        var assert2 = require("assert");
        var { atob: atob2 } = require("buffer");
        var { isValidHTTPToken } = require_util3();
        var encoder = new TextEncoder();
        function dataURLProcessor(dataURL) {
          assert2(dataURL.protocol === "data:");
          let input = URLSerializer(dataURL, true);
          input = input.slice(5);
          const position = { position: 0 };
          let mimeType = collectASequenceOfCodePoints(
            (char) => char !== ",",
            input,
            position
          );
          const mimeTypeLength = mimeType.length;
          mimeType = mimeType.replace(/^(\u0020)+|(\u0020)+$/g, "");
          if (position.position >= input.length) {
            return "failure";
          }
          position.position++;
          const encodedBody = input.slice(mimeTypeLength + 1);
          let body = stringPercentDecode(encodedBody);
          if (/;(\u0020){0,}base64$/i.test(mimeType)) {
            const stringBody = decodeURIComponent(new TextDecoder("utf-8").decode(body));
            body = forgivingBase64(stringBody);
            if (body === "failure") {
              return "failure";
            }
            mimeType = mimeType.slice(0, -6);
            mimeType = mimeType.replace(/(\u0020)+$/, "");
            mimeType = mimeType.slice(0, -1);
          }
          if (mimeType.startsWith(";")) {
            mimeType = "text/plain" + mimeType;
          }
          let mimeTypeRecord = parseMIMEType(mimeType);
          if (mimeTypeRecord === "failure") {
            mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
          }
          return { mimeType: mimeTypeRecord, body };
        }
        __name(dataURLProcessor, "dataURLProcessor");
        function URLSerializer(url2, excludeFragment = false) {
          let output = url2.protocol;
          if (url2.host.length > 0) {
            output += "//";
            if (url2.username.length > 0 || url2.password.length > 0) {
              output += url2.username;
              if (url2.password.length > 0) {
                output += ":" + url2.password;
              }
              output += "@";
            }
            output += decodeURIComponent(url2.host);
            if (url2.port.length > 0) {
              output += ":" + url2.port;
            }
          }
          if (url2.host.length === 0 && url2.pathname.length > 1 && url2.href.slice(url2.protocol.length + 1)[0] === ".") {
            output += "/.";
          }
          output += url2.pathname;
          if (url2.search.length > 0) {
            output += url2.search;
          }
          if (excludeFragment === false && url2.hash.length > 0) {
            output += url2.hash;
          }
          return output;
        }
        __name(URLSerializer, "URLSerializer");
        function collectASequenceOfCodePoints(condition, input, position) {
          let result = "";
          while (position.position < input.length && condition(input[position.position])) {
            result += input[position.position];
            position.position++;
          }
          return result;
        }
        __name(collectASequenceOfCodePoints, "collectASequenceOfCodePoints");
        function stringPercentDecode(input) {
          const bytes = encoder.encode(input);
          return percentDecode(bytes);
        }
        __name(stringPercentDecode, "stringPercentDecode");
        function percentDecode(input) {
          const output = [];
          for (let i = 0; i < input.length; i++) {
            const byte = input[i];
            if (byte !== 37) {
              output.push(byte);
            } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
              output.push(37);
            } else {
              const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
              const bytePoint = Number.parseInt(nextTwoBytes, 16);
              output.push(bytePoint);
              i += 2;
            }
          }
          return Uint8Array.from(output);
        }
        __name(percentDecode, "percentDecode");
        function parseMIMEType(input) {
          input = input.trim();
          const position = { position: 0 };
          const type = collectASequenceOfCodePoints(
            (char) => char !== "/",
            input,
            position
          );
          if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {
            return "failure";
          }
          if (position.position > input.length) {
            return "failure";
          }
          position.position++;
          let subtype = collectASequenceOfCodePoints(
            (char) => char !== ";",
            input,
            position
          );
          subtype = subtype.trim();
          if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {
            return "failure";
          }
          const mimeType = {
            type: type.toLowerCase(),
            subtype: subtype.toLowerCase(),
            parameters: /* @__PURE__ */ new Map()
          };
          while (position.position < input.length) {
            position.position++;
            collectASequenceOfCodePoints(
              (char) => /(\u000A|\u000D|\u0009|\u0020)/.test(char),
              input,
              position
            );
            let parameterName = collectASequenceOfCodePoints(
              (char) => char !== ";" && char !== "=",
              input,
              position
            );
            parameterName = parameterName.toLowerCase();
            if (position.position < input.length) {
              if (input[position.position] === ";") {
                continue;
              }
              position.position++;
            }
            if (position.position > input.length) {
              break;
            }
            let parameterValue = null;
            if (input[position.position] === '"') {
              parameterValue = collectAnHTTPQuotedString(input, position, true);
              collectASequenceOfCodePoints(
                (char) => char !== ";",
                input,
                position
              );
            } else {
              parameterValue = collectASequenceOfCodePoints(
                (char) => char !== ";",
                input,
                position
              );
              parameterValue = parameterValue.trimEnd();
              if (parameterValue.length === 0) {
                continue;
              }
            }
            if (parameterName.length !== 0 && /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) && !/^(\u0009|\x{0020}-\x{007E}|\x{0080}-\x{00FF})+$/.test(parameterValue) && !mimeType.parameters.has(parameterName)) {
              mimeType.parameters.set(parameterName, parameterValue);
            }
          }
          return mimeType;
        }
        __name(parseMIMEType, "parseMIMEType");
        function forgivingBase64(data) {
          data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
          if (data.length % 4 === 0) {
            data = data.replace(/=?=$/, "");
          }
          if (data.length % 4 === 1) {
            return "failure";
          }
          if (/[^+/0-9A-Za-z]/.test(data)) {
            return "failure";
          }
          const binary = atob2(data);
          const bytes = new Uint8Array(binary.length);
          for (let byte = 0; byte < binary.length; byte++) {
            bytes[byte] = binary.charCodeAt(byte);
          }
          return bytes;
        }
        __name(forgivingBase64, "forgivingBase64");
        function collectAnHTTPQuotedString(input, position, extractValue) {
          const positionStart = position.position;
          let value = "";
          assert2(input[position.position] === '"');
          position.position++;
          while (true) {
            value += collectASequenceOfCodePoints(
              (char) => char !== '"' && char !== "\\",
              input,
              position
            );
            if (position.position >= input.length) {
              break;
            }
            const quoteOrBackslash = input[position.position];
            position.position++;
            if (quoteOrBackslash === "\\") {
              if (position.position >= input.length) {
                value += "\\";
                break;
              }
              value += input[position.position];
              position.position++;
            } else {
              assert2(quoteOrBackslash === '"');
              break;
            }
          }
          if (extractValue) {
            return value;
          }
          return input.slice(positionStart, position.position);
        }
        __name(collectAnHTTPQuotedString, "collectAnHTTPQuotedString");
        function serializeAMimeType(mimeType) {
          assert2(mimeType !== "failure");
          const { type, subtype, parameters } = mimeType;
          let serialization = `${type}/${subtype}`;
          for (let [name, value] of parameters.entries()) {
            serialization += ";";
            serialization += name;
            serialization += "=";
            if (!isValidHTTPToken(value)) {
              value = value.replace(/(\\|")/g, "\\$1");
              value = '"' + value;
              value += '"';
            }
            serialization += value;
          }
          return serialization;
        }
        __name(serializeAMimeType, "serializeAMimeType");
        module2.exports = {
          dataURLProcessor,
          URLSerializer,
          collectASequenceOfCodePoints,
          stringPercentDecode,
          parseMIMEType,
          collectAnHTTPQuotedString,
          serializeAMimeType
        };
      }
    });
    var require_fetch = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/lib/fetch/index.js"(exports2, module2) {
        "use strict";
        var {
          Response: Response2,
          makeNetworkError,
          makeAppropriateNetworkError,
          filterResponse,
          makeResponse
        } = require_response();
        var { Headers } = require_headers();
        var { Request: Request2, makeRequest } = require_request2();
        var zlib2 = require("zlib");
        var {
          bytesMatch,
          makePolicyContainer,
          clonePolicyContainer,
          requestBadPort,
          TAOCheck,
          appendRequestOriginHeader,
          responseLocationURL,
          requestCurrentURL,
          setRequestReferrerPolicyOnRedirect,
          tryUpgradeRequestToAPotentiallyTrustworthyURL,
          createOpaqueTimingInfo,
          appendFetchMetadata,
          corsCheck,
          crossOriginResourcePolicyCheck,
          determineRequestsReferrer,
          coarsenedSharedCurrentTime,
          createDeferredPromise,
          isBlobLike,
          sameOrigin,
          isCancelled,
          isAborted,
          isErrorLike,
          fullyReadBody
        } = require_util3();
        var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
        var assert2 = require("assert");
        var { safelyExtractBody, extractBody } = require_body();
        var {
          redirectStatus,
          nullBodyStatus,
          safeMethods,
          requestBodyHeader,
          subresource,
          DOMException
        } = require_constants();
        var { kHeadersList } = require_symbols();
        var EE = require("events");
        var { Readable, pipeline } = require("stream");
        var { isErrored, isReadable } = require_util2();
        var { dataURLProcessor, serializeAMimeType } = require_dataURL();
        var { TransformStream } = require("stream/web");
        var resolveObjectURL;
        var ReadableStream2;
        var nodeVersion = process.versions.node.split(".");
        var nodeMajor = Number(nodeVersion[0]);
        var nodeMinor = Number(nodeVersion[1]);
        var Fetch = class extends EE {
          constructor(dispatcher) {
            super();
            this.dispatcher = dispatcher;
            this.connection = null;
            this.dump = false;
            this.state = "ongoing";
          }
          terminate(reason) {
            var _a32;
            if (this.state !== "ongoing") {
              return;
            }
            this.state = "terminated";
            (_a32 = this.connection) == null ? void 0 : _a32.destroy(reason);
            this.emit("terminated", reason);
          }
          abort() {
            var _a32;
            if (this.state !== "ongoing") {
              return;
            }
            const reason = new DOMException("The operation was aborted.", "AbortError");
            this.state = "aborted";
            (_a32 = this.connection) == null ? void 0 : _a32.destroy(reason);
            this.emit("terminated", reason);
          }
        };
        __name(Fetch, "Fetch");
        async function fetch2(input, init2 = {}) {
          var _a32;
          if (arguments.length < 1) {
            throw new TypeError(
              `Failed to execute 'fetch' on 'Window': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const p = createDeferredPromise();
          let requestObject;
          try {
            requestObject = new Request2(input, init2);
          } catch (e) {
            p.reject(e);
            return p.promise;
          }
          const request2 = requestObject[kState];
          if (requestObject.signal.aborted) {
            abortFetch(p, request2, null);
            return p.promise;
          }
          const globalObject = request2.client.globalObject;
          if (((_a32 = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a32.name) === "ServiceWorkerGlobalScope") {
            request2.serviceWorkers = "none";
          }
          let responseObject = null;
          const relevantRealm = null;
          let locallyAborted = false;
          let controller = null;
          requestObject.signal.addEventListener(
            "abort",
            () => {
              locallyAborted = true;
              abortFetch(p, request2, responseObject);
              if (controller != null) {
                controller.abort();
              }
            },
            { once: true }
          );
          const handleFetchDone = /* @__PURE__ */ __name((response) => finalizeAndReportTiming(response, "fetch"), "handleFetchDone");
          const processResponse = /* @__PURE__ */ __name((response) => {
            if (locallyAborted) {
              return;
            }
            if (response.aborted) {
              abortFetch(p, request2, responseObject);
              return;
            }
            if (response.type === "error") {
              p.reject(
                Object.assign(new TypeError("fetch failed"), { cause: response.error })
              );
              return;
            }
            responseObject = new Response2();
            responseObject[kState] = response;
            responseObject[kRealm] = relevantRealm;
            responseObject[kHeaders][kHeadersList] = response.headersList;
            responseObject[kHeaders][kGuard] = "immutable";
            responseObject[kHeaders][kRealm] = relevantRealm;
            p.resolve(responseObject);
          }, "processResponse");
          controller = fetching({
            request: request2,
            processResponseEndOfBody: handleFetchDone,
            processResponse,
            dispatcher: this
          });
          return p.promise;
        }
        __name(fetch2, "fetch");
        function finalizeAndReportTiming(response, initiatorType = "other") {
          var _a32;
          if (response.type === "error" && response.aborted) {
            return;
          }
          if (!((_a32 = response.urlList) == null ? void 0 : _a32.length)) {
            return;
          }
          const originalURL = response.urlList[0];
          let timingInfo = response.timingInfo;
          let cacheState = response.cacheState;
          if (!/^https?:/.test(originalURL.protocol)) {
            return;
          }
          if (timingInfo === null) {
            return;
          }
          if (!timingInfo.timingAllowPassed) {
            timingInfo = createOpaqueTimingInfo({
              startTime: timingInfo.startTime
            });
            cacheState = "";
          }
          response.timingInfo.endTime = coarsenedSharedCurrentTime();
          response.timingInfo = timingInfo;
          markResourceTiming(
            timingInfo,
            originalURL,
            initiatorType,
            globalThis,
            cacheState
          );
        }
        __name(finalizeAndReportTiming, "finalizeAndReportTiming");
        function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
          if (nodeMajor >= 18 && nodeMinor >= 2) {
            performance.markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState);
          }
        }
        __name(markResourceTiming, "markResourceTiming");
        function abortFetch(p, request2, responseObject) {
          var _a32, _b22;
          const error2 = new DOMException("The operation was aborted.", "AbortError");
          p.reject(error2);
          if (request2.body != null && isReadable((_a32 = request2.body) == null ? void 0 : _a32.stream)) {
            request2.body.stream.cancel(error2).catch((err) => {
              if (err.code === "ERR_INVALID_STATE") {
                return;
              }
              throw err;
            });
          }
          if (responseObject == null) {
            return;
          }
          const response = responseObject[kState];
          if (response.body != null && isReadable((_b22 = response.body) == null ? void 0 : _b22.stream)) {
            response.body.stream.cancel(error2).catch((err) => {
              if (err.code === "ERR_INVALID_STATE") {
                return;
              }
              throw err;
            });
          }
        }
        __name(abortFetch, "abortFetch");
        function fetching({
          request: request2,
          processRequestBodyChunkLength,
          processRequestEndOfBody,
          processResponse,
          processResponseEndOfBody,
          processResponseConsumeBody,
          useParallelQueue = false,
          dispatcher
        }) {
          var _a32, _b22, _c2, _d2;
          let taskDestination = null;
          let crossOriginIsolatedCapability = false;
          if (request2.client != null) {
            taskDestination = request2.client.globalObject;
            crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;
          }
          const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
          const timingInfo = createOpaqueTimingInfo({
            startTime: currenTime
          });
          const fetchParams = {
            controller: new Fetch(dispatcher),
            request: request2,
            timingInfo,
            processRequestBodyChunkLength,
            processRequestEndOfBody,
            processResponse,
            processResponseConsumeBody,
            processResponseEndOfBody,
            taskDestination,
            crossOriginIsolatedCapability
          };
          assert2(!request2.body || request2.body.stream);
          if (request2.window === "client") {
            request2.window = ((_c2 = (_b22 = (_a32 = request2.client) == null ? void 0 : _a32.globalObject) == null ? void 0 : _b22.constructor) == null ? void 0 : _c2.name) === "Window" ? request2.client : "no-window";
          }
          if (request2.origin === "client") {
            request2.origin = (_d2 = request2.client) == null ? void 0 : _d2.origin;
          }
          if (request2.policyContainer === "client") {
            if (request2.client != null) {
              request2.policyContainer = clonePolicyContainer(
                request2.client.policyContainer
              );
            } else {
              request2.policyContainer = makePolicyContainer();
            }
          }
          if (!request2.headersList.has("accept")) {
            const value = "*/*";
            request2.headersList.append("accept", value);
          }
          if (!request2.headersList.has("accept-language")) {
            request2.headersList.append("accept-language", "*");
          }
          if (request2.priority === null) {
          }
          if (subresource.includes(request2.destination)) {
          }
          mainFetch(fetchParams).catch((err) => {
            fetchParams.controller.terminate(err);
          });
          return fetchParams.controller;
        }
        __name(fetching, "fetching");
        async function mainFetch(fetchParams, recursive = false) {
          const request2 = fetchParams.request;
          let response = null;
          if (request2.localURLsOnly && !/^(about|blob|data):/.test(requestCurrentURL(request2).protocol)) {
            response = makeNetworkError("local URLs only");
          }
          tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);
          if (requestBadPort(request2) === "blocked") {
            response = makeNetworkError("bad port");
          }
          if (request2.referrerPolicy === "") {
            request2.referrerPolicy = request2.policyContainer.referrerPolicy;
          }
          if (request2.referrer !== "no-referrer") {
            request2.referrer = determineRequestsReferrer(request2);
          }
          if (response === null) {
            response = await (async () => {
              const currentURL = requestCurrentURL(request2);
              if (sameOrigin(currentURL, request2.url) && request2.responseTainting === "basic" || currentURL.protocol === "data:" || (request2.mode === "navigate" || request2.mode === "websocket")) {
                request2.responseTainting = "basic";
                return await schemeFetch(fetchParams);
              }
              if (request2.mode === "same-origin") {
                return makeNetworkError('request mode cannot be "same-origin"');
              }
              if (request2.mode === "no-cors") {
                if (request2.redirect !== "follow") {
                  return makeNetworkError(
                    'redirect mode cannot be "follow" for "no-cors" request'
                  );
                }
                request2.responseTainting = "opaque";
                return await schemeFetch(fetchParams);
              }
              if (!/^https?:/.test(requestCurrentURL(request2).protocol)) {
                return makeNetworkError("URL scheme must be a HTTP(S) scheme");
              }
              request2.responseTainting = "cors";
              return await httpFetch(fetchParams);
            })();
          }
          if (recursive) {
            return response;
          }
          if (response.status !== 0 && !response.internalResponse) {
            if (request2.responseTainting === "cors") {
            }
            if (request2.responseTainting === "basic") {
              response = filterResponse(response, "basic");
            } else if (request2.responseTainting === "cors") {
              response = filterResponse(response, "cors");
            } else if (request2.responseTainting === "opaque") {
              response = filterResponse(response, "opaque");
            } else {
              assert2(false);
            }
          }
          let internalResponse = response.status === 0 ? response : response.internalResponse;
          if (internalResponse.urlList.length === 0) {
            internalResponse.urlList.push(...request2.urlList);
          }
          if (!request2.timingAllowFailed) {
            response.timingAllowPassed = true;
          }
          if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.has("range")) {
            response = internalResponse = makeNetworkError();
          }
          if (response.status !== 0 && (request2.method === "HEAD" || request2.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
            internalResponse.body = null;
            fetchParams.controller.dump = true;
          }
          if (request2.integrity) {
            const processBodyError = /* @__PURE__ */ __name((reason) => fetchFinale(fetchParams, makeNetworkError(reason)), "processBodyError");
            if (request2.responseTainting === "opaque" || response.body == null) {
              processBodyError(response.error);
              return;
            }
            const processBody = /* @__PURE__ */ __name((bytes) => {
              if (!bytesMatch(bytes, request2.integrity)) {
                processBodyError("integrity mismatch");
                return;
              }
              response.body = safelyExtractBody(bytes)[0];
              fetchFinale(fetchParams, response);
            }, "processBody");
            await fullyReadBody(response.body, processBody, processBodyError);
          } else {
            fetchFinale(fetchParams, response);
          }
        }
        __name(mainFetch, "mainFetch");
        async function schemeFetch(fetchParams) {
          const { request: request2 } = fetchParams;
          const {
            protocol: scheme,
            pathname: path7
          } = requestCurrentURL(request2);
          switch (scheme) {
            case "about:": {
              if (path7 === "blank") {
                const resp = makeResponse({
                  statusText: "OK",
                  headersList: [
                    ["content-type", "text/html;charset=utf-8"]
                  ]
                });
                resp.urlList = [new URL("about:blank")];
                return resp;
              }
              return makeNetworkError("invalid path called");
            }
            case "blob:": {
              resolveObjectURL = resolveObjectURL || require("buffer").resolveObjectURL;
              const currentURL = requestCurrentURL(request2);
              if (currentURL.search.length !== 0) {
                return makeNetworkError("NetworkError when attempting to fetch resource.");
              }
              const blob = resolveObjectURL(currentURL.toString());
              if (request2.method !== "GET" || !isBlobLike(blob)) {
                return makeNetworkError("invalid method");
              }
              const response = makeResponse({ statusText: "OK", urlList: [currentURL] });
              response.headersList.set("content-length", `${blob.size}`);
              response.headersList.set("content-type", blob.type);
              response.body = extractBody(blob)[0];
              return response;
            }
            case "data:": {
              const currentURL = requestCurrentURL(request2);
              const dataURLStruct = dataURLProcessor(currentURL);
              if (dataURLStruct === "failure") {
                return makeNetworkError("failed to fetch the data URL");
              }
              const mimeType = serializeAMimeType(dataURLStruct.mimeType);
              return makeResponse({
                statusText: "OK",
                headersList: [
                  ["content-type", mimeType]
                ],
                body: extractBody(dataURLStruct.body)[0]
              });
            }
            case "file:": {
              return makeNetworkError("not implemented... yet...");
            }
            case "http:":
            case "https:": {
              return await httpFetch(fetchParams).catch((err) => makeNetworkError(err));
            }
            default: {
              return makeNetworkError("unknown scheme");
            }
          }
        }
        __name(schemeFetch, "schemeFetch");
        function finalizeResponse(fetchParams, response) {
          fetchParams.request.done = true;
          if (fetchParams.processResponseDone != null) {
            queueMicrotask(() => fetchParams.processResponseDone(response));
          }
        }
        __name(finalizeResponse, "finalizeResponse");
        async function fetchFinale(fetchParams, response) {
          if (response.type === "error") {
            response.urlList = [fetchParams.request.urlList[0]];
            response.timingInfo = createOpaqueTimingInfo({
              startTime: fetchParams.timingInfo.startTime
            });
          }
          const processResponseEndOfBody = /* @__PURE__ */ __name(() => {
            fetchParams.request.done = true;
            if (fetchParams.processResponseEndOfBody != null) {
              queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
            }
          }, "processResponseEndOfBody");
          if (fetchParams.processResponse != null) {
            queueMicrotask(() => fetchParams.processResponse(response));
          }
          if (response.body == null) {
            processResponseEndOfBody();
          } else {
            const identityTransformAlgorithm = /* @__PURE__ */ __name((chunk, controller) => {
              controller.enqueue(chunk);
            }, "identityTransformAlgorithm");
            const transformStream = new TransformStream({
              start() {
              },
              transform: identityTransformAlgorithm,
              flush: processResponseEndOfBody
            });
            response.body = { stream: response.body.stream.pipeThrough(transformStream) };
          }
          if (fetchParams.processResponseConsumeBody != null) {
            const processBody = /* @__PURE__ */ __name((nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes), "processBody");
            const processBodyError = /* @__PURE__ */ __name((failure) => fetchParams.processResponseConsumeBody(response, failure), "processBodyError");
            if (response.body == null) {
              queueMicrotask(() => processBody(null));
            } else {
              await fullyReadBody(response.body, processBody, processBodyError);
            }
          }
        }
        __name(fetchFinale, "fetchFinale");
        async function httpFetch(fetchParams) {
          const request2 = fetchParams.request;
          let response = null;
          let actualResponse = null;
          const timingInfo = fetchParams.timingInfo;
          if (request2.serviceWorkers === "all") {
          }
          if (response === null) {
            if (request2.redirect === "follow") {
              request2.serviceWorkers = "none";
            }
            actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
            if (request2.responseTainting === "cors" && corsCheck(request2, response) === "failure") {
              return makeNetworkError("cors failure");
            }
            if (TAOCheck(request2, response) === "failure") {
              request2.timingAllowFailed = true;
            }
          }
          if ((request2.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
            request2.origin,
            request2.client,
            request2.destination,
            actualResponse
          ) === "blocked") {
            return makeNetworkError("blocked");
          }
          if (redirectStatus.includes(actualResponse.status)) {
            if (request2.redirect !== "manual") {
              fetchParams.controller.connection.destroy();
            }
            if (request2.redirect === "error") {
              response = makeNetworkError("unexpected redirect");
            } else if (request2.redirect === "manual") {
              response = actualResponse;
            } else if (request2.redirect === "follow") {
              response = await httpRedirectFetch(fetchParams, response);
            } else {
              assert2(false);
            }
          }
          response.timingInfo = timingInfo;
          return response;
        }
        __name(httpFetch, "httpFetch");
        async function httpRedirectFetch(fetchParams, response) {
          const request2 = fetchParams.request;
          const actualResponse = response.internalResponse ? response.internalResponse : response;
          let locationURL;
          try {
            locationURL = responseLocationURL(
              actualResponse,
              requestCurrentURL(request2).hash
            );
            if (locationURL == null) {
              return response;
            }
          } catch (err) {
            return makeNetworkError(err);
          }
          if (!/^https?:/.test(locationURL.protocol)) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          if (request2.redirectCount === 20) {
            return makeNetworkError("redirect count exceeded");
          }
          request2.redirectCount += 1;
          if (request2.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {
            return makeNetworkError('cross origin not allowed for request mode "cors"');
          }
          if (request2.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
            return makeNetworkError(
              'URL cannot contain credentials for request mode "cors"'
            );
          }
          if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {
            return makeNetworkError();
          }
          if ([301, 302].includes(actualResponse.status) && request2.method === "POST" || actualResponse.status === 303 && !["GET", "HEAD"].includes(request2.method)) {
            request2.method = "GET";
            request2.body = null;
            for (const headerName of requestBodyHeader) {
              request2.headersList.delete(headerName);
            }
          }
          if (request2.body != null) {
            assert2(request2.body.source);
            request2.body = safelyExtractBody(request2.body.source)[0];
          }
          const timingInfo = fetchParams.timingInfo;
          timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
          if (timingInfo.redirectStartTime === 0) {
            timingInfo.redirectStartTime = timingInfo.startTime;
          }
          request2.urlList.push(locationURL);
          setRequestReferrerPolicyOnRedirect(request2, actualResponse);
          return mainFetch(fetchParams, true);
        }
        __name(httpRedirectFetch, "httpRedirectFetch");
        async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
          const request2 = fetchParams.request;
          let httpFetchParams = null;
          let httpRequest = null;
          let response = null;
          const httpCache = null;
          const revalidatingFlag = false;
          if (request2.window === "no-window" && request2.redirect === "error") {
            httpFetchParams = fetchParams;
            httpRequest = request2;
          } else {
            httpRequest = makeRequest(request2);
            httpFetchParams = { ...fetchParams };
            httpFetchParams.request = httpRequest;
          }
          const includeCredentials = request2.credentials === "include" || request2.credentials === "same-origin" && request2.responseTainting === "basic";
          const contentLength = httpRequest.body ? httpRequest.body.length : null;
          let contentLengthHeaderValue = null;
          if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
            contentLengthHeaderValue = "0";
          }
          if (contentLength != null) {
            contentLengthHeaderValue = String(contentLength);
          }
          if (contentLengthHeaderValue != null) {
            httpRequest.headersList.append("content-length", contentLengthHeaderValue);
          }
          if (contentLength != null && httpRequest.keepalive) {
          }
          if (httpRequest.referrer instanceof URL) {
            httpRequest.headersList.append("referer", httpRequest.referrer.href);
          }
          appendRequestOriginHeader(httpRequest);
          appendFetchMetadata(httpRequest);
          if (!httpRequest.headersList.has("user-agent")) {
            httpRequest.headersList.append("user-agent", "undici");
          }
          if (httpRequest.cache === "default" && (httpRequest.headersList.has("if-modified-since") || httpRequest.headersList.has("if-none-match") || httpRequest.headersList.has("if-unmodified-since") || httpRequest.headersList.has("if-match") || httpRequest.headersList.has("if-range"))) {
            httpRequest.cache = "no-store";
          }
          if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.has("cache-control")) {
            httpRequest.headersList.append("cache-control", "max-age=0");
          }
          if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
            if (!httpRequest.headersList.has("pragma")) {
              httpRequest.headersList.append("pragma", "no-cache");
            }
            if (!httpRequest.headersList.has("cache-control")) {
              httpRequest.headersList.append("cache-control", "no-cache");
            }
          }
          if (httpRequest.headersList.has("range")) {
            httpRequest.headersList.append("accept-encoding", "identity");
          }
          if (!httpRequest.headersList.has("accept-encoding")) {
            if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {
              httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
            } else {
              httpRequest.headersList.append("accept-encoding", "gzip, deflate");
            }
          }
          if (includeCredentials) {
          }
          if (httpCache == null) {
            httpRequest.cache = "no-store";
          }
          if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
          }
          if (response == null) {
            if (httpRequest.mode === "only-if-cached") {
              return makeNetworkError("only if cached");
            }
            const forwardResponse = await httpNetworkFetch(
              httpFetchParams,
              includeCredentials,
              isNewConnectionFetch
            );
            if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
            }
            if (revalidatingFlag && forwardResponse.status === 304) {
            }
            if (response == null) {
              response = forwardResponse;
            }
          }
          response.urlList = [...httpRequest.urlList];
          if (httpRequest.headersList.has("range")) {
            response.rangeRequested = true;
          }
          response.requestIncludesCredentials = includeCredentials;
          if (response.status === 407) {
            if (request2.window === "no-window") {
              return makeNetworkError();
            }
            if (isCancelled(fetchParams)) {
              return makeAppropriateNetworkError(fetchParams);
            }
            return makeNetworkError("proxy authentication required");
          }
          if (response.status === 421 && !isNewConnectionFetch && (request2.body == null || request2.body.source != null)) {
            if (isCancelled(fetchParams)) {
              return makeAppropriateNetworkError(fetchParams);
            }
            fetchParams.controller.connection.destroy();
            response = await httpNetworkOrCacheFetch(
              fetchParams,
              isAuthenticationFetch,
              true
            );
          }
          if (isAuthenticationFetch) {
          }
          return response;
        }
        __name(httpNetworkOrCacheFetch, "httpNetworkOrCacheFetch");
        async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
          assert2(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
          fetchParams.controller.connection = {
            abort: null,
            destroyed: false,
            destroy(err) {
              var _a32;
              if (!this.destroyed) {
                this.destroyed = true;
                (_a32 = this.abort) == null ? void 0 : _a32.call(this, err != null ? err : new DOMException("The operation was aborted.", "AbortError"));
              }
            }
          };
          const request2 = fetchParams.request;
          let response = null;
          const timingInfo = fetchParams.timingInfo;
          const httpCache = null;
          if (httpCache == null) {
            request2.cache = "no-store";
          }
          const newConnection = forceNewConnection ? "yes" : "no";
          if (request2.mode === "websocket") {
          } else {
          }
          let requestBody = null;
          if (request2.body == null && fetchParams.processRequestEndOfBody) {
            queueMicrotask(() => fetchParams.processRequestEndOfBody());
          } else if (request2.body != null) {
            const processBodyChunk = /* @__PURE__ */ __name(async function* (bytes) {
              var _a32;
              if (isCancelled(fetchParams)) {
                return;
              }
              yield bytes;
              (_a32 = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a32.call(fetchParams, bytes.byteLength);
            }, "processBodyChunk");
            const processEndOfBody = /* @__PURE__ */ __name(() => {
              if (isCancelled(fetchParams)) {
                return;
              }
              if (fetchParams.processRequestEndOfBody) {
                fetchParams.processRequestEndOfBody();
              }
            }, "processEndOfBody");
            const processBodyError = /* @__PURE__ */ __name((e) => {
              if (isCancelled(fetchParams)) {
                return;
              }
              if (e.name === "AbortError") {
                fetchParams.controller.abort();
              } else {
                fetchParams.controller.terminate(e);
              }
            }, "processBodyError");
            requestBody = async function* () {
              try {
                for await (const bytes of request2.body.stream) {
                  yield* processBodyChunk(bytes);
                }
                processEndOfBody();
              } catch (err) {
                processBodyError(err);
              }
            }();
          }
          try {
            const { body, status, statusText, headersList } = await dispatch({ body: requestBody });
            const iterator = body[Symbol.asyncIterator]();
            fetchParams.controller.next = () => iterator.next();
            response = makeResponse({ status, statusText, headersList });
          } catch (err) {
            if (err.name === "AbortError") {
              fetchParams.controller.connection.destroy();
              return makeAppropriateNetworkError(fetchParams);
            }
            return makeNetworkError(err);
          }
          const pullAlgorithm = /* @__PURE__ */ __name(() => {
            fetchParams.controller.resume();
          }, "pullAlgorithm");
          const cancelAlgorithm = /* @__PURE__ */ __name(() => {
            fetchParams.controller.abort();
          }, "cancelAlgorithm");
          if (!ReadableStream2) {
            ReadableStream2 = require("stream/web").ReadableStream;
          }
          const stream22 = new ReadableStream2(
            {
              async start(controller) {
                fetchParams.controller.controller = controller;
              },
              async pull(controller) {
                await pullAlgorithm(controller);
              },
              async cancel(reason) {
                await cancelAlgorithm(reason);
              }
            },
            { highWaterMark: 0 }
          );
          response.body = { stream: stream22 };
          fetchParams.controller.on("terminated", onAborted);
          fetchParams.controller.resume = async () => {
            var _a32;
            while (true) {
              let bytes;
              try {
                const { done, value } = await fetchParams.controller.next();
                if (isAborted(fetchParams)) {
                  break;
                }
                bytes = done ? void 0 : value;
              } catch (err) {
                if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
                  bytes = void 0;
                } else {
                  bytes = err;
                }
              }
              if (bytes === void 0) {
                try {
                  fetchParams.controller.controller.close();
                } catch (err) {
                  if (!/Controller is already closed/.test(err)) {
                    throw err;
                  }
                }
                finalizeResponse(fetchParams, response);
                return;
              }
              timingInfo.decodedBodySize += (_a32 = bytes == null ? void 0 : bytes.byteLength) != null ? _a32 : 0;
              if (isErrorLike(bytes)) {
                fetchParams.controller.terminate(bytes);
                return;
              }
              fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
              if (isErrored(stream22)) {
                fetchParams.controller.terminate();
                return;
              }
              if (!fetchParams.controller.controller.desiredSize) {
                return;
              }
            }
          };
          function onAborted(reason) {
            if (isAborted(fetchParams)) {
              response.aborted = true;
              if (isReadable(stream22)) {
                fetchParams.controller.controller.error(
                  new DOMException("The operation was aborted.", "AbortError")
                );
              }
            } else {
              if (isReadable(stream22)) {
                fetchParams.controller.controller.error(new TypeError("terminated", {
                  cause: isErrorLike(reason) ? reason : void 0
                }));
              }
            }
            fetchParams.controller.connection.destroy();
          }
          __name(onAborted, "onAborted");
          return response;
          async function dispatch({ body }) {
            const url2 = requestCurrentURL(request2);
            return new Promise((resolve, reject) => fetchParams.controller.dispatcher.dispatch(
              {
                path: url2.pathname + url2.search,
                origin: url2.origin,
                method: request2.method,
                body: fetchParams.controller.dispatcher.isMockActive ? request2.body && request2.body.source : body,
                headers: [...request2.headersList].flat(),
                maxRedirections: 0,
                bodyTimeout: 3e5,
                headersTimeout: 3e5
              },
              {
                body: null,
                abort: null,
                onConnect(abort) {
                  const { connection } = fetchParams.controller;
                  if (connection.destroyed) {
                    abort(new DOMException("The operation was aborted.", "AbortError"));
                  } else {
                    fetchParams.controller.on("terminated", abort);
                    this.abort = connection.abort = abort;
                  }
                },
                onHeaders(status, headersList, resume, statusText) {
                  if (status < 200) {
                    return;
                  }
                  let codings = [];
                  let location = "";
                  const headers = new Headers();
                  for (let n = 0; n < headersList.length; n += 2) {
                    const key = headersList[n + 0].toString("latin1");
                    const val = headersList[n + 1].toString("latin1");
                    if (key.toLowerCase() === "content-encoding") {
                      codings = val.split(",").map((x) => x.trim());
                    } else if (key.toLowerCase() === "location") {
                      location = val;
                    }
                    headers.append(key, val);
                  }
                  this.body = new Readable({ read: resume });
                  const decoders = [];
                  const willFollow = request2.redirect === "follow" && location && redirectStatus.includes(status);
                  if (request2.method !== "HEAD" && request2.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                    for (const coding of codings) {
                      if (/(x-)?gzip/.test(coding)) {
                        decoders.push(zlib2.createGunzip());
                      } else if (/(x-)?deflate/.test(coding)) {
                        decoders.push(zlib2.createInflate());
                      } else if (coding === "br") {
                        decoders.push(zlib2.createBrotliDecompress());
                      } else {
                        decoders.length = 0;
                        break;
                      }
                    }
                  }
                  resolve({
                    status,
                    statusText,
                    headersList: headers[kHeadersList],
                    body: decoders.length ? pipeline(this.body, ...decoders, () => {
                    }) : this.body.on("error", () => {
                    })
                  });
                  return true;
                },
                onData(chunk) {
                  if (fetchParams.controller.dump) {
                    return;
                  }
                  const bytes = chunk;
                  timingInfo.encodedBodySize += bytes.byteLength;
                  return this.body.push(bytes);
                },
                onComplete() {
                  if (this.abort) {
                    fetchParams.controller.off("terminated", this.abort);
                  }
                  fetchParams.controller.ended = true;
                  this.body.push(null);
                },
                onError(error2) {
                  var _a32;
                  if (this.abort) {
                    fetchParams.controller.off("terminated", this.abort);
                  }
                  (_a32 = this.body) == null ? void 0 : _a32.destroy(error2);
                  fetchParams.controller.terminate(error2);
                  reject(error2);
                }
              }
            ));
          }
          __name(dispatch, "dispatch");
        }
        __name(httpNetworkFetch, "httpNetworkFetch");
        module2.exports = {
          fetch: fetch2,
          Fetch,
          fetching,
          finalizeAndReportTiming
        };
      }
    });
    var require_undici = __commonJS({
      "../../node_modules/.pnpm/undici@5.11.0/node_modules/undici/index.js"(exports2, module2) {
        "use strict";
        var Client = require_client();
        var Dispatcher = require_dispatcher();
        var errors = require_errors();
        var Pool = require_pool();
        var BalancedPool = require_balanced_pool();
        var Agent = require_agent();
        var util2 = require_util2();
        var { InvalidArgumentError } = errors;
        var api = require_api();
        var buildConnector = require_connect();
        var MockClient = require_mock_client();
        var MockAgent = require_mock_agent();
        var MockPool = require_mock_pool();
        var mockErrors = require_mock_errors();
        var ProxyAgent = require_proxy_agent();
        var { getGlobalDispatcher, setGlobalDispatcher } = require_global();
        var DecoratorHandler = require_DecoratorHandler();
        var RedirectHandler = require_RedirectHandler();
        var createRedirectInterceptor = require_redirectInterceptor();
        var nodeVersion = process.versions.node.split(".");
        var nodeMajor = Number(nodeVersion[0]);
        var nodeMinor = Number(nodeVersion[1]);
        Object.assign(Dispatcher.prototype, api);
        module2.exports.Dispatcher = Dispatcher;
        module2.exports.Client = Client;
        module2.exports.Pool = Pool;
        module2.exports.BalancedPool = BalancedPool;
        module2.exports.Agent = Agent;
        module2.exports.ProxyAgent = ProxyAgent;
        module2.exports.DecoratorHandler = DecoratorHandler;
        module2.exports.RedirectHandler = RedirectHandler;
        module2.exports.createRedirectInterceptor = createRedirectInterceptor;
        module2.exports.buildConnector = buildConnector;
        module2.exports.errors = errors;
        function makeDispatcher(fn) {
          return (url2, opts, handler) => {
            if (typeof opts === "function") {
              handler = opts;
              opts = null;
            }
            if (!url2 || typeof url2 !== "string" && typeof url2 !== "object" && !(url2 instanceof URL)) {
              throw new InvalidArgumentError("invalid url");
            }
            if (opts != null && typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            if (opts && opts.path != null) {
              if (typeof opts.path !== "string") {
                throw new InvalidArgumentError("invalid opts.path");
              }
              let path7 = opts.path;
              if (!opts.path.startsWith("/")) {
                path7 = `/${path7}`;
              }
              url2 = new URL(util2.parseOrigin(url2).origin + path7);
            } else {
              if (!opts) {
                opts = typeof url2 === "object" ? url2 : {};
              }
              url2 = util2.parseURL(url2);
            }
            const { agent, dispatcher = getGlobalDispatcher() } = opts;
            if (agent) {
              throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
            }
            return fn.call(dispatcher, {
              ...opts,
              origin: url2.origin,
              path: url2.search ? `${url2.pathname}${url2.search}` : url2.pathname,
              method: opts.method || (opts.body ? "PUT" : "GET")
            }, handler);
          };
        }
        __name(makeDispatcher, "makeDispatcher");
        module2.exports.setGlobalDispatcher = setGlobalDispatcher;
        module2.exports.getGlobalDispatcher = getGlobalDispatcher;
        if (nodeMajor > 16 || nodeMajor === 16 && nodeMinor >= 8) {
          let fetchImpl = null;
          module2.exports.fetch = /* @__PURE__ */ __name(async function fetch2(resource) {
            if (!fetchImpl) {
              fetchImpl = require_fetch().fetch;
            }
            const dispatcher = arguments[1] && arguments[1].dispatcher || getGlobalDispatcher();
            try {
              return await fetchImpl.apply(dispatcher, arguments);
            } catch (err) {
              Error.captureStackTrace(err, this);
              throw err;
            }
          }, "fetch");
          module2.exports.Headers = require_headers().Headers;
          module2.exports.Response = require_response().Response;
          module2.exports.Request = require_request2().Request;
          module2.exports.FormData = require_formdata().FormData;
          module2.exports.File = require_file().File;
          const { setGlobalOrigin, getGlobalOrigin } = require_global2();
          module2.exports.setGlobalOrigin = setGlobalOrigin;
          module2.exports.getGlobalOrigin = getGlobalOrigin;
        }
        module2.exports.request = makeDispatcher(api.request);
        module2.exports.stream = makeDispatcher(api.stream);
        module2.exports.pipeline = makeDispatcher(api.pipeline);
        module2.exports.connect = makeDispatcher(api.connect);
        module2.exports.upgrade = makeDispatcher(api.upgrade);
        module2.exports.MockClient = MockClient;
        module2.exports.MockPool = MockPool;
        module2.exports.MockAgent = MockAgent;
        module2.exports.mockErrors = mockErrors;
      }
    });
    var require_js_levenshtein = __commonJS({
      "../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js"(exports2, module2) {
        "use strict";
        module2.exports = function() {
          function _min(d0, d1, d2, bx, ay) {
            return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;
          }
          __name(_min, "_min");
          return function(a, b) {
            if (a === b) {
              return 0;
            }
            if (a.length > b.length) {
              var tmp = a;
              a = b;
              b = tmp;
            }
            var la = a.length;
            var lb = b.length;
            while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
              la--;
              lb--;
            }
            var offset = 0;
            while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {
              offset++;
            }
            la -= offset;
            lb -= offset;
            if (la === 0 || lb < 3) {
              return lb;
            }
            var x = 0;
            var y;
            var d0;
            var d1;
            var d2;
            var d3;
            var dd;
            var dy;
            var ay;
            var bx0;
            var bx1;
            var bx2;
            var bx3;
            var vector = [];
            for (y = 0; y < la; y++) {
              vector.push(y + 1);
              vector.push(a.charCodeAt(offset + y));
            }
            var len = vector.length - 1;
            for (; x < lb - 3; ) {
              bx0 = b.charCodeAt(offset + (d0 = x));
              bx1 = b.charCodeAt(offset + (d1 = x + 1));
              bx2 = b.charCodeAt(offset + (d2 = x + 2));
              bx3 = b.charCodeAt(offset + (d3 = x + 3));
              dd = x += 4;
              for (y = 0; y < len; y += 2) {
                dy = vector[y];
                ay = vector[y + 1];
                d0 = _min(dy, d0, d1, bx0, ay);
                d1 = _min(d0, d1, d2, bx1, ay);
                d2 = _min(d1, d2, d3, bx2, ay);
                dd = _min(d2, d3, dd, bx3, ay);
                vector[y] = dd;
                d3 = d2;
                d2 = d1;
                d1 = d0;
                d0 = dy;
              }
            }
            for (; x < lb; ) {
              bx0 = b.charCodeAt(offset + (d0 = x));
              dd = ++x;
              for (y = 0; y < len; y += 2) {
                dy = vector[y];
                vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);
                d0 = dy;
              }
            }
            return dd;
          };
        }();
      }
    });
    var require_pluralize = __commonJS({
      "../../node_modules/.pnpm/pluralize@8.0.0/node_modules/pluralize/pluralize.js"(exports2, module2) {
        (function(root, pluralize2) {
          if (typeof require === "function" && typeof exports2 === "object" && typeof module2 === "object") {
            module2.exports = pluralize2();
          } else if (typeof define === "function" && false) {
            define(function() {
              return pluralize2();
            });
          } else {
            root.pluralize = pluralize2();
          }
        })(exports2, function() {
          var pluralRules = [];
          var singularRules = [];
          var uncountables = {};
          var irregularPlurals = {};
          var irregularSingles = {};
          function sanitizeRule(rule) {
            if (typeof rule === "string") {
              return new RegExp("^" + rule + "$", "i");
            }
            return rule;
          }
          __name(sanitizeRule, "sanitizeRule");
          function restoreCase(word, token) {
            if (word === token)
              return token;
            if (word === word.toLowerCase())
              return token.toLowerCase();
            if (word === word.toUpperCase())
              return token.toUpperCase();
            if (word[0] === word[0].toUpperCase()) {
              return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
            }
            return token.toLowerCase();
          }
          __name(restoreCase, "restoreCase");
          function interpolate(str, args) {
            return str.replace(/\$(\d{1,2})/g, function(match, index) {
              return args[index] || "";
            });
          }
          __name(interpolate, "interpolate");
          function replace(word, rule) {
            return word.replace(rule[0], function(match, index) {
              var result = interpolate(rule[1], arguments);
              if (match === "") {
                return restoreCase(word[index - 1], result);
              }
              return restoreCase(match, result);
            });
          }
          __name(replace, "replace");
          function sanitizeWord(token, word, rules) {
            if (!token.length || uncountables.hasOwnProperty(token)) {
              return word;
            }
            var len = rules.length;
            while (len--) {
              var rule = rules[len];
              if (rule[0].test(word))
                return replace(word, rule);
            }
            return word;
          }
          __name(sanitizeWord, "sanitizeWord");
          function replaceWord(replaceMap, keepMap, rules) {
            return function(word) {
              var token = word.toLowerCase();
              if (keepMap.hasOwnProperty(token)) {
                return restoreCase(word, token);
              }
              if (replaceMap.hasOwnProperty(token)) {
                return restoreCase(word, replaceMap[token]);
              }
              return sanitizeWord(token, word, rules);
            };
          }
          __name(replaceWord, "replaceWord");
          function checkWord(replaceMap, keepMap, rules, bool) {
            return function(word) {
              var token = word.toLowerCase();
              if (keepMap.hasOwnProperty(token))
                return true;
              if (replaceMap.hasOwnProperty(token))
                return false;
              return sanitizeWord(token, token, rules) === token;
            };
          }
          __name(checkWord, "checkWord");
          function pluralize2(word, count2, inclusive) {
            var pluralized = count2 === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
            return (inclusive ? count2 + " " : "") + pluralized;
          }
          __name(pluralize2, "pluralize");
          pluralize2.plural = replaceWord(
            irregularSingles,
            irregularPlurals,
            pluralRules
          );
          pluralize2.isPlural = checkWord(
            irregularSingles,
            irregularPlurals,
            pluralRules
          );
          pluralize2.singular = replaceWord(
            irregularPlurals,
            irregularSingles,
            singularRules
          );
          pluralize2.isSingular = checkWord(
            irregularPlurals,
            irregularSingles,
            singularRules
          );
          pluralize2.addPluralRule = function(rule, replacement) {
            pluralRules.push([sanitizeRule(rule), replacement]);
          };
          pluralize2.addSingularRule = function(rule, replacement) {
            singularRules.push([sanitizeRule(rule), replacement]);
          };
          pluralize2.addUncountableRule = function(word) {
            if (typeof word === "string") {
              uncountables[word.toLowerCase()] = true;
              return;
            }
            pluralize2.addPluralRule(word, "$0");
            pluralize2.addSingularRule(word, "$0");
          };
          pluralize2.addIrregularRule = function(single, plural) {
            plural = plural.toLowerCase();
            single = single.toLowerCase();
            irregularSingles[single] = plural;
            irregularPlurals[plural] = single;
          };
          [
            ["I", "we"],
            ["me", "us"],
            ["he", "they"],
            ["she", "they"],
            ["them", "them"],
            ["myself", "ourselves"],
            ["yourself", "yourselves"],
            ["itself", "themselves"],
            ["herself", "themselves"],
            ["himself", "themselves"],
            ["themself", "themselves"],
            ["is", "are"],
            ["was", "were"],
            ["has", "have"],
            ["this", "these"],
            ["that", "those"],
            ["echo", "echoes"],
            ["dingo", "dingoes"],
            ["volcano", "volcanoes"],
            ["tornado", "tornadoes"],
            ["torpedo", "torpedoes"],
            ["genus", "genera"],
            ["viscus", "viscera"],
            ["stigma", "stigmata"],
            ["stoma", "stomata"],
            ["dogma", "dogmata"],
            ["lemma", "lemmata"],
            ["schema", "schemata"],
            ["anathema", "anathemata"],
            ["ox", "oxen"],
            ["axe", "axes"],
            ["die", "dice"],
            ["yes", "yeses"],
            ["foot", "feet"],
            ["eave", "eaves"],
            ["goose", "geese"],
            ["tooth", "teeth"],
            ["quiz", "quizzes"],
            ["human", "humans"],
            ["proof", "proofs"],
            ["carve", "carves"],
            ["valve", "valves"],
            ["looey", "looies"],
            ["thief", "thieves"],
            ["groove", "grooves"],
            ["pickaxe", "pickaxes"],
            ["passerby", "passersby"]
          ].forEach(function(rule) {
            return pluralize2.addIrregularRule(rule[0], rule[1]);
          });
          [
            [/s?$/i, "s"],
            [/[^\u0000-\u007F]$/i, "$0"],
            [/([^aeiou]ese)$/i, "$1"],
            [/(ax|test)is$/i, "$1es"],
            [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
            [/(e[mn]u)s?$/i, "$1s"],
            [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
            [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
            [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
            [/(seraph|cherub)(?:im)?$/i, "$1im"],
            [/(her|at|gr)o$/i, "$1oes"],
            [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
            [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
            [/sis$/i, "ses"],
            [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
            [/([^aeiouy]|qu)y$/i, "$1ies"],
            [/([^ch][ieo][ln])ey$/i, "$1ies"],
            [/(x|ch|ss|sh|zz)$/i, "$1es"],
            [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
            [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
            [/(pe)(?:rson|ople)$/i, "$1ople"],
            [/(child)(?:ren)?$/i, "$1ren"],
            [/eaux$/i, "$0"],
            [/m[ae]n$/i, "men"],
            ["thou", "you"]
          ].forEach(function(rule) {
            return pluralize2.addPluralRule(rule[0], rule[1]);
          });
          [
            [/s$/i, ""],
            [/(ss)$/i, "$1"],
            [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
            [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
            [/ies$/i, "y"],
            [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
            [/\b(mon|smil)ies$/i, "$1ey"],
            [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
            [/(seraph|cherub)im$/i, "$1"],
            [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
            [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
            [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
            [/(test)(?:is|es)$/i, "$1is"],
            [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
            [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
            [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
            [/(alumn|alg|vertebr)ae$/i, "$1a"],
            [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
            [/(matr|append)ices$/i, "$1ix"],
            [/(pe)(rson|ople)$/i, "$1rson"],
            [/(child)ren$/i, "$1"],
            [/(eau)x?$/i, "$1"],
            [/men$/i, "man"]
          ].forEach(function(rule) {
            return pluralize2.addSingularRule(rule[0], rule[1]);
          });
          [
            "adulthood",
            "advice",
            "agenda",
            "aid",
            "aircraft",
            "alcohol",
            "ammo",
            "analytics",
            "anime",
            "athletics",
            "audio",
            "bison",
            "blood",
            "bream",
            "buffalo",
            "butter",
            "carp",
            "cash",
            "chassis",
            "chess",
            "clothing",
            "cod",
            "commerce",
            "cooperation",
            "corps",
            "debris",
            "diabetes",
            "digestion",
            "elk",
            "energy",
            "equipment",
            "excretion",
            "expertise",
            "firmware",
            "flounder",
            "fun",
            "gallows",
            "garbage",
            "graffiti",
            "hardware",
            "headquarters",
            "health",
            "herpes",
            "highjinks",
            "homework",
            "housework",
            "information",
            "jeans",
            "justice",
            "kudos",
            "labour",
            "literature",
            "machinery",
            "mackerel",
            "mail",
            "media",
            "mews",
            "moose",
            "music",
            "mud",
            "manga",
            "news",
            "only",
            "personnel",
            "pike",
            "plankton",
            "pliers",
            "police",
            "pollution",
            "premises",
            "rain",
            "research",
            "rice",
            "salmon",
            "scissors",
            "series",
            "sewage",
            "shambles",
            "shrimp",
            "software",
            "species",
            "staff",
            "swine",
            "tennis",
            "traffic",
            "transportation",
            "trout",
            "tuna",
            "wealth",
            "welfare",
            "whiting",
            "wildebeest",
            "wildlife",
            "you",
            /pok[e]mon$/i,
            /[^aeiou]ese$/i,
            /deer$/i,
            /fish$/i,
            /measles$/i,
            /o[iu]s$/i,
            /pox$/i,
            /sheep$/i
          ].forEach(pluralize2.addUncountableRule);
          return pluralize2;
        });
      }
    });
    var require_is_regexp = __commonJS({
      "../../node_modules/.pnpm/is-regexp@2.1.0/node_modules/is-regexp/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (input) => Object.prototype.toString.call(input) === "[object RegExp]";
      }
    });
    var require_is_obj = __commonJS({
      "../../node_modules/.pnpm/is-obj@2.0.0/node_modules/is-obj/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (value) => {
          const type = typeof value;
          return value !== null && (type === "object" || type === "function");
        };
      }
    });
    var require_lib2 = __commonJS({
      "../../node_modules/.pnpm/get-own-enumerable-property-symbols@3.0.2/node_modules/get-own-enumerable-property-symbols/lib/index.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.default = (object) => Object.getOwnPropertySymbols(object).filter((keySymbol) => Object.prototype.propertyIsEnumerable.call(object, keySymbol));
      }
    });
    var require_package3 = __commonJS({
      "package.json"(exports2, module2) {
        module2.exports = {
          name: "@prisma/client",
          version: "4.7.1",
          description: "Prisma Client is an auto-generated, type-safe and modern JavaScript/TypeScript ORM for Node.js that's tailored to your data. Supports MySQL, PostgreSQL, MariaDB, SQLite databases.",
          keywords: [
            "orm",
            "prisma2",
            "prisma",
            "client",
            "query",
            "database",
            "sql",
            "postgres",
            "postgresql",
            "mysql",
            "sqlite",
            "mariadb",
            "mssql",
            "typescript",
            "query-builder"
          ],
          main: "index.js",
          browser: "index-browser.js",
          types: "index.d.ts",
          license: "Apache-2.0",
          engines: {
            node: ">=14.17"
          },
          homepage: "https://www.prisma.io",
          repository: {
            type: "git",
            url: "https://github.com/prisma/prisma.git",
            directory: "packages/client"
          },
          author: "Tim Suchanek <suchanek@prisma.io>",
          bugs: "https://github.com/prisma/prisma/issues",
          scripts: {
            dev: "DEV=true node -r esbuild-register helpers/build.ts",
            build: "node -r esbuild-register helpers/build.ts",
            test: "jest --verbose",
            "test:functional": "node -r esbuild-register helpers/functional-test/run-tests.ts",
            "test:memory": "node -r esbuild-register helpers/memory-tests.ts",
            "test:functional:code": "node -r esbuild-register helpers/functional-test/run-tests.ts --no-types",
            "test:functional:types": "node -r esbuild-register helpers/functional-test/run-tests.ts --types-only",
            "test-notypes": "jest --verbose --testPathIgnorePatterns src/__tests__/types/types.test.ts",
            generate: "node scripts/postinstall.js",
            postinstall: "node scripts/postinstall.js",
            prepublishOnly: "pnpm run build",
            "new-test": "NODE_OPTIONS='-r ts-node/register' yo ./helpers/generator-test/index.ts"
          },
          files: [
            "README.md",
            "runtime",
            "scripts",
            "generator-build",
            "edge.js",
            "edge.d.ts",
            "index.js",
            "index.d.ts",
            "index-browser.js"
          ],
          devDependencies: {
            "@faker-js/faker": "7.6.0",
            "@fast-check/jest": "1.4.0",
            "@jest/globals": "28.1.3",
            "@jest/test-sequencer": "28.1.3",
            "@opentelemetry/api": "1.2.0",
            "@opentelemetry/context-async-hooks": "1.7.0",
            "@opentelemetry/instrumentation": "0.33.0",
            "@opentelemetry/resources": "1.7.0",
            "@opentelemetry/sdk-trace-base": "1.7.0",
            "@opentelemetry/semantic-conventions": "1.7.0",
            "@prisma/debug": "workspace:4.7.1",
            "@prisma/engine-core": "workspace:4.7.1",
            "@prisma/engines": "workspace:4.7.1",
            "@prisma/fetch-engine": "workspace:4.7.1",
            "@prisma/generator-helper": "workspace:4.7.1",
            "@prisma/get-platform": "workspace:4.7.1",
            "@prisma/instrumentation": "workspace:4.7.1",
            "@prisma/internals": "workspace:4.7.1",
            "@prisma/migrate": "workspace:4.7.1",
            "@prisma/mini-proxy": "0.3.0",
            "@swc-node/register": "1.5.4",
            "@swc/core": "1.3.14",
            "@swc/jest": "0.2.23",
            "@timsuchanek/copy": "1.4.5",
            "@types/debug": "4.1.7",
            "@types/fs-extra": "9.0.13",
            "@types/jest": "28.1.8",
            "@types/js-levenshtein": "1.1.1",
            "@types/mssql": "8.1.1",
            "@types/node": "14.18.33",
            "@types/pg": "8.6.5",
            "@types/yeoman-generator": "5.2.11",
            arg: "5.0.2",
            benchmark: "2.1.4",
            chalk: "4.1.2",
            cuid: "2.1.8",
            "decimal.js": "10.4.2",
            esbuild: "0.15.13",
            execa: "5.1.1",
            "expect-type": "0.15.0",
            "flat-map-polyfill": "0.3.8",
            "fs-extra": "10.1.0",
            "fs-monkey": "1.0.3",
            "get-own-enumerable-property-symbols": "3.0.2",
            globby: "11.1.0",
            "indent-string": "4.0.0",
            "is-obj": "2.0.0",
            "is-regexp": "2.1.0",
            jest: "28.1.3",
            "jest-junit": "14.0.1",
            "jest-snapshot": "28.1.3",
            "js-levenshtein": "1.1.6",
            klona: "2.0.5",
            "lz-string": "1.4.4",
            "make-dir": "3.1.0",
            mariadb: "3.0.2",
            memfs: "3.4.10",
            mssql: "9.0.1",
            "node-fetch": "2.6.7",
            pg: "8.8.0",
            "pkg-up": "3.1.0",
            pluralize: "8.0.0",
            "replace-string": "3.1.0",
            resolve: "1.22.1",
            rimraf: "3.0.2",
            "simple-statistics": "7.8.0",
            "sort-keys": "4.2.0",
            "source-map-support": "0.5.21",
            "sql-template-tag": "5.0.3",
            "stacktrace-parser": "0.1.10",
            "strip-ansi": "6.0.1",
            "strip-indent": "3.0.0",
            "ts-jest": "28.0.8",
            "ts-node": "10.9.1",
            "ts-pattern": "4.0.5",
            tsd: "0.21.0",
            typescript: "4.8.4",
            "yeoman-generator": "5.7.0",
            yo: "4.3.1"
          },
          peerDependencies: {
            prisma: "*"
          },
          peerDependenciesMeta: {
            prisma: {
              optional: true
            }
          },
          dependencies: {
            "@prisma/engines-version": "4.7.1-1.272861e07ab64f234d3ffc4094e32bd61775599c"
          },
          sideEffects: false
        };
      }
    });
    var runtime_exports = {};
    __export(runtime_exports, {
      DMMF: () => DMMF,
      DMMFClass: () => DMMFHelper,
      Debug: () => Debug,
      Decimal: () => decimal_default,
      Engine: () => Engine,
      Extensions: () => extensions_exports,
      MetricsClient: () => MetricsClient,
      NotFoundError: () => NotFoundError2,
      PrismaClientExtensionError: () => PrismaClientExtensionError,
      PrismaClientInitializationError: () => PrismaClientInitializationError,
      PrismaClientKnownRequestError: () => PrismaClientKnownRequestError,
      PrismaClientRustPanicError: () => PrismaClientRustPanicError,
      PrismaClientUnknownRequestError: () => PrismaClientUnknownRequestError,
      PrismaClientValidationError: () => PrismaClientValidationError,
      Sql: () => Sql,
      Types: () => types_exports,
      decompressFromBase64: () => decompressFromBase642,
      empty: () => empty,
      findSync: () => findSync,
      getPrismaClient: () => getPrismaClient,
      join: () => join,
      makeDocument: () => makeDocument,
      makeStrictEnum: () => makeStrictEnum,
      objectEnumValues: () => objectEnumValues,
      raw: () => raw,
      sqltag: () => sql,
      transformDocument: () => transformDocument,
      unpack: () => unpack,
      warnEnvConflicts: () => warnEnvConflicts
    });
    module.exports = __toCommonJS(runtime_exports);
    var lzString = __toESM(require_lz_string());
    var extensions_exports = {};
    __export(extensions_exports, {
      defineExtension: () => defineExtension,
      getExtensionContext: () => getExtensionContext
    });
    function defineExtension(ext) {
      if (typeof ext === "function") {
        return ext;
      }
      return (client2) => client2.$extends(ext);
    }
    __name(defineExtension, "defineExtension");
    function getExtensionContext(that) {
      return that;
    }
    __name(getExtensionContext, "getExtensionContext");
    var types_exports = {};
    __export(types_exports, {
      Extensions: () => Extensions_exports,
      Utils: () => Utils_exports
    });
    var Extensions_exports = {};
    var Utils_exports = {};
    var import_debug = __toESM(require_src());
    var MAX_LOGS = 100;
    var debugArgsHistory = [];
    var _a;
    var _b;
    if (typeof process !== "undefined" && typeof ((_a = process.stderr) == null ? void 0 : _a.write) !== "function") {
      import_debug.default.log = (_b = console.debug) != null ? _b : console.log;
    }
    function debugCall(namespace) {
      const debugNamespace = (0, import_debug.default)(namespace);
      const call = Object.assign((...args) => {
        debugNamespace.log = call.log;
        if (args.length !== 0) {
          debugArgsHistory.push([namespace, ...args]);
        }
        if (debugArgsHistory.length > MAX_LOGS) {
          debugArgsHistory.shift();
        }
        return debugNamespace("", ...args);
      }, debugNamespace);
      return call;
    }
    __name(debugCall, "debugCall");
    var Debug = Object.assign(debugCall, import_debug.default);
    function getLogs(numChars = 7500) {
      const output = debugArgsHistory.map(
        (c) => c.map((item) => {
          if (typeof item === "string") {
            return item;
          }
          return JSON.stringify(item);
        }).join(" ")
      ).join("\n");
      if (output.length < numChars) {
        return output;
      }
      return output.slice(-numChars);
    }
    __name(getLogs, "getLogs");
    var src_default = Debug;
    var import_chalk = __toESM(require_source());
    var import_dotenv = __toESM(require_main2());
    var import_fs = __toESM(require("fs"));
    var import_path = __toESM(require("path"));
    function dotenvExpand(config2) {
      const environment = config2.ignoreProcessEnv ? {} : process.env;
      const interpolate = /* @__PURE__ */ __name((envValue) => {
        const matches = envValue.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g) || [];
        return matches.reduce(function(newEnv, match) {
          const parts = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(match);
          if (!parts) {
            return newEnv;
          }
          const prefix = parts[1];
          let value, replacePart;
          if (prefix === "\\") {
            replacePart = parts[0];
            value = replacePart.replace("\\$", "$");
          } else {
            const key = parts[2];
            replacePart = parts[0].substring(prefix.length);
            value = Object.hasOwnProperty.call(environment, key) ? environment[key] : config2.parsed[key] || "";
            value = interpolate(value);
          }
          return newEnv.replace(replacePart, value);
        }, envValue);
      }, "interpolate");
      for (const configKey in config2.parsed) {
        const value = Object.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config2.parsed[configKey];
        config2.parsed[configKey] = interpolate(value);
      }
      for (const processKey in config2.parsed) {
        environment[processKey] = config2.parsed[processKey];
      }
      return config2;
    }
    __name(dotenvExpand, "dotenvExpand");
    var debug2 = src_default("prisma:tryLoadEnv");
    function tryLoadEnvs({
      rootEnvPath,
      schemaEnvPath
    }, opts = {
      conflictCheck: "none"
    }) {
      var _a32, _b22;
      const rootEnvInfo = loadEnv(rootEnvPath);
      if (opts.conflictCheck !== "none") {
        checkForConflicts(rootEnvInfo, schemaEnvPath, opts.conflictCheck);
      }
      let schemaEnvInfo = null;
      if (!pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, schemaEnvPath)) {
        schemaEnvInfo = loadEnv(schemaEnvPath);
      }
      if (!rootEnvInfo && !schemaEnvInfo) {
        debug2("No Environment variables loaded");
      }
      if (schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult.error) {
        return console.error(import_chalk.default.redBright.bold("Schema Env Error: ") + schemaEnvInfo.dotenvResult.error);
      }
      const messages = [rootEnvInfo == null ? void 0 : rootEnvInfo.message, schemaEnvInfo == null ? void 0 : schemaEnvInfo.message].filter(Boolean);
      return {
        message: messages.join("\n"),
        parsed: {
          ...(_a32 = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult) == null ? void 0 : _a32.parsed,
          ...(_b22 = schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult) == null ? void 0 : _b22.parsed
        }
      };
    }
    __name(tryLoadEnvs, "tryLoadEnvs");
    function checkForConflicts(rootEnvInfo, envPath, type) {
      const parsedRootEnv = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult.parsed;
      const areNotTheSame = !pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, envPath);
      if (parsedRootEnv && envPath && areNotTheSame && import_fs.default.existsSync(envPath)) {
        const envConfig = import_dotenv.default.parse(import_fs.default.readFileSync(envPath));
        const conflicts = [];
        for (const k in envConfig) {
          if (parsedRootEnv[k] === envConfig[k]) {
            conflicts.push(k);
          }
        }
        if (conflicts.length > 0) {
          const relativeRootEnvPath = import_path.default.relative(process.cwd(), rootEnvInfo.path);
          const relativeEnvPath = import_path.default.relative(process.cwd(), envPath);
          if (type === "error") {
            const message = `There is a conflict between env var${conflicts.length > 1 ? "s" : ""} in ${import_chalk.default.underline(
              relativeRootEnvPath
            )} and ${import_chalk.default.underline(relativeEnvPath)}
Conflicting env vars:
${conflicts.map((conflict) => `  ${import_chalk.default.bold(conflict)}`).join("\n")}

We suggest to move the contents of ${import_chalk.default.underline(relativeEnvPath)} to ${import_chalk.default.underline(
              relativeRootEnvPath
            )} to consolidate your env vars.
`;
            throw new Error(message);
          } else if (type === "warn") {
            const message = `Conflict for env var${conflicts.length > 1 ? "s" : ""} ${conflicts.map((c) => import_chalk.default.bold(c)).join(", ")} in ${import_chalk.default.underline(relativeRootEnvPath)} and ${import_chalk.default.underline(relativeEnvPath)}
Env vars from ${import_chalk.default.underline(relativeEnvPath)} overwrite the ones from ${import_chalk.default.underline(relativeRootEnvPath)}
      `;
            console.warn(`${import_chalk.default.yellow("warn(prisma)")} ${message}`);
          }
        }
      }
    }
    __name(checkForConflicts, "checkForConflicts");
    function loadEnv(envPath) {
      if (exists(envPath)) {
        debug2(`Environment variables loaded from ${envPath}`);
        return {
          dotenvResult: dotenvExpand(
            import_dotenv.default.config({
              path: envPath,
              debug: process.env.DOTENV_CONFIG_DEBUG ? true : void 0
            })
          ),
          message: import_chalk.default.dim(`Environment variables loaded from ${import_path.default.relative(process.cwd(), envPath)}`),
          path: envPath
        };
      } else {
        debug2(`Environment variables not found at ${envPath}`);
      }
      return null;
    }
    __name(loadEnv, "loadEnv");
    function pathsEqual(path1, path22) {
      return path1 && path22 && import_path.default.resolve(path1) === import_path.default.resolve(path22);
    }
    __name(pathsEqual, "pathsEqual");
    function exists(p) {
      return Boolean(p && import_fs.default.existsSync(p));
    }
    __name(exists, "exists");
    var DEFAULT_CLIENT_ENGINE_TYPE = "library";
    function getClientEngineType(generatorConfig) {
      const engineTypeFromEnvVar = getEngineTypeFromEnvVar();
      if (engineTypeFromEnvVar)
        return engineTypeFromEnvVar;
      if ((generatorConfig == null ? void 0 : generatorConfig.config.engineType) === "library") {
        return "library";
      } else if ((generatorConfig == null ? void 0 : generatorConfig.config.engineType) === "binary") {
        return "binary";
      } else {
        return DEFAULT_CLIENT_ENGINE_TYPE;
      }
    }
    __name(getClientEngineType, "getClientEngineType");
    function getEngineTypeFromEnvVar() {
      const engineType = process.env.PRISMA_CLIENT_ENGINE_TYPE;
      if (engineType === "library") {
        return "library";
      } else if (engineType === "binary") {
        return "binary";
      } else {
        return void 0;
      }
    }
    __name(getEngineTypeFromEnvVar, "getEngineTypeFromEnvVar");
    var import_arg = __toESM(require_arg());
    var import_strip_indent = __toESM(require_strip_indent());
    function isError(result) {
      return result instanceof Error;
    }
    __name(isError, "isError");
    var import_engines_version = __toESM(require_engines_version());
    var NODE_API_QUERY_ENGINE_URL_BASE = "libquery_engine";
    function getNodeAPIName(platform3, type) {
      const isUrl = type === "url";
      if (platform3.includes("windows")) {
        return isUrl ? `query_engine.dll.node` : `query_engine-${platform3}.dll.node`;
      } else if (platform3.includes("darwin")) {
        return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.dylib.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform3}.dylib.node`;
      } else {
        return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.so.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform3}.so.node`;
      }
    }
    __name(getNodeAPIName, "getNodeAPIName");
    var import_child_process = require("child_process");
    var import_fs2 = __toESM(require("fs"));
    var import_os = __toESM(require("os"));
    var import_util = require("util");
    var readFile = (0, import_util.promisify)(import_fs2.default.readFile);
    var exists2 = (0, import_util.promisify)(import_fs2.default.exists);
    async function getos() {
      const platform3 = import_os.default.platform();
      const arch2 = process.arch;
      if (platform3 === "freebsd") {
        const version = await gracefulExec(`freebsd-version`);
        if (version && version.trim().length > 0) {
          const regex = /^(\d+)\.?/;
          const match = regex.exec(version);
          if (match) {
            return {
              platform: "freebsd",
              distro: `freebsd${match[1]}`,
              arch: arch2
            };
          }
        }
      }
      if (platform3 !== "linux") {
        return {
          platform: platform3,
          arch: arch2
        };
      }
      return {
        platform: "linux",
        libssl: await getOpenSSLVersion(),
        distro: await resolveDistro(),
        arch: arch2
      };
    }
    __name(getos, "getos");
    function parseDistro(input) {
      const idRegex = /^ID="?([^"\n]*)"?$/im;
      const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
      const idMatch = idRegex.exec(input);
      const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
      const idLikeMatch = idLikeRegex.exec(input);
      const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
      if (id === "raspbian") {
        return "arm";
      }
      if (id === "nixos") {
        return "nixos";
      }
      if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
        return "rhel";
      }
      if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
        return "debian";
      }
      return;
    }
    __name(parseDistro, "parseDistro");
    async function resolveDistro() {
      const osReleaseFile = "/etc/os-release";
      const alpineReleaseFile = "/etc/alpine-release";
      if (await exists2(alpineReleaseFile)) {
        return "musl";
      } else if (await exists2(osReleaseFile)) {
        return parseDistro(await readFile(osReleaseFile, "utf-8"));
      } else {
        return;
      }
    }
    __name(resolveDistro, "resolveDistro");
    function parseOpenSSLVersion(input) {
      const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
      if (match) {
        return match[1] + ".x";
      }
      return;
    }
    __name(parseOpenSSLVersion, "parseOpenSSLVersion");
    async function getOpenSSLVersion() {
      const [version, ls] = await Promise.all([
        gracefulExec(`openssl version -v`),
        gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
      ]);
      if (version) {
        const v = parseOpenSSLVersion(version);
        if (v) {
          return v;
        }
      }
      if (ls) {
        const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
        if (match) {
          return match[1] + ".x";
        }
      }
      return void 0;
    }
    __name(getOpenSSLVersion, "getOpenSSLVersion");
    async function gracefulExec(cmd) {
      return new Promise((resolve) => {
        try {
          (0, import_child_process.exec)(cmd, (err, stdout) => {
            resolve(String(stdout));
          });
        } catch (e) {
          resolve(void 0);
          return void 0;
        }
        return void 0;
      });
    }
    __name(gracefulExec, "gracefulExec");
    async function getPlatform() {
      const { platform: platform3, libssl, distro, arch: arch2 } = await getos();
      if (platform3 === "darwin" && arch2 === "arm64") {
        return "darwin-arm64";
      }
      if (platform3 === "darwin") {
        return "darwin";
      }
      if (platform3 === "win32") {
        return "windows";
      }
      if (platform3 === "freebsd") {
        return distro;
      }
      if (platform3 === "openbsd") {
        return "openbsd";
      }
      if (platform3 === "netbsd") {
        return "netbsd";
      }
      if (platform3 === "linux" && distro === "nixos") {
        return "linux-nixos";
      }
      if (platform3 === "linux" && arch2 === "arm64") {
        return `linux-arm64-openssl-${libssl}`;
      }
      if (platform3 === "linux" && arch2 === "arm") {
        return `linux-arm-openssl-${libssl}`;
      }
      if (platform3 === "linux" && distro === "musl") {
        return "linux-musl";
      }
      if (platform3 === "linux" && distro && libssl) {
        return distro + "-openssl-" + libssl;
      }
      if (libssl) {
        return "debian-openssl-" + libssl;
      }
      if (distro) {
        return distro + "-openssl-1.1.x";
      }
      return "debian-openssl-1.1.x";
    }
    __name(getPlatform, "getPlatform");
    var import_fs3 = __toESM(require("fs"));
    async function isNodeAPISupported() {
      const customLibraryPath = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
      const customLibraryExists = customLibraryPath && import_fs3.default.existsSync(customLibraryPath);
      const os32 = await getos();
      if (!customLibraryExists && (os32.arch === "x32" || os32.arch === "ia32")) {
        throw new Error(
          `The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set \`engineType = "binary"\` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)`
        );
      }
    }
    __name(isNodeAPISupported, "isNodeAPISupported");
    var platforms = [
      "darwin",
      "darwin-arm64",
      "debian-openssl-1.0.x",
      "debian-openssl-1.1.x",
      "debian-openssl-3.0.x",
      "rhel-openssl-1.0.x",
      "rhel-openssl-1.1.x",
      "rhel-openssl-3.0.x",
      "linux-arm64-openssl-1.1.x",
      "linux-arm64-openssl-1.0.x",
      "linux-arm64-openssl-3.0.x",
      "linux-arm-openssl-1.1.x",
      "linux-arm-openssl-1.0.x",
      "linux-arm-openssl-3.0.x",
      "linux-musl",
      "linux-nixos",
      "windows",
      "freebsd11",
      "freebsd12",
      "freebsd13",
      "openbsd",
      "netbsd",
      "arm"
    ];
    var import_path2 = __toESM(require("path"));
    var import_engines_version2 = __toESM(require_engines_version());
    var debug3 = src_default("prisma:engines");
    function getEnginesPath() {
      return import_path2.default.join(__dirname, "../");
    }
    __name(getEnginesPath, "getEnginesPath");
    var DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE = "libquery-engine";
    import_path2.default.join(__dirname, "../query-engine-darwin");
    import_path2.default.join(__dirname, "../introspection-engine-darwin");
    import_path2.default.join(__dirname, "../prisma-fmt-darwin");
    import_path2.default.join(__dirname, "../query-engine-darwin-arm64");
    import_path2.default.join(__dirname, "../introspection-engine-darwin-arm64");
    import_path2.default.join(__dirname, "../prisma-fmt-darwin-arm64");
    import_path2.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
    import_path2.default.join(__dirname, "../introspection-engine-debian-openssl-1.0.x");
    import_path2.default.join(__dirname, "../prisma-fmt-debian-openssl-1.0.x");
    import_path2.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
    import_path2.default.join(__dirname, "../introspection-engine-debian-openssl-1.1.x");
    import_path2.default.join(__dirname, "../prisma-fmt-debian-openssl-1.1.x");
    import_path2.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
    import_path2.default.join(__dirname, "../introspection-engine-debian-openssl-3.0.x");
    import_path2.default.join(__dirname, "../prisma-fmt-debian-openssl-3.0.x");
    import_path2.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
    import_path2.default.join(__dirname, "../introspection-engine-rhel-openssl-1.0.x");
    import_path2.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.0.x");
    import_path2.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
    import_path2.default.join(__dirname, "../introspection-engine-rhel-openssl-1.1.x");
    import_path2.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.1.x");
    import_path2.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
    import_path2.default.join(__dirname, "../introspection-engine-rhel-openssl-3.0.x");
    import_path2.default.join(__dirname, "../prisma-fmt-rhel-openssl-3.0.x");
    import_path2.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
    import_path2.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
    import_path2.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
    import_path2.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
    import_path2.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
    import_path2.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
    import_path2.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
    import_path2.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
    import_path2.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
    import_path2.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
    import_path2.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
    import_path2.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
    import_path2.default.join(__dirname, "../query_engine-windows.dll.node");
    var import_chalk3 = __toESM(require_source());
    var import_child_process2 = require("child_process");
    var import_execa = __toESM(require_execa());
    var import_fs5 = __toESM(require("fs"));
    var import_net = __toESM(require("net"));
    var import_p_retry = __toESM(require_p_retry());
    var import_path3 = __toESM(require("path"));
    var import_url = require("url");
    var import_util4 = require("util");
    var Engine = class {
    };
    __name(Engine, "Engine");
    var PrismaClientInitializationError = class extends Error {
      constructor(message, clientVersion2, errorCode) {
        super(message);
        this.clientVersion = clientVersion2;
        this.errorCode = errorCode;
        Error.captureStackTrace(PrismaClientInitializationError);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    };
    __name(PrismaClientInitializationError, "PrismaClientInitializationError");
    var PrismaClientKnownRequestError = class extends Error {
      constructor(message, { code, clientVersion: clientVersion2, meta, batchRequestIdx }) {
        super(message);
        this.code = code;
        this.clientVersion = clientVersion2;
        this.meta = meta;
        this.batchRequestIdx = batchRequestIdx;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    };
    __name(PrismaClientKnownRequestError, "PrismaClientKnownRequestError");
    function getMessage(log3) {
      if (typeof log3 === "string") {
        return log3;
      } else {
        return log3.message;
      }
    }
    __name(getMessage, "getMessage");
    function getBacktrace(log3) {
      var _a32, _b22, _c2, _d2, _e, _f, _g;
      if ((_a32 = log3.fields) == null ? void 0 : _a32.message) {
        let str = (_b22 = log3.fields) == null ? void 0 : _b22.message;
        if ((_c2 = log3.fields) == null ? void 0 : _c2.file) {
          str += ` in ${log3.fields.file}`;
          if ((_d2 = log3.fields) == null ? void 0 : _d2.line) {
            str += `:${log3.fields.line}`;
          }
          if ((_e = log3.fields) == null ? void 0 : _e.column) {
            str += `:${log3.fields.column}`;
          }
        }
        if ((_f = log3.fields) == null ? void 0 : _f.reason) {
          str += `
${(_g = log3.fields) == null ? void 0 : _g.reason}`;
        }
        return str;
      }
      return "Unknown error";
    }
    __name(getBacktrace, "getBacktrace");
    function isPanic(err) {
      var _a32;
      return ((_a32 = err.fields) == null ? void 0 : _a32.message) === "PANIC";
    }
    __name(isPanic, "isPanic");
    function isRustLog(e) {
      return e.timestamp && typeof e.level === "string" && typeof e.target === "string";
    }
    __name(isRustLog, "isRustLog");
    function isRustErrorLog(e) {
      var _a32, _b22;
      return isRustLog(e) && (e.level === "error" || ((_b22 = (_a32 = e.fields) == null ? void 0 : _a32.message) == null ? void 0 : _b22.includes("fatal error")));
    }
    __name(isRustErrorLog, "isRustErrorLog");
    function convertLog(rustLog) {
      const isQuery = isQueryLog(rustLog.fields);
      const level = isQuery ? "query" : rustLog.level.toLowerCase();
      return {
        ...rustLog,
        level,
        timestamp: new Date(rustLog.timestamp)
      };
    }
    __name(convertLog, "convertLog");
    function isQueryLog(fields) {
      return Boolean(fields.query);
    }
    __name(isQueryLog, "isQueryLog");
    var PrismaClientRustError = class extends Error {
      constructor({ clientVersion: clientVersion2, error: error2 }) {
        const backtrace = getBacktrace(error2);
        super(backtrace != null ? backtrace : "Unknown error");
        this._isPanic = isPanic(error2);
        this.clientVersion = clientVersion2;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
      isPanic() {
        return this._isPanic;
      }
    };
    __name(PrismaClientRustError, "PrismaClientRustError");
    var PrismaClientRustPanicError = class extends Error {
      constructor(message, clientVersion2) {
        super(message);
        this.clientVersion = clientVersion2;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    __name(PrismaClientRustPanicError, "PrismaClientRustPanicError");
    var PrismaClientUnknownRequestError = class extends Error {
      constructor(message, { clientVersion: clientVersion2, batchRequestIdx }) {
        super(message);
        this.clientVersion = clientVersion2;
        this.batchRequestIdx = batchRequestIdx;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    };
    __name(PrismaClientUnknownRequestError, "PrismaClientUnknownRequestError");
    var import_chalk2 = __toESM(require_source());
    var import_strip_ansi = __toESM(require_strip_ansi());
    var import_fs4 = __toESM(require("fs"));
    var import_new_github_issue_url = __toESM(require_new_github_issue_url());
    var debug4 = src_default("plusX");
    function plusX(file) {
      const s = import_fs4.default.statSync(file);
      const newMode = s.mode | 64 | 8 | 1;
      if (s.mode === newMode) {
        debug4(`Execution permissions of ${file} are fine`);
        return;
      }
      const base8 = newMode.toString(8).slice(-3);
      debug4(`Have to call plusX on ${file}`);
      import_fs4.default.chmodSync(file, base8);
    }
    __name(plusX, "plusX");
    function transformPlatformToEnvValue(platform3) {
      return { fromEnvVar: null, value: platform3 };
    }
    __name(transformPlatformToEnvValue, "transformPlatformToEnvValue");
    function fixBinaryTargets(binaryTargets, platform3) {
      binaryTargets = binaryTargets || [];
      if (!binaryTargets.find((object) => object.value === "native")) {
        return [transformPlatformToEnvValue("native"), ...binaryTargets];
      }
      return [...binaryTargets, transformPlatformToEnvValue(platform3)];
    }
    __name(fixBinaryTargets, "fixBinaryTargets");
    function getGitHubIssueUrl({
      title,
      user = "prisma",
      repo = "prisma",
      template = "bug_report.md",
      body
    }) {
      return (0, import_new_github_issue_url.default)({
        user,
        repo,
        template,
        title,
        body
      });
    }
    __name(getGitHubIssueUrl, "getGitHubIssueUrl");
    function maskQuery(query2) {
      if (!query2) {
        return "";
      }
      return query2.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (substr) => {
        return `${substr[0]}5`;
      });
    }
    __name(maskQuery, "maskQuery");
    function normalizeLogs(logs) {
      return logs.split("\n").map((l) => {
        return l.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "");
      }).join("\n");
    }
    __name(normalizeLogs, "normalizeLogs");
    function getErrorMessageWithLink({
      version,
      platform: platform3,
      title,
      description,
      engineVersion,
      database,
      query: query2
    }) {
      var _a32, _b22;
      const gotLogs = getLogs(6e3 - ((_a32 = query2 == null ? void 0 : query2.length) != null ? _a32 : 0));
      const logs = normalizeLogs((0, import_strip_ansi.default)(gotLogs));
      const moreInfo = description ? `# Description
\`\`\`
${description}
\`\`\`` : "";
      const body = (0, import_strip_ansi.default)(
        `Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${(_b22 = process.version) == null ? void 0 : _b22.padEnd(19)}| 
| OS              | ${platform3 == null ? void 0 : platform3.padEnd(19)}|
| Prisma Client   | ${version == null ? void 0 : version.padEnd(19)}|
| Query Engine    | ${engineVersion == null ? void 0 : engineVersion.padEnd(19)}|
| Database        | ${database == null ? void 0 : database.padEnd(19)}|

${moreInfo}

## Logs
\`\`\`
${logs}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${query2 ? maskQuery(query2) : ""}
\`\`\`
`
      );
      const url2 = getGitHubIssueUrl({ title, body });
      return `${title}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${import_chalk2.default.underline(url2)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
    }
    __name(getErrorMessageWithLink, "getErrorMessageWithLink");
    function prismaGraphQLToJSError({ error: error2, user_facing_error }, clientVersion2) {
      if (user_facing_error.error_code) {
        return new PrismaClientKnownRequestError(user_facing_error.message, {
          code: user_facing_error.error_code,
          clientVersion: clientVersion2,
          meta: user_facing_error.meta,
          batchRequestIdx: user_facing_error.batch_request_idx
        });
      }
      return new PrismaClientUnknownRequestError(error2, {
        clientVersion: clientVersion2,
        batchRequestIdx: user_facing_error.batch_request_idx
      });
    }
    __name(prismaGraphQLToJSError, "prismaGraphQLToJSError");
    var import_indent_string = __toESM(require_indent_string());
    function printGeneratorConfig(config2) {
      return String(new GeneratorConfigClass(config2));
    }
    __name(printGeneratorConfig, "printGeneratorConfig");
    var GeneratorConfigClass = class {
      constructor(config2) {
        this.config = config2;
      }
      toString() {
        const { config: config2 } = this;
        const provider = config2.provider.fromEnvVar ? `env("${config2.provider.fromEnvVar}")` : config2.provider.value;
        const obj = JSON.parse(
          JSON.stringify({
            provider,
            binaryTargets: getOriginalBinaryTargetsValue(config2.binaryTargets)
          })
        );
        return `generator ${config2.name} {
${(0, import_indent_string.default)(printDatamodelObject(obj), 2)}
}`;
      }
    };
    __name(GeneratorConfigClass, "GeneratorConfigClass");
    function getOriginalBinaryTargetsValue(binaryTargets) {
      let value;
      if (binaryTargets.length > 0) {
        const binaryTargetsFromEnvVar = binaryTargets.find((object) => object.fromEnvVar !== null);
        if (binaryTargetsFromEnvVar) {
          value = `env("${binaryTargetsFromEnvVar.fromEnvVar}")`;
        } else {
          value = binaryTargets.map((object) => object.value);
        }
      } else {
        value = void 0;
      }
      return value;
    }
    __name(getOriginalBinaryTargetsValue, "getOriginalBinaryTargetsValue");
    function printDatamodelObject(obj) {
      const maxLength = Object.keys(obj).reduce((max2, curr) => Math.max(max2, curr.length), 0);
      return Object.entries(obj).map(([key, value]) => `${key.padEnd(maxLength)} = ${niceStringify(value)}`).join("\n");
    }
    __name(printDatamodelObject, "printDatamodelObject");
    function niceStringify(value) {
      return JSON.parse(
        JSON.stringify(value, (_, value2) => {
          if (Array.isArray(value2)) {
            return `[${value2.map((element) => JSON.stringify(element)).join(", ")}]`;
          }
          return JSON.stringify(value2);
        })
      );
    }
    __name(niceStringify, "niceStringify");
    var import_stream = __toESM(require("stream"));
    var import_util3 = __toESM(require("util"));
    function byline(readStream2, options) {
      return createStream(readStream2, options);
    }
    __name(byline, "byline");
    function createStream(readStream2, options) {
      if (readStream2) {
        return createLineStream(readStream2, options);
      } else {
        return new LineStream(options);
      }
    }
    __name(createStream, "createStream");
    function createLineStream(readStream2, options) {
      if (!readStream2) {
        throw new Error("expected readStream");
      }
      if (!readStream2.readable) {
        throw new Error("readStream must be readable");
      }
      const ls = new LineStream(options);
      readStream2.pipe(ls);
      return ls;
    }
    __name(createLineStream, "createLineStream");
    function LineStream(options) {
      import_stream.default.Transform.call(this, options);
      options = options || {};
      this._readableState.objectMode = true;
      this._lineBuffer = [];
      this._keepEmptyLines = options.keepEmptyLines || false;
      this._lastChunkEndedWithCR = false;
      this.on("pipe", function(src) {
        if (!this.encoding) {
          if (src instanceof import_stream.default.Readable) {
            this.encoding = src._readableState.encoding;
          }
        }
      });
    }
    __name(LineStream, "LineStream");
    import_util3.default.inherits(LineStream, import_stream.default.Transform);
    LineStream.prototype._transform = function(chunk, encoding, done) {
      encoding = encoding || "utf8";
      if (Buffer.isBuffer(chunk)) {
        if (encoding == "buffer") {
          chunk = chunk.toString();
          encoding = "utf8";
        } else {
          chunk = chunk.toString(encoding);
        }
      }
      this._chunkEncoding = encoding;
      const lines = chunk.split(/\r\n|\r|\n/g);
      if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
        lines.shift();
      }
      if (this._lineBuffer.length > 0) {
        this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
        lines.shift();
      }
      this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
      this._lineBuffer = this._lineBuffer.concat(lines);
      this._pushBuffer(encoding, 1, done);
    };
    LineStream.prototype._pushBuffer = function(encoding, keep, done) {
      while (this._lineBuffer.length > keep) {
        const line = this._lineBuffer.shift();
        if (this._keepEmptyLines || line.length > 0) {
          if (!this.push(this._reencode(line, encoding))) {
            const self2 = this;
            setImmediate(function() {
              self2._pushBuffer(encoding, keep, done);
            });
            return;
          }
        }
      }
      done();
    };
    LineStream.prototype._flush = function(done) {
      this._pushBuffer(this._chunkEncoding, 0, done);
    };
    LineStream.prototype._reencode = function(line, chunkEncoding) {
      if (this.encoding && this.encoding != chunkEncoding) {
        return Buffer.from(line, chunkEncoding).toString(this.encoding);
      } else if (this.encoding) {
        return line;
      } else {
        return Buffer.from(line, chunkEncoding);
      }
    };
    function omit(obj, keys2) {
      return Object.keys(obj).filter((key) => !keys2.includes(key)).reduce((result, key) => {
        result[key] = obj[key];
        return result;
      }, {});
    }
    __name(omit, "omit");
    var _globalThis = typeof globalThis === "object" ? globalThis : global;
    var VERSION = "1.2.0";
    var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    function _makeCompatibilityCheck(ownVersion) {
      var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
      var rejectedVersions = /* @__PURE__ */ new Set();
      var myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
        return function() {
          return false;
        };
      }
      var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      if (ownVersionParsed.prerelease != null) {
        return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {
          return globalVersion === ownVersion;
        }, "isExactmatch");
      }
      function _reject(v) {
        rejectedVersions.add(v);
        return false;
      }
      __name(_reject, "_reject");
      function _accept(v) {
        acceptedVersions.add(v);
        return true;
      }
      __name(_accept, "_accept");
      return /* @__PURE__ */ __name(function isCompatible2(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
          return true;
        }
        if (rejectedVersions.has(globalVersion)) {
          return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
          return _reject(globalVersion);
        }
        var globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
          if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
            return _accept(globalVersion);
          }
          return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }, "isCompatible");
    }
    __name(_makeCompatibilityCheck, "_makeCompatibilityCheck");
    var isCompatible = _makeCompatibilityCheck(VERSION);
    var major = VERSION.split(".")[0];
    var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    var _global = _globalThis;
    function registerGlobal(type, instance, diag3, allowOverride) {
      var _a32;
      if (allowOverride === void 0) {
        allowOverride = false;
      }
      var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a32 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a32 !== void 0 ? _a32 : {
        version: VERSION
      };
      if (!allowOverride && api[type]) {
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag3.error(err.stack || err.message);
        return false;
      }
      if (api.version !== VERSION) {
        var err = new Error("@opentelemetry/api: All API registration versions must match");
        diag3.error(err.stack || err.message);
        return false;
      }
      api[type] = instance;
      diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
      return true;
    }
    __name(registerGlobal, "registerGlobal");
    function getGlobal(type) {
      var _a32, _b22;
      var globalVersion = (_a32 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a32 === void 0 ? void 0 : _a32.version;
      if (!globalVersion || !isCompatible(globalVersion)) {
        return;
      }
      return (_b22 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b22 === void 0 ? void 0 : _b22[type];
    }
    __name(getGlobal, "getGlobal");
    function unregisterGlobal(type, diag3) {
      diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
      var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
        delete api[type];
      }
    }
    __name(unregisterGlobal, "unregisterGlobal");
    var DiagComponentLogger = function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      __name(DiagComponentLogger2, "DiagComponentLogger");
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
    function logProxy(funcName, namespace, args) {
      var logger2 = getGlobal("diag");
      if (!logger2) {
        return;
      }
      args.unshift(namespace);
      return logger2[funcName].apply(logger2, args);
    }
    __name(logProxy, "logProxy");
    var DiagLogLevel;
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
    function createLogLevelDiagLogger(maxLevel, logger2) {
      if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
      } else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
      }
      logger2 = logger2 || {};
      function _filterFunc(funcName, theLevel) {
        var theFunc = logger2[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
          return theFunc.bind(logger2);
        }
        return function() {
        };
      }
      __name(_filterFunc, "_filterFunc");
      return {
        error: _filterFunc("error", DiagLogLevel.ERROR),
        warn: _filterFunc("warn", DiagLogLevel.WARN),
        info: _filterFunc("info", DiagLogLevel.INFO),
        debug: _filterFunc("debug", DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
      };
    }
    __name(createLogLevelDiagLogger, "createLogLevelDiagLogger");
    var API_NAME = "diag";
    var DiagAPI = function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger2 = getGlobal("diag");
            if (!logger2)
              return;
            return logger2[funcName].apply(logger2, args);
          };
        }
        __name(_logProxy, "_logProxy");
        var self2 = this;
        self2.setLogger = function(logger2, logLevel) {
          var _a32, _b22;
          if (logLevel === void 0) {
            logLevel = DiagLogLevel.INFO;
          }
          if (logger2 === self2) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a32 = err.stack) !== null && _a32 !== void 0 ? _a32 : err.message);
            return false;
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger(logLevel, logger2);
          if (oldLogger) {
            var stack = (_b22 = new Error().stack) !== null && _b22 !== void 0 ? _b22 : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self2, true);
        };
        self2.disable = function() {
          unregisterGlobal(API_NAME, self2);
        };
        self2.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      __name(DiagAPI2, "DiagAPI");
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
    var BaggageImpl = function() {
      function BaggageImpl2(entries2) {
        this._entries = entries2 ? new Map(entries2) : /* @__PURE__ */ new Map();
      }
      __name(BaggageImpl2, "BaggageImpl");
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a32) {
          var k = _a32[0], v = _a32[1];
          return [k, v];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var keys2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys2[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        for (var _a32 = 0, keys_1 = keys2; _a32 < keys_1.length; _a32++) {
          var key = keys_1[_a32];
          newBaggage._entries.delete(key);
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
    var baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
    var diag = DiagAPI.instance();
    function createBaggage(entries2) {
      if (entries2 === void 0) {
        entries2 = {};
      }
      return new BaggageImpl(new Map(Object.entries(entries2)));
    }
    __name(createBaggage, "createBaggage");
    function baggageEntryMetadataFromString(str) {
      if (typeof str !== "string") {
        diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
        str = "";
      }
      return {
        __TYPE__: baggageEntryMetadataSymbol,
        toString: function() {
          return str;
        }
      };
    }
    __name(baggageEntryMetadataFromString, "baggageEntryMetadataFromString");
    var consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    var DiagConsoleLogger = function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        __name(_consoleFunc, "_consoleFunc");
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      __name(DiagConsoleLogger2, "DiagConsoleLogger");
      return DiagConsoleLogger2;
    }();
    var defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    var defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
    function createContextKey(description) {
      return Symbol.for(description);
    }
    __name(createContextKey, "createContextKey");
    var BaseContext = function() {
      function BaseContext2(parentContext) {
        var self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = function(key) {
          return self2._currentContext.get(key);
        };
        self2.setValue = function(key, value) {
          var context3 = new BaseContext2(self2._currentContext);
          context3._currentContext.set(key, value);
          return context3;
        };
        self2.deleteValue = function(key) {
          var context3 = new BaseContext2(self2._currentContext);
          context3._currentContext.delete(key);
          return context3;
        };
      }
      __name(BaseContext2, "BaseContext");
      return BaseContext2;
    }();
    var ROOT_CONTEXT = new BaseContext();
    var __spreadArray = function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    var NoopContextManager = function() {
      function NoopContextManager2() {
      }
      __name(NoopContextManager2, "NoopContextManager");
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray([thisArg], args));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
    var __spreadArray2 = function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    var API_NAME2 = "context";
    var NOOP_CONTEXT_MANAGER = new NoopContextManager();
    var ContextAPI = function() {
      function ContextAPI2() {
      }
      __name(ContextAPI2, "ContextAPI");
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context3, fn, thisArg) {
        var _a32;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a32 = this._getContextManager()).with.apply(_a32, __spreadArray2([context3, fn, thisArg], args));
      };
      ContextAPI2.prototype.bind = function(context3, target) {
        return this._getContextManager().bind(context3, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
    var TraceFlags;
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
    var INVALID_SPANID = "0000000000000000";
    var INVALID_TRACEID = "00000000000000000000000000000000";
    var INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
    var NonRecordingSpan = function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      __name(NonRecordingSpan2, "NonRecordingSpan");
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
    var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
    function getSpan(context3) {
      return context3.getValue(SPAN_KEY) || void 0;
    }
    __name(getSpan, "getSpan");
    function getActiveSpan() {
      return getSpan(ContextAPI.getInstance().active());
    }
    __name(getActiveSpan, "getActiveSpan");
    function setSpan(context3, span) {
      return context3.setValue(SPAN_KEY, span);
    }
    __name(setSpan, "setSpan");
    function deleteSpan(context3) {
      return context3.deleteValue(SPAN_KEY);
    }
    __name(deleteSpan, "deleteSpan");
    function setSpanContext(context3, spanContext) {
      return setSpan(context3, new NonRecordingSpan(spanContext));
    }
    __name(setSpanContext, "setSpanContext");
    function getSpanContext(context3) {
      var _a32;
      return (_a32 = getSpan(context3)) === null || _a32 === void 0 ? void 0 : _a32.spanContext();
    }
    __name(getSpanContext, "getSpanContext");
    var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
    }
    __name(isValidTraceId, "isValidTraceId");
    function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
    }
    __name(isValidSpanId, "isValidSpanId");
    function isSpanContextValid(spanContext) {
      return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
    }
    __name(isSpanContextValid, "isSpanContextValid");
    function wrapSpanContext(spanContext) {
      return new NonRecordingSpan(spanContext);
    }
    __name(wrapSpanContext, "wrapSpanContext");
    var context = ContextAPI.getInstance();
    var NoopTracer = function() {
      function NoopTracer2() {
      }
      __name(NoopTracer2, "NoopTracer");
      NoopTracer2.prototype.startSpan = function(name, options, context3) {
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context3 && getSpanContext(context3);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return context.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
    function isSpanContext(spanContext) {
      return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
    }
    __name(isSpanContext, "isSpanContext");
    var NOOP_TRACER = new NoopTracer();
    var ProxyTracer = function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      __name(ProxyTracer2, "ProxyTracer");
      ProxyTracer2.prototype.startSpan = function(name, options, context3) {
        return this._getTracer().startSpan(name, options, context3);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
    var NoopTracerProvider = function() {
      function NoopTracerProvider2() {
      }
      __name(NoopTracerProvider2, "NoopTracerProvider");
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
    var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    var ProxyTracerProvider = function() {
      function ProxyTracerProvider2() {
      }
      __name(ProxyTracerProvider2, "ProxyTracerProvider");
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a32;
        return (_a32 = this.getDelegateTracer(name, version, options)) !== null && _a32 !== void 0 ? _a32 : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a32;
        return (_a32 = this._delegate) !== null && _a32 !== void 0 ? _a32 : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a32;
        return (_a32 = this._delegate) === null || _a32 === void 0 ? void 0 : _a32.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    }();
    var SamplingDecision;
    (function(SamplingDecision3) {
      SamplingDecision3[SamplingDecision3["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision3[SamplingDecision3["RECORD"] = 1] = "RECORD";
      SamplingDecision3[SamplingDecision3["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
    var SpanKind;
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
    var SpanStatusCode;
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    __name(validateKey, "validateKey");
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }
    __name(validateValue, "validateValue");
    var MAX_TRACE_STATE_ITEMS = 32;
    var MAX_TRACE_STATE_LEN = 512;
    var LIST_MEMBERS_SEPARATOR = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    var TraceStateImpl = function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      __name(TraceStateImpl2, "TraceStateImpl");
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    }();
    var API_NAME3 = "trace";
    var TraceAPI = function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      __name(TraceAPI2, "TraceAPI");
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME3) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
    var NoopTextMapPropagator = function() {
      function NoopTextMapPropagator2() {
      }
      __name(NoopTextMapPropagator2, "NoopTextMapPropagator");
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context3, _carrier) {
        return context3;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
    var BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
    function getBaggage(context3) {
      return context3.getValue(BAGGAGE_KEY) || void 0;
    }
    __name(getBaggage, "getBaggage");
    function setBaggage(context3, baggage) {
      return context3.setValue(BAGGAGE_KEY, baggage);
    }
    __name(setBaggage, "setBaggage");
    function deleteBaggage(context3) {
      return context3.deleteValue(BAGGAGE_KEY);
    }
    __name(deleteBaggage, "deleteBaggage");
    var API_NAME4 = "propagation";
    var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    var PropagationAPI = function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      __name(PropagationAPI2, "PropagationAPI");
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context3, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context3, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context3, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context3, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
    var context2 = ContextAPI.getInstance();
    var trace = TraceAPI.getInstance();
    var propagation = PropagationAPI.getInstance();
    var diag2 = DiagAPI.instance();
    var SUPPRESS_TRACING_KEY = createContextKey("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context3) {
      return context3.setValue(SUPPRESS_TRACING_KEY, true);
    }
    __name(suppressTracing, "suppressTracing");
    function isTracingSuppressed(context3) {
      return context3.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    __name(isTracingSuppressed, "isTracingSuppressed");
    var BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    var BAGGAGE_PROPERTIES_SEPARATOR = ";";
    var BAGGAGE_ITEMS_SEPARATOR = ",";
    var BAGGAGE_HEADER = "baggage";
    var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    var BAGGAGE_MAX_TOTAL_LENGTH = 8192;
    var __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce(function(hValue, current) {
        var value = "" + hValue + (hValue !== "" ? BAGGAGE_ITEMS_SEPARATOR : "") + current;
        return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    __name(serializeKeyPairs, "serializeKeyPairs");
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(function(_a32) {
        var _b22 = __read(_a32, 2), key = _b22[0], value = _b22[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        if (value.metadata !== void 0) {
          entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    __name(getKeyPairs, "getKeyPairs");
    function parsePairKeyValue(entry) {
      var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      var keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      var keyPair = keyPairPart.split(BAGGAGE_KEY_PAIR_SEPARATOR);
      if (keyPair.length !== 2)
        return;
      var key = decodeURIComponent(keyPair[0].trim());
      var value = decodeURIComponent(keyPair[1].trim());
      var metadata;
      if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    __name(parsePairKeyValue, "parsePairKeyValue");
    var W3CBaggagePropagator = function() {
      function W3CBaggagePropagator2() {
      }
      __name(W3CBaggagePropagator2, "W3CBaggagePropagator");
      W3CBaggagePropagator2.prototype.inject = function(context3, carrier, setter) {
        var baggage = propagation.getBaggage(context3);
        if (!baggage || isTracingSuppressed(context3))
          return;
        var keyPairs = getKeyPairs(baggage).filter(function(pair) {
          return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, BAGGAGE_HEADER, headerValue);
        }
      };
      W3CBaggagePropagator2.prototype.extract = function(context3, carrier, getter) {
        var headerValue = getter.get(carrier, BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context3;
        var baggage = {};
        if (baggageString.length === 0) {
          return context3;
        }
        var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function(entry) {
          var keyPair = parsePairKeyValue(entry);
          if (keyPair) {
            var baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context3;
        }
        return propagation.setBaggage(context3, propagation.createBaggage(baggage));
      };
      W3CBaggagePropagator2.prototype.fields = function() {
        return [BAGGAGE_HEADER];
      };
      return W3CBaggagePropagator2;
    }();
    var AnchoredClock = function() {
      function AnchoredClock2(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      __name(AnchoredClock2, "AnchoredClock");
      AnchoredClock2.prototype.now = function() {
        var delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      };
      return AnchoredClock2;
    }();
    var __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    function sanitizeAttributes(attributes) {
      var e_1, _a32;
      var out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      try {
        for (var _b22 = __values(Object.entries(attributes)), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
          var _d2 = __read2(_c2.value, 2), key = _d2[0], val = _d2[1];
          if (!isAttributeKey(key)) {
            diag2.warn("Invalid attribute key: " + key);
            continue;
          }
          if (!isAttributeValue(val)) {
            diag2.warn("Invalid attribute value set for key: " + key);
            continue;
          }
          if (Array.isArray(val)) {
            out[key] = val.slice();
          } else {
            out[key] = val;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c2 && !_c2.done && (_a32 = _b22.return))
            _a32.call(_b22);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return out;
    }
    __name(sanitizeAttributes, "sanitizeAttributes");
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    __name(isAttributeKey, "isAttributeKey");
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    __name(isAttributeValue, "isAttributeValue");
    function isHomogeneousAttributeValueArray(arr) {
      var e_2, _a32;
      var type;
      try {
        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
          var element = arr_1_1.value;
          if (element == null)
            continue;
          if (!type) {
            if (isValidPrimitiveAttributeValue(element)) {
              type = typeof element;
              continue;
            }
            return false;
          }
          if (typeof element === type) {
            continue;
          }
          return false;
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (arr_1_1 && !arr_1_1.done && (_a32 = arr_1.return))
            _a32.call(arr_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return true;
    }
    __name(isHomogeneousAttributeValueArray, "isHomogeneousAttributeValueArray");
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
    __name(isValidPrimitiveAttributeValue, "isValidPrimitiveAttributeValue");
    function loggingErrorHandler() {
      return function(ex) {
        diag2.error(stringifyException(ex));
      };
    }
    __name(loggingErrorHandler, "loggingErrorHandler");
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    __name(stringifyException, "stringifyException");
    function flattenException(ex) {
      var result = {};
      var current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(function(propertyName) {
          if (result[propertyName])
            return;
          var value = current[propertyName];
          if (value) {
            result[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result;
    }
    __name(flattenException, "flattenException");
    var delegateHandler = loggingErrorHandler();
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a32) {
      }
    }
    __name(globalErrorHandler, "globalErrorHandler");
    var os2 = __toESM(require("os"));
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues || (TracesSamplerValues = {}));
    var _globalThis2 = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    __name(isEnvVarANumber, "isEnvVarANumber");
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    __name(isEnvVarAList, "isEnvVarAList");
    var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    var DEFAULT_ENVIRONMENT = {
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_TRACES_EXPORTER: "none",
      OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: ""
    };
    function parseNumber(name, environment, values, min2, max2) {
      if (min2 === void 0) {
        min2 = -Infinity;
      }
      if (max2 === void 0) {
        max2 = Infinity;
      }
      if (typeof values[name] !== "undefined") {
        var value = Number(values[name]);
        if (!isNaN(value)) {
          if (value < min2) {
            environment[name] = min2;
          } else if (value > max2) {
            environment[name] = max2;
          } else {
            environment[name] = value;
          }
        }
      }
    }
    __name(parseNumber, "parseNumber");
    function parseStringList(name, output, input, separator) {
      if (separator === void 0) {
        separator = DEFAULT_LIST_SEPARATOR;
      }
      var givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map(function(v) {
          return v.trim();
        });
      }
    }
    __name(parseStringList, "parseStringList");
    var logLevelMap = {
      ALL: DiagLogLevel.ALL,
      VERBOSE: DiagLogLevel.VERBOSE,
      DEBUG: DiagLogLevel.DEBUG,
      INFO: DiagLogLevel.INFO,
      WARN: DiagLogLevel.WARN,
      ERROR: DiagLogLevel.ERROR,
      NONE: DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment, values) {
      var value = values[key];
      if (typeof value === "string") {
        var theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment[key] = theLevel;
        }
      }
    }
    __name(setLogLevelFromEnv, "setLogLevelFromEnv");
    function parseEnvironment(values) {
      var environment = {};
      for (var env2 in DEFAULT_ENVIRONMENT) {
        var key = env2;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarANumber(key)) {
              parseNumber(key, environment, values);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment, values);
            } else {
              var value = values[key];
              if (typeof value !== "undefined" && value !== null) {
                environment[key] = String(value);
              }
            }
        }
      }
      return environment;
    }
    __name(parseEnvironment, "parseEnvironment");
    function getEnvWithoutDefaults() {
      return typeof process !== "undefined" ? parseEnvironment(process.env) : parseEnvironment(_globalThis2);
    }
    __name(getEnvWithoutDefaults, "getEnvWithoutDefaults");
    function getEnv() {
      var processEnv = parseEnvironment(process.env);
      return Object.assign({
        HOSTNAME: os2.hostname()
      }, DEFAULT_ENVIRONMENT, processEnv);
    }
    __name(getEnv, "getEnv");
    var _globalThis3 = typeof globalThis === "object" ? globalThis : global;
    var buf8 = Buffer.alloc(8);
    var buf16 = Buffer.alloc(16);
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = function() {
      function RandomIdGenerator3() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
      __name(RandomIdGenerator3, "RandomIdGenerator");
      return RandomIdGenerator3;
    }();
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return /* @__PURE__ */ __name(function generateId() {
        for (var i = 0; i < bytes / 4; i++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);
        }
        for (var i = 0; i < bytes; i++) {
          if (SHARED_BUFFER[i] > 0) {
            break;
          } else if (i === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      }, "generateId");
    }
    __name(getIdGenerator, "getIdGenerator");
    var import_perf_hooks = require("perf_hooks");
    var otperformance = import_perf_hooks.performance;
    var VERSION2 = "1.7.0";
    var SemanticAttributes = {
      AWS_LAMBDA_INVOKED_ARN: "aws.lambda.invoked_arn",
      DB_SYSTEM: "db.system",
      DB_CONNECTION_STRING: "db.connection_string",
      DB_USER: "db.user",
      DB_JDBC_DRIVER_CLASSNAME: "db.jdbc.driver_classname",
      DB_NAME: "db.name",
      DB_STATEMENT: "db.statement",
      DB_OPERATION: "db.operation",
      DB_MSSQL_INSTANCE_NAME: "db.mssql.instance_name",
      DB_CASSANDRA_KEYSPACE: "db.cassandra.keyspace",
      DB_CASSANDRA_PAGE_SIZE: "db.cassandra.page_size",
      DB_CASSANDRA_CONSISTENCY_LEVEL: "db.cassandra.consistency_level",
      DB_CASSANDRA_TABLE: "db.cassandra.table",
      DB_CASSANDRA_IDEMPOTENCE: "db.cassandra.idempotence",
      DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: "db.cassandra.speculative_execution_count",
      DB_CASSANDRA_COORDINATOR_ID: "db.cassandra.coordinator.id",
      DB_CASSANDRA_COORDINATOR_DC: "db.cassandra.coordinator.dc",
      DB_HBASE_NAMESPACE: "db.hbase.namespace",
      DB_REDIS_DATABASE_INDEX: "db.redis.database_index",
      DB_MONGODB_COLLECTION: "db.mongodb.collection",
      DB_SQL_TABLE: "db.sql.table",
      EXCEPTION_TYPE: "exception.type",
      EXCEPTION_MESSAGE: "exception.message",
      EXCEPTION_STACKTRACE: "exception.stacktrace",
      EXCEPTION_ESCAPED: "exception.escaped",
      FAAS_TRIGGER: "faas.trigger",
      FAAS_EXECUTION: "faas.execution",
      FAAS_DOCUMENT_COLLECTION: "faas.document.collection",
      FAAS_DOCUMENT_OPERATION: "faas.document.operation",
      FAAS_DOCUMENT_TIME: "faas.document.time",
      FAAS_DOCUMENT_NAME: "faas.document.name",
      FAAS_TIME: "faas.time",
      FAAS_CRON: "faas.cron",
      FAAS_COLDSTART: "faas.coldstart",
      FAAS_INVOKED_NAME: "faas.invoked_name",
      FAAS_INVOKED_PROVIDER: "faas.invoked_provider",
      FAAS_INVOKED_REGION: "faas.invoked_region",
      NET_TRANSPORT: "net.transport",
      NET_PEER_IP: "net.peer.ip",
      NET_PEER_PORT: "net.peer.port",
      NET_PEER_NAME: "net.peer.name",
      NET_HOST_IP: "net.host.ip",
      NET_HOST_PORT: "net.host.port",
      NET_HOST_NAME: "net.host.name",
      NET_HOST_CONNECTION_TYPE: "net.host.connection.type",
      NET_HOST_CONNECTION_SUBTYPE: "net.host.connection.subtype",
      NET_HOST_CARRIER_NAME: "net.host.carrier.name",
      NET_HOST_CARRIER_MCC: "net.host.carrier.mcc",
      NET_HOST_CARRIER_MNC: "net.host.carrier.mnc",
      NET_HOST_CARRIER_ICC: "net.host.carrier.icc",
      PEER_SERVICE: "peer.service",
      ENDUSER_ID: "enduser.id",
      ENDUSER_ROLE: "enduser.role",
      ENDUSER_SCOPE: "enduser.scope",
      THREAD_ID: "thread.id",
      THREAD_NAME: "thread.name",
      CODE_FUNCTION: "code.function",
      CODE_NAMESPACE: "code.namespace",
      CODE_FILEPATH: "code.filepath",
      CODE_LINENO: "code.lineno",
      HTTP_METHOD: "http.method",
      HTTP_URL: "http.url",
      HTTP_TARGET: "http.target",
      HTTP_HOST: "http.host",
      HTTP_SCHEME: "http.scheme",
      HTTP_STATUS_CODE: "http.status_code",
      HTTP_FLAVOR: "http.flavor",
      HTTP_USER_AGENT: "http.user_agent",
      HTTP_REQUEST_CONTENT_LENGTH: "http.request_content_length",
      HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: "http.request_content_length_uncompressed",
      HTTP_RESPONSE_CONTENT_LENGTH: "http.response_content_length",
      HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: "http.response_content_length_uncompressed",
      HTTP_SERVER_NAME: "http.server_name",
      HTTP_ROUTE: "http.route",
      HTTP_CLIENT_IP: "http.client_ip",
      AWS_DYNAMODB_TABLE_NAMES: "aws.dynamodb.table_names",
      AWS_DYNAMODB_CONSUMED_CAPACITY: "aws.dynamodb.consumed_capacity",
      AWS_DYNAMODB_ITEM_COLLECTION_METRICS: "aws.dynamodb.item_collection_metrics",
      AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: "aws.dynamodb.provisioned_read_capacity",
      AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: "aws.dynamodb.provisioned_write_capacity",
      AWS_DYNAMODB_CONSISTENT_READ: "aws.dynamodb.consistent_read",
      AWS_DYNAMODB_PROJECTION: "aws.dynamodb.projection",
      AWS_DYNAMODB_LIMIT: "aws.dynamodb.limit",
      AWS_DYNAMODB_ATTRIBUTES_TO_GET: "aws.dynamodb.attributes_to_get",
      AWS_DYNAMODB_INDEX_NAME: "aws.dynamodb.index_name",
      AWS_DYNAMODB_SELECT: "aws.dynamodb.select",
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: "aws.dynamodb.global_secondary_indexes",
      AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: "aws.dynamodb.local_secondary_indexes",
      AWS_DYNAMODB_EXCLUSIVE_START_TABLE: "aws.dynamodb.exclusive_start_table",
      AWS_DYNAMODB_TABLE_COUNT: "aws.dynamodb.table_count",
      AWS_DYNAMODB_SCAN_FORWARD: "aws.dynamodb.scan_forward",
      AWS_DYNAMODB_SEGMENT: "aws.dynamodb.segment",
      AWS_DYNAMODB_TOTAL_SEGMENTS: "aws.dynamodb.total_segments",
      AWS_DYNAMODB_COUNT: "aws.dynamodb.count",
      AWS_DYNAMODB_SCANNED_COUNT: "aws.dynamodb.scanned_count",
      AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: "aws.dynamodb.attribute_definitions",
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: "aws.dynamodb.global_secondary_index_updates",
      MESSAGING_SYSTEM: "messaging.system",
      MESSAGING_DESTINATION: "messaging.destination",
      MESSAGING_DESTINATION_KIND: "messaging.destination_kind",
      MESSAGING_TEMP_DESTINATION: "messaging.temp_destination",
      MESSAGING_PROTOCOL: "messaging.protocol",
      MESSAGING_PROTOCOL_VERSION: "messaging.protocol_version",
      MESSAGING_URL: "messaging.url",
      MESSAGING_MESSAGE_ID: "messaging.message_id",
      MESSAGING_CONVERSATION_ID: "messaging.conversation_id",
      MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: "messaging.message_payload_size_bytes",
      MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: "messaging.message_payload_compressed_size_bytes",
      MESSAGING_OPERATION: "messaging.operation",
      MESSAGING_CONSUMER_ID: "messaging.consumer_id",
      MESSAGING_RABBITMQ_ROUTING_KEY: "messaging.rabbitmq.routing_key",
      MESSAGING_KAFKA_MESSAGE_KEY: "messaging.kafka.message_key",
      MESSAGING_KAFKA_CONSUMER_GROUP: "messaging.kafka.consumer_group",
      MESSAGING_KAFKA_CLIENT_ID: "messaging.kafka.client_id",
      MESSAGING_KAFKA_PARTITION: "messaging.kafka.partition",
      MESSAGING_KAFKA_TOMBSTONE: "messaging.kafka.tombstone",
      RPC_SYSTEM: "rpc.system",
      RPC_SERVICE: "rpc.service",
      RPC_METHOD: "rpc.method",
      RPC_GRPC_STATUS_CODE: "rpc.grpc.status_code",
      RPC_JSONRPC_VERSION: "rpc.jsonrpc.version",
      RPC_JSONRPC_REQUEST_ID: "rpc.jsonrpc.request_id",
      RPC_JSONRPC_ERROR_CODE: "rpc.jsonrpc.error_code",
      RPC_JSONRPC_ERROR_MESSAGE: "rpc.jsonrpc.error_message",
      MESSAGE_TYPE: "message.type",
      MESSAGE_ID: "message.id",
      MESSAGE_COMPRESSED_SIZE: "message.compressed_size",
      MESSAGE_UNCOMPRESSED_SIZE: "message.uncompressed_size"
    };
    var SemanticResourceAttributes = {
      CLOUD_PROVIDER: "cloud.provider",
      CLOUD_ACCOUNT_ID: "cloud.account.id",
      CLOUD_REGION: "cloud.region",
      CLOUD_AVAILABILITY_ZONE: "cloud.availability_zone",
      CLOUD_PLATFORM: "cloud.platform",
      AWS_ECS_CONTAINER_ARN: "aws.ecs.container.arn",
      AWS_ECS_CLUSTER_ARN: "aws.ecs.cluster.arn",
      AWS_ECS_LAUNCHTYPE: "aws.ecs.launchtype",
      AWS_ECS_TASK_ARN: "aws.ecs.task.arn",
      AWS_ECS_TASK_FAMILY: "aws.ecs.task.family",
      AWS_ECS_TASK_REVISION: "aws.ecs.task.revision",
      AWS_EKS_CLUSTER_ARN: "aws.eks.cluster.arn",
      AWS_LOG_GROUP_NAMES: "aws.log.group.names",
      AWS_LOG_GROUP_ARNS: "aws.log.group.arns",
      AWS_LOG_STREAM_NAMES: "aws.log.stream.names",
      AWS_LOG_STREAM_ARNS: "aws.log.stream.arns",
      CONTAINER_NAME: "container.name",
      CONTAINER_ID: "container.id",
      CONTAINER_RUNTIME: "container.runtime",
      CONTAINER_IMAGE_NAME: "container.image.name",
      CONTAINER_IMAGE_TAG: "container.image.tag",
      DEPLOYMENT_ENVIRONMENT: "deployment.environment",
      DEVICE_ID: "device.id",
      DEVICE_MODEL_IDENTIFIER: "device.model.identifier",
      DEVICE_MODEL_NAME: "device.model.name",
      FAAS_NAME: "faas.name",
      FAAS_ID: "faas.id",
      FAAS_VERSION: "faas.version",
      FAAS_INSTANCE: "faas.instance",
      FAAS_MAX_MEMORY: "faas.max_memory",
      HOST_ID: "host.id",
      HOST_NAME: "host.name",
      HOST_TYPE: "host.type",
      HOST_ARCH: "host.arch",
      HOST_IMAGE_NAME: "host.image.name",
      HOST_IMAGE_ID: "host.image.id",
      HOST_IMAGE_VERSION: "host.image.version",
      K8S_CLUSTER_NAME: "k8s.cluster.name",
      K8S_NODE_NAME: "k8s.node.name",
      K8S_NODE_UID: "k8s.node.uid",
      K8S_NAMESPACE_NAME: "k8s.namespace.name",
      K8S_POD_UID: "k8s.pod.uid",
      K8S_POD_NAME: "k8s.pod.name",
      K8S_CONTAINER_NAME: "k8s.container.name",
      K8S_REPLICASET_UID: "k8s.replicaset.uid",
      K8S_REPLICASET_NAME: "k8s.replicaset.name",
      K8S_DEPLOYMENT_UID: "k8s.deployment.uid",
      K8S_DEPLOYMENT_NAME: "k8s.deployment.name",
      K8S_STATEFULSET_UID: "k8s.statefulset.uid",
      K8S_STATEFULSET_NAME: "k8s.statefulset.name",
      K8S_DAEMONSET_UID: "k8s.daemonset.uid",
      K8S_DAEMONSET_NAME: "k8s.daemonset.name",
      K8S_JOB_UID: "k8s.job.uid",
      K8S_JOB_NAME: "k8s.job.name",
      K8S_CRONJOB_UID: "k8s.cronjob.uid",
      K8S_CRONJOB_NAME: "k8s.cronjob.name",
      OS_TYPE: "os.type",
      OS_DESCRIPTION: "os.description",
      OS_NAME: "os.name",
      OS_VERSION: "os.version",
      PROCESS_PID: "process.pid",
      PROCESS_EXECUTABLE_NAME: "process.executable.name",
      PROCESS_EXECUTABLE_PATH: "process.executable.path",
      PROCESS_COMMAND: "process.command",
      PROCESS_COMMAND_LINE: "process.command_line",
      PROCESS_COMMAND_ARGS: "process.command_args",
      PROCESS_OWNER: "process.owner",
      PROCESS_RUNTIME_NAME: "process.runtime.name",
      PROCESS_RUNTIME_VERSION: "process.runtime.version",
      PROCESS_RUNTIME_DESCRIPTION: "process.runtime.description",
      SERVICE_NAME: "service.name",
      SERVICE_NAMESPACE: "service.namespace",
      SERVICE_INSTANCE_ID: "service.instance.id",
      SERVICE_VERSION: "service.version",
      TELEMETRY_SDK_NAME: "telemetry.sdk.name",
      TELEMETRY_SDK_LANGUAGE: "telemetry.sdk.language",
      TELEMETRY_SDK_VERSION: "telemetry.sdk.version",
      TELEMETRY_AUTO_VERSION: "telemetry.auto.version",
      WEBENGINE_NAME: "webengine.name",
      WEBENGINE_VERSION: "webengine.version",
      WEBENGINE_DESCRIPTION: "webengine.description"
    };
    var TelemetrySdkLanguageValues = {
      CPP: "cpp",
      DOTNET: "dotnet",
      ERLANG: "erlang",
      GO: "go",
      JAVA: "java",
      NODEJS: "nodejs",
      PHP: "php",
      PYTHON: "python",
      RUBY: "ruby",
      WEBJS: "webjs"
    };
    var _a2;
    var SDK_INFO = (_a2 = {}, _a2[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = "opentelemetry", _a2[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = "node", _a2[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = TelemetrySdkLanguageValues.NODEJS, _a2[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = VERSION2, _a2);
    function unrefTimer(timer2) {
      timer2.unref();
    }
    __name(unrefTimer, "unrefTimer");
    var NANOSECOND_DIGITS = 9;
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function numberToHrtime(epochMillis) {
      var epochSeconds = epochMillis / 1e3;
      var seconds = Math.trunc(epochSeconds);
      var nanos = Number((epochSeconds - seconds).toFixed(NANOSECOND_DIGITS)) * SECOND_TO_NANOSECONDS;
      return [seconds, nanos];
    }
    __name(numberToHrtime, "numberToHrtime");
    function getTimeOrigin() {
      var timeOrigin = otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        var perf = otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    __name(getTimeOrigin, "getTimeOrigin");
    function hrTime(performanceNow) {
      var timeOrigin = numberToHrtime(getTimeOrigin());
      var now = numberToHrtime(typeof performanceNow === "number" ? performanceNow : otperformance.now());
      var seconds = timeOrigin[0] + now[0];
      var nanos = timeOrigin[1] + now[1];
      if (nanos > SECOND_TO_NANOSECONDS) {
        nanos -= SECOND_TO_NANOSECONDS;
        seconds += 1;
      }
      return [seconds, nanos];
    }
    __name(hrTime, "hrTime");
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return numberToHrtime(time);
        }
      } else if (time instanceof Date) {
        return numberToHrtime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    __name(timeInputToHrTime, "timeInputToHrTime");
    function hrTimeDuration(startTime, endTime) {
      var seconds = endTime[0] - startTime[0];
      var nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    __name(hrTimeDuration, "hrTimeDuration");
    function hrTimeToMicroseconds(time) {
      return Math.round(time[0] * 1e6 + time[1] / 1e3);
    }
    __name(hrTimeToMicroseconds, "hrTimeToMicroseconds");
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    __name(isTimeInputHrTime, "isTimeInputHrTime");
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    __name(isTimeInput, "isTimeInput");
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode || (ExportResultCode = {}));
    var __values2 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var CompositePropagator = function() {
      function CompositePropagator2(config2) {
        if (config2 === void 0) {
          config2 = {};
        }
        var _a32;
        this._propagators = (_a32 = config2.propagators) !== null && _a32 !== void 0 ? _a32 : [];
        this._fields = Array.from(new Set(this._propagators.map(function(p) {
          return typeof p.fields === "function" ? p.fields() : [];
        }).reduce(function(x, y) {
          return x.concat(y);
        }, [])));
      }
      __name(CompositePropagator2, "CompositePropagator");
      CompositePropagator2.prototype.inject = function(context3, carrier, setter) {
        var e_1, _a32;
        try {
          for (var _b22 = __values2(this._propagators), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var propagator = _c2.value;
            try {
              propagator.inject(context3, carrier, setter);
            } catch (err) {
              diag2.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      };
      CompositePropagator2.prototype.extract = function(context3, carrier, getter) {
        return this._propagators.reduce(function(ctx, propagator) {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            diag2.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
          }
          return ctx;
        }, context3);
      };
      CompositePropagator2.prototype.fields = function() {
        return this._fields.slice();
      };
      return CompositePropagator2;
    }();
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = "[a-z]" + VALID_KEY_CHAR_RANGE2 + "{0,255}";
    var VALID_VENDOR_KEY2 = "[a-z0-9]" + VALID_KEY_CHAR_RANGE2 + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE2 + "{0,13}";
    var VALID_KEY_REGEX2 = new RegExp("^(?:" + VALID_KEY2 + "|" + VALID_VENDOR_KEY2 + ")$");
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    __name(validateKey2, "validateKey");
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    __name(validateValue2, "validateValue");
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = function() {
      function TraceState2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      __name(TraceState2, "TraceState");
      TraceState2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceState2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceState2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceState2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      };
      TraceState2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey2(key) && validateValue2(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      };
      TraceState2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceState2.prototype._clone = function() {
        var traceState = new TraceState2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceState2;
    }();
    var TRACE_PARENT_HEADER = "traceparent";
    var TRACE_STATE_HEADER = "tracestate";
    var VERSION3 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
    function parseTraceParent(traceParent) {
      var match = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match)
        return null;
      if (match[1] === "00" && match[5])
        return null;
      return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    __name(parseTraceParent, "parseTraceParent");
    var W3CTraceContextPropagator = function() {
      function W3CTraceContextPropagator2() {
      }
      __name(W3CTraceContextPropagator2, "W3CTraceContextPropagator");
      W3CTraceContextPropagator2.prototype.inject = function(context3, carrier, setter) {
        var spanContext = trace.getSpanContext(context3);
        if (!spanContext || isTracingSuppressed(context3) || !isSpanContextValid(spanContext))
          return;
        var traceParent = VERSION3 + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      };
      W3CTraceContextPropagator2.prototype.extract = function(context3, carrier, getter) {
        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context3;
        var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context3;
        var spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context3;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
          var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState(typeof state === "string" ? state : void 0);
        }
        return trace.setSpanContext(context3, spanContext);
      };
      W3CTraceContextPropagator2.prototype.fields = function() {
        return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];
      };
      return W3CTraceContextPropagator2;
    }();
    var RPC_METADATA_KEY = createContextKey("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType || (RPCType = {}));
    var AlwaysOffSampler = function() {
      function AlwaysOffSampler3() {
      }
      __name(AlwaysOffSampler3, "AlwaysOffSampler");
      AlwaysOffSampler3.prototype.shouldSample = function() {
        return {
          decision: SamplingDecision.NOT_RECORD
        };
      };
      AlwaysOffSampler3.prototype.toString = function() {
        return "AlwaysOffSampler";
      };
      return AlwaysOffSampler3;
    }();
    var AlwaysOnSampler = function() {
      function AlwaysOnSampler3() {
      }
      __name(AlwaysOnSampler3, "AlwaysOnSampler");
      AlwaysOnSampler3.prototype.shouldSample = function() {
        return {
          decision: SamplingDecision.RECORD_AND_SAMPLED
        };
      };
      AlwaysOnSampler3.prototype.toString = function() {
        return "AlwaysOnSampler";
      };
      return AlwaysOnSampler3;
    }();
    var ParentBasedSampler = function() {
      function ParentBasedSampler3(config2) {
        var _a32, _b22, _c2, _d2;
        this._root = config2.root;
        if (!this._root) {
          globalErrorHandler(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a32 = config2.remoteParentSampled) !== null && _a32 !== void 0 ? _a32 : new AlwaysOnSampler();
        this._remoteParentNotSampled = (_b22 = config2.remoteParentNotSampled) !== null && _b22 !== void 0 ? _b22 : new AlwaysOffSampler();
        this._localParentSampled = (_c2 = config2.localParentSampled) !== null && _c2 !== void 0 ? _c2 : new AlwaysOnSampler();
        this._localParentNotSampled = (_d2 = config2.localParentNotSampled) !== null && _d2 !== void 0 ? _d2 : new AlwaysOffSampler();
      }
      __name(ParentBasedSampler3, "ParentBasedSampler");
      ParentBasedSampler3.prototype.shouldSample = function(context3, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context3);
        if (!parentContext || !isSpanContextValid(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      };
      ParentBasedSampler3.prototype.toString = function() {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
      };
      return ParentBasedSampler3;
    }();
    var TraceIdRatioBasedSampler = function() {
      function TraceIdRatioBasedSampler3(_ratio) {
        if (_ratio === void 0) {
          _ratio = 0;
        }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      __name(TraceIdRatioBasedSampler3, "TraceIdRatioBasedSampler");
      TraceIdRatioBasedSampler3.prototype.shouldSample = function(context3, traceId) {
        return {
          decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD
        };
      };
      TraceIdRatioBasedSampler3.prototype.toString = function() {
        return "TraceIdRatioBased{" + this._ratio + "}";
      };
      TraceIdRatioBasedSampler3.prototype._normalize = function(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      };
      TraceIdRatioBasedSampler3.prototype._accumulate = function(traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
          var pos = i * 8;
          var part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      };
      return TraceIdRatioBasedSampler3;
    }();
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func, transform) {
      return function(arg2) {
        return func(transform(arg2));
      };
    }
    __name(overArg, "overArg");
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    __name(isPlainObject, "isPlainObject");
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    __name(baseGetTag, "baseGetTag");
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
      var unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag2;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    __name(getRawTag, "getRawTag");
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    __name(objectToString, "objectToString");
    var MAX_LEVEL = 20;
    function merge() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = args.shift();
      var objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      }
      return result;
    }
    __name(merge, "merge");
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    __name(takeValue, "takeValue");
    function mergeTwoObjects(one, two, level, objects) {
      if (level === void 0) {
        level = 0;
      }
      var result;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
      } else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
          for (var i = 0, j = two.length; i < j; i++) {
            result.push(takeValue(two[i]));
          }
        } else if (isObject(two)) {
          var keys2 = Object.keys(two);
          for (var i = 0, j = keys2.length; i < j; i++) {
            var key = keys2[i];
            result[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result = Object.assign({}, one);
          var keys2 = Object.keys(two);
          for (var i = 0, j = keys2.length; i < j; i++) {
            var key = keys2[i];
            var twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result[key];
              } else {
                result[key] = twoValue;
              }
            } else {
              var obj1 = result[key];
              var obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  var arr1 = objects.get(obj1) || [];
                  var arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result = two;
        }
      }
      return result;
    }
    __name(mergeTwoObjects, "mergeTwoObjects");
    function wasObjectReferenced(obj, key, objects) {
      var arr = objects.get(obj[key]) || [];
      for (var i = 0, j = arr.length; i < j; i++) {
        var info2 = arr[i];
        if (info2.key === key && info2.obj === obj) {
          return true;
        }
      }
      return false;
    }
    __name(wasObjectReferenced, "wasObjectReferenced");
    function isArray(value) {
      return Array.isArray(value);
    }
    __name(isArray, "isArray");
    function isFunction(value) {
      return typeof value === "function";
    }
    __name(isFunction, "isFunction");
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    __name(isObject, "isObject");
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    __name(isPrimitive, "isPrimitive");
    function shouldMerge(one, two) {
      if (!isPlainObject(one) || !isPlainObject(two)) {
        return false;
      }
      return true;
    }
    __name(shouldMerge, "shouldMerge");
    var Deferred = function() {
      function Deferred2() {
        var _this = this;
        this._promise = new Promise(function(resolve, reject) {
          _this._resolve = resolve;
          _this._reject = reject;
        });
      }
      __name(Deferred2, "Deferred");
      Object.defineProperty(Deferred2.prototype, "promise", {
        get: function() {
          return this._promise;
        },
        enumerable: false,
        configurable: true
      });
      Deferred2.prototype.resolve = function(val) {
        this._resolve(val);
      };
      Deferred2.prototype.reject = function(err) {
        this._reject(err);
      };
      return Deferred2;
    }();
    var __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var BindOnceFuture = function() {
      function BindOnceFuture2(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new Deferred();
      }
      __name(BindOnceFuture2, "BindOnceFuture");
      Object.defineProperty(BindOnceFuture2.prototype, "isCalled", {
        get: function() {
          return this._isCalled;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BindOnceFuture2.prototype, "promise", {
        get: function() {
          return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
      });
      BindOnceFuture2.prototype.call = function() {
        var _a32;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve((_a32 = this._callback).call.apply(_a32, __spreadArray3([this._that], __read3(args), false))).then(function(val) {
              return _this._deferred.resolve(val);
            }, function(err) {
              return _this._deferred.reject(err);
            });
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      };
      return BindOnceFuture2;
    }();
    var ExceptionEventName = "exception";
    var __values3 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var Span = function() {
      function Span3(parentTracer, context3, spanName, spanContext, kind, parentSpanId, links, startTime, clock) {
        if (links === void 0) {
          links = [];
        }
        if (clock === void 0) {
          clock = otperformance;
        }
        this.attributes = {};
        this.links = [];
        this.events = [];
        this.status = {
          code: SpanStatusCode.UNSET
        };
        this.endTime = [0, 0];
        this._ended = false;
        this._duration = [-1, -1];
        this._clock = clock;
        this.name = spanName;
        this._spanContext = spanContext;
        this.parentSpanId = parentSpanId;
        this.kind = kind;
        this.links = links;
        this.startTime = timeInputToHrTime(startTime !== null && startTime !== void 0 ? startTime : clock.now());
        this.resource = parentTracer.resource;
        this.instrumentationLibrary = parentTracer.instrumentationLibrary;
        this._spanLimits = parentTracer.getSpanLimits();
        this._spanProcessor = parentTracer.getActiveSpanProcessor();
        this._spanProcessor.onStart(this, context3);
        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
      }
      __name(Span3, "Span");
      Span3.prototype.spanContext = function() {
        return this._spanContext;
      };
      Span3.prototype.setAttribute = function(key, value) {
        if (value == null || this._isSpanEnded())
          return this;
        if (key.length === 0) {
          diag2.warn("Invalid attribute key: " + key);
          return this;
        }
        if (!isAttributeValue(value)) {
          diag2.warn("Invalid attribute value set for key: " + key);
          return this;
        }
        if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
          return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
      };
      Span3.prototype.setAttributes = function(attributes) {
        var e_1, _a32;
        try {
          for (var _b22 = __values3(Object.entries(attributes)), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var _d2 = __read4(_c2.value, 2), k = _d2[0], v = _d2[1];
            this.setAttribute(k, v);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return this;
      };
      Span3.prototype.addEvent = function(name, attributesOrStartTime, startTime) {
        if (this._isSpanEnded())
          return this;
        if (this._spanLimits.eventCountLimit === 0) {
          diag2.warn("No events allowed.");
          return this;
        }
        if (this.events.length >= this._spanLimits.eventCountLimit) {
          diag2.warn("Dropping extra events.");
          this.events.shift();
        }
        if (isTimeInput(attributesOrStartTime)) {
          if (typeof startTime === "undefined") {
            startTime = attributesOrStartTime;
          }
          attributesOrStartTime = void 0;
        }
        if (typeof startTime === "undefined") {
          startTime = this._clock.now();
        }
        var attributes = sanitizeAttributes(attributesOrStartTime);
        this.events.push({
          name,
          attributes,
          time: timeInputToHrTime(startTime)
        });
        return this;
      };
      Span3.prototype.setStatus = function(status) {
        if (this._isSpanEnded())
          return this;
        this.status = status;
        return this;
      };
      Span3.prototype.updateName = function(name) {
        if (this._isSpanEnded())
          return this;
        this.name = name;
        return this;
      };
      Span3.prototype.end = function(endTime) {
        if (this._isSpanEnded()) {
          diag2.error("You can only call end() on a span once.");
          return;
        }
        this._ended = true;
        this.endTime = timeInputToHrTime(endTime !== null && endTime !== void 0 ? endTime : this._clock.now());
        this._duration = hrTimeDuration(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
          diag2.warn("Inconsistent start and end time, startTime > endTime", this.startTime, this.endTime);
        }
        this._spanProcessor.onEnd(this);
      };
      Span3.prototype.isRecording = function() {
        return this._ended === false;
      };
      Span3.prototype.recordException = function(exception, time) {
        if (time === void 0) {
          time = this._clock.now();
        }
        var attributes = {};
        if (typeof exception === "string") {
          attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;
        } else if (exception) {
          if (exception.code) {
            attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();
          } else if (exception.name) {
            attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;
          }
          if (exception.message) {
            attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;
          }
          if (exception.stack) {
            attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;
          }
        }
        if (attributes[SemanticAttributes.EXCEPTION_TYPE] || attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {
          this.addEvent(ExceptionEventName, attributes, time);
        } else {
          diag2.warn("Failed to record an exception " + exception);
        }
      };
      Object.defineProperty(Span3.prototype, "duration", {
        get: function() {
          return this._duration;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Span3.prototype, "ended", {
        get: function() {
          return this._ended;
        },
        enumerable: false,
        configurable: true
      });
      Span3.prototype._isSpanEnded = function() {
        if (this._ended) {
          diag2.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}");
        }
        return this._ended;
      };
      Span3.prototype._truncateToLimitUtil = function(value, limit) {
        if (value.length <= limit) {
          return value;
        }
        return value.substr(0, limit);
      };
      Span3.prototype._truncateToSize = function(value) {
        var _this = this;
        var limit = this._attributeValueLengthLimit;
        if (limit <= 0) {
          diag2.warn("Attribute value limit must be positive, got " + limit);
          return value;
        }
        if (typeof value === "string") {
          return this._truncateToLimitUtil(value, limit);
        }
        if (Array.isArray(value)) {
          return value.map(function(val) {
            return typeof val === "string" ? _this._truncateToLimitUtil(val, limit) : val;
          });
        }
        return value;
      };
      return Span3;
    }();
    var SamplingDecision2;
    (function(SamplingDecision3) {
      SamplingDecision3[SamplingDecision3["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision3[SamplingDecision3["RECORD"] = 1] = "RECORD";
      SamplingDecision3[SamplingDecision3["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision2 || (SamplingDecision2 = {}));
    var AlwaysOffSampler2 = function() {
      function AlwaysOffSampler3() {
      }
      __name(AlwaysOffSampler3, "AlwaysOffSampler");
      AlwaysOffSampler3.prototype.shouldSample = function() {
        return {
          decision: SamplingDecision2.NOT_RECORD
        };
      };
      AlwaysOffSampler3.prototype.toString = function() {
        return "AlwaysOffSampler";
      };
      return AlwaysOffSampler3;
    }();
    var AlwaysOnSampler2 = function() {
      function AlwaysOnSampler3() {
      }
      __name(AlwaysOnSampler3, "AlwaysOnSampler");
      AlwaysOnSampler3.prototype.shouldSample = function() {
        return {
          decision: SamplingDecision2.RECORD_AND_SAMPLED
        };
      };
      AlwaysOnSampler3.prototype.toString = function() {
        return "AlwaysOnSampler";
      };
      return AlwaysOnSampler3;
    }();
    var ParentBasedSampler2 = function() {
      function ParentBasedSampler3(config2) {
        var _a32, _b22, _c2, _d2;
        this._root = config2.root;
        if (!this._root) {
          globalErrorHandler(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler2();
        }
        this._remoteParentSampled = (_a32 = config2.remoteParentSampled) !== null && _a32 !== void 0 ? _a32 : new AlwaysOnSampler2();
        this._remoteParentNotSampled = (_b22 = config2.remoteParentNotSampled) !== null && _b22 !== void 0 ? _b22 : new AlwaysOffSampler2();
        this._localParentSampled = (_c2 = config2.localParentSampled) !== null && _c2 !== void 0 ? _c2 : new AlwaysOnSampler2();
        this._localParentNotSampled = (_d2 = config2.localParentNotSampled) !== null && _d2 !== void 0 ? _d2 : new AlwaysOffSampler2();
      }
      __name(ParentBasedSampler3, "ParentBasedSampler");
      ParentBasedSampler3.prototype.shouldSample = function(context3, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context3);
        if (!parentContext || !isSpanContextValid(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      };
      ParentBasedSampler3.prototype.toString = function() {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
      };
      return ParentBasedSampler3;
    }();
    var TraceIdRatioBasedSampler2 = function() {
      function TraceIdRatioBasedSampler3(_ratio) {
        if (_ratio === void 0) {
          _ratio = 0;
        }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      __name(TraceIdRatioBasedSampler3, "TraceIdRatioBasedSampler");
      TraceIdRatioBasedSampler3.prototype.shouldSample = function(context3, traceId) {
        return {
          decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision2.RECORD_AND_SAMPLED : SamplingDecision2.NOT_RECORD
        };
      };
      TraceIdRatioBasedSampler3.prototype.toString = function() {
        return "TraceIdRatioBased{" + this._ratio + "}";
      };
      TraceIdRatioBasedSampler3.prototype._normalize = function(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      };
      TraceIdRatioBasedSampler3.prototype._accumulate = function(traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
          var pos = i * 8;
          var part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      };
      return TraceIdRatioBasedSampler3;
    }();
    var env = getEnv();
    var FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;
    var DEFAULT_RATIO = 1;
    function loadDefaultConfig() {
      return {
        sampler: buildSamplerFromEnv(env),
        forceFlushTimeoutMillis: 3e4,
        generalLimits: {
          attributeValueLengthLimit: getEnv().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: getEnv().OTEL_ATTRIBUTE_COUNT_LIMIT
        },
        spanLimits: {
          attributeValueLengthLimit: getEnv().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
          linkCountLimit: getEnv().OTEL_SPAN_LINK_COUNT_LIMIT,
          eventCountLimit: getEnv().OTEL_SPAN_EVENT_COUNT_LIMIT
        }
      };
    }
    __name(loadDefaultConfig, "loadDefaultConfig");
    function buildSamplerFromEnv(environment) {
      if (environment === void 0) {
        environment = getEnv();
      }
      switch (environment.OTEL_TRACES_SAMPLER) {
        case TracesSamplerValues.AlwaysOn:
          return new AlwaysOnSampler2();
        case TracesSamplerValues.AlwaysOff:
          return new AlwaysOffSampler2();
        case TracesSamplerValues.ParentBasedAlwaysOn:
          return new ParentBasedSampler2({
            root: new AlwaysOnSampler2()
          });
        case TracesSamplerValues.ParentBasedAlwaysOff:
          return new ParentBasedSampler2({
            root: new AlwaysOffSampler2()
          });
        case TracesSamplerValues.TraceIdRatio:
          return new TraceIdRatioBasedSampler2(getSamplerProbabilityFromEnv(environment));
        case TracesSamplerValues.ParentBasedTraceIdRatio:
          return new ParentBasedSampler2({
            root: new TraceIdRatioBasedSampler2(getSamplerProbabilityFromEnv(environment))
          });
        default:
          diag2.error('OTEL_TRACES_SAMPLER value "' + environment.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + '".');
          return new AlwaysOnSampler2();
      }
    }
    __name(buildSamplerFromEnv, "buildSamplerFromEnv");
    function getSamplerProbabilityFromEnv(environment) {
      if (environment.OTEL_TRACES_SAMPLER_ARG === void 0 || environment.OTEL_TRACES_SAMPLER_ARG === "") {
        diag2.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
      if (isNaN(probability)) {
        diag2.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      if (probability < 0 || probability > 1) {
        diag2.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      return probability;
    }
    __name(getSamplerProbabilityFromEnv, "getSamplerProbabilityFromEnv");
    function mergeConfig(userConfig) {
      var perInstanceDefaults = {
        sampler: buildSamplerFromEnv()
      };
      var DEFAULT_CONFIG = loadDefaultConfig();
      var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
      target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
      target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
      return target;
    }
    __name(mergeConfig, "mergeConfig");
    function reconfigureLimits(userConfig) {
      var _a32, _b22, _c2, _d2, _e, _f, _g, _h, _j, _k, _l, _m;
      var spanLimits = Object.assign({}, userConfig.spanLimits);
      var parsedEnvConfig = getEnvWithoutDefaults();
      spanLimits.attributeCountLimit = (_f = (_e = (_d2 = (_b22 = (_a32 = userConfig.spanLimits) === null || _a32 === void 0 ? void 0 : _a32.attributeCountLimit) !== null && _b22 !== void 0 ? _b22 : (_c2 = userConfig.generalLimits) === null || _c2 === void 0 ? void 0 : _c2.attributeCountLimit) !== null && _d2 !== void 0 ? _d2 : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;
      spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
      return Object.assign({}, userConfig, { spanLimits });
    }
    __name(reconfigureLimits, "reconfigureLimits");
    var BatchSpanProcessorBase = function() {
      function BatchSpanProcessorBase2(_exporter, config2) {
        this._exporter = _exporter;
        this._finishedSpans = [];
        var env2 = getEnv();
        this._maxExportBatchSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxExportBatchSize) === "number" ? config2.maxExportBatchSize : env2.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
        this._maxQueueSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxQueueSize) === "number" ? config2.maxQueueSize : env2.OTEL_BSP_MAX_QUEUE_SIZE;
        this._scheduledDelayMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.scheduledDelayMillis) === "number" ? config2.scheduledDelayMillis : env2.OTEL_BSP_SCHEDULE_DELAY;
        this._exportTimeoutMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.exportTimeoutMillis) === "number" ? config2.exportTimeoutMillis : env2.OTEL_BSP_EXPORT_TIMEOUT;
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
      }
      __name(BatchSpanProcessorBase2, "BatchSpanProcessorBase");
      BatchSpanProcessorBase2.prototype.forceFlush = function() {
        if (this._shutdownOnce.isCalled) {
          return this._shutdownOnce.promise;
        }
        return this._flushAll();
      };
      BatchSpanProcessorBase2.prototype.onStart = function(_span, _parentContext) {
      };
      BatchSpanProcessorBase2.prototype.onEnd = function(span) {
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
          return;
        }
        this._addToBuffer(span);
      };
      BatchSpanProcessorBase2.prototype.shutdown = function() {
        return this._shutdownOnce.call();
      };
      BatchSpanProcessorBase2.prototype._shutdown = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.onShutdown();
        }).then(function() {
          return _this._flushAll();
        }).then(function() {
          return _this._exporter.shutdown();
        });
      };
      BatchSpanProcessorBase2.prototype._addToBuffer = function(span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
          return;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
      };
      BatchSpanProcessorBase2.prototype._flushAll = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var promises = [];
          var count2 = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);
          for (var i = 0, j = count2; i < j; i++) {
            promises.push(_this._flushOneBatch());
          }
          Promise.all(promises).then(function() {
            resolve();
          }).catch(reject);
        });
      };
      BatchSpanProcessorBase2.prototype._flushOneBatch = function() {
        var _this = this;
        this._clearTimer();
        if (this._finishedSpans.length === 0) {
          return Promise.resolve();
        }
        return new Promise(function(resolve, reject) {
          var timer2 = setTimeout(function() {
            reject(new Error("Timeout"));
          }, _this._exportTimeoutMillis);
          context2.with(suppressTracing(context2.active()), function() {
            _this._exporter.export(_this._finishedSpans.splice(0, _this._maxExportBatchSize), function(result) {
              var _a32;
              clearTimeout(timer2);
              if (result.code === ExportResultCode.SUCCESS) {
                resolve();
              } else {
                reject((_a32 = result.error) !== null && _a32 !== void 0 ? _a32 : new Error("BatchSpanProcessor: span export failed"));
              }
            });
          });
        });
      };
      BatchSpanProcessorBase2.prototype._maybeStartTimer = function() {
        var _this = this;
        if (this._timer !== void 0)
          return;
        this._timer = setTimeout(function() {
          _this._flushOneBatch().then(function() {
            if (_this._finishedSpans.length > 0) {
              _this._clearTimer();
              _this._maybeStartTimer();
            }
          }).catch(function(e) {
            globalErrorHandler(e);
          });
        }, this._scheduledDelayMillis);
        unrefTimer(this._timer);
      };
      BatchSpanProcessorBase2.prototype._clearTimer = function() {
        if (this._timer !== void 0) {
          clearTimeout(this._timer);
          this._timer = void 0;
        }
      };
      return BatchSpanProcessorBase2;
    }();
    var __extends = function() {
      var extendStatics = /* @__PURE__ */ __name(function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      }, "extendStatics");
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var BatchSpanProcessor = function(_super) {
      __extends(BatchSpanProcessor2, _super);
      function BatchSpanProcessor2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(BatchSpanProcessor2, "BatchSpanProcessor");
      BatchSpanProcessor2.prototype.onShutdown = function() {
      };
      return BatchSpanProcessor2;
    }(BatchSpanProcessorBase);
    var SPAN_ID_BYTES2 = 8;
    var TRACE_ID_BYTES2 = 16;
    var RandomIdGenerator2 = function() {
      function RandomIdGenerator3() {
        this.generateTraceId = getIdGenerator2(TRACE_ID_BYTES2);
        this.generateSpanId = getIdGenerator2(SPAN_ID_BYTES2);
      }
      __name(RandomIdGenerator3, "RandomIdGenerator");
      return RandomIdGenerator3;
    }();
    var SHARED_BUFFER2 = Buffer.allocUnsafe(TRACE_ID_BYTES2);
    function getIdGenerator2(bytes) {
      return /* @__PURE__ */ __name(function generateId() {
        for (var i = 0; i < bytes / 4; i++) {
          SHARED_BUFFER2.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);
        }
        for (var i = 0; i < bytes; i++) {
          if (SHARED_BUFFER2[i] > 0) {
            break;
          } else if (i === bytes - 1) {
            SHARED_BUFFER2[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER2.toString("hex", 0, bytes);
      }, "generateId");
    }
    __name(getIdGenerator2, "getIdGenerator");
    var Tracer = function() {
      function Tracer3(instrumentationLibrary, config2, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        var localConfig = mergeConfig(config2);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config2.idGenerator || new RandomIdGenerator2();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
      }
      __name(Tracer3, "Tracer");
      Tracer3.prototype.startSpan = function(name, options, context3) {
        var _a32, _b22;
        if (options === void 0) {
          options = {};
        }
        if (context3 === void 0) {
          context3 = context2.active();
        }
        if (options.root) {
          context3 = trace.deleteSpan(context3);
        }
        var parentSpan = trace.getSpan(context3);
        var clock;
        if (parentSpan) {
          clock = parentSpan["_clock"];
        }
        if (!clock) {
          clock = new AnchoredClock(Date, otperformance);
          if (parentSpan) {
            parentSpan["_clock"] = clock;
          }
        }
        if (isTracingSuppressed(context3)) {
          diag2.debug("Instrumentation suppressed, returning Noop Span");
          var nonRecordingSpan = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
          nonRecordingSpan["_clock"] = clock;
          return nonRecordingSpan;
        }
        var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
        var spanId = this._idGenerator.generateSpanId();
        var traceId;
        var traceState;
        var parentSpanId;
        if (!parentSpanContext || !trace.isSpanContextValid(parentSpanContext)) {
          traceId = this._idGenerator.generateTraceId();
        } else {
          traceId = parentSpanContext.traceId;
          traceState = parentSpanContext.traceState;
          parentSpanId = parentSpanContext.spanId;
        }
        var spanKind = (_a32 = options.kind) !== null && _a32 !== void 0 ? _a32 : SpanKind.INTERNAL;
        var links = ((_b22 = options.links) !== null && _b22 !== void 0 ? _b22 : []).map(function(link) {
          return {
            context: link.context,
            attributes: sanitizeAttributes(link.attributes)
          };
        });
        var attributes = sanitizeAttributes(options.attributes);
        var samplingResult = this._sampler.shouldSample(context3, traceId, name, spanKind, attributes, links);
        var traceFlags = samplingResult.decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE;
        var spanContext = { traceId, spanId, traceFlags, traceState };
        if (samplingResult.decision === SamplingDecision.NOT_RECORD) {
          diag2.debug("Recording is off, propagating context in a non-recording span");
          var nonRecordingSpan = trace.wrapSpanContext(spanContext);
          nonRecordingSpan["_clock"] = clock;
          return nonRecordingSpan;
        }
        var span = new Span(this, context3, name, spanContext, spanKind, parentSpanId, links, options.startTime, clock);
        var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));
        span.setAttributes(initAttributes);
        return span;
      };
      Tracer3.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : context2.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = trace.setSpan(parentContext, span);
        return context2.with(contextWithSpanSet, fn, void 0, span);
      };
      Tracer3.prototype.getGeneralLimits = function() {
        return this._generalLimits;
      };
      Tracer3.prototype.getSpanLimits = function() {
        return this._spanLimits;
      };
      Tracer3.prototype.getActiveSpanProcessor = function() {
        return this._tracerProvider.getActiveSpanProcessor();
      };
      return Tracer3;
    }();
    function defaultServiceName() {
      return "unknown_service:" + process.argv0;
    }
    __name(defaultServiceName, "defaultServiceName");
    var import_os2 = require("os");
    var __awaiter = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var HostDetector = function() {
      function HostDetector2() {
      }
      __name(HostDetector2, "HostDetector");
      HostDetector2.prototype.detect = function(_config) {
        return __awaiter(this, void 0, void 0, function() {
          var attributes;
          var _a32;
          return __generator(this, function(_b22) {
            attributes = (_a32 = {}, _a32[SemanticResourceAttributes.HOST_NAME] = (0, import_os2.hostname)(), _a32[SemanticResourceAttributes.HOST_ARCH] = this._normalizeArch((0, import_os2.arch)()), _a32);
            return [2, new Resource(attributes)];
          });
        });
      };
      HostDetector2.prototype._normalizeArch = function(nodeArchString) {
        switch (nodeArchString) {
          case "arm":
            return "arm32";
          case "ppc":
            return "ppc32";
          case "x64":
            return "amd64";
          default:
            return nodeArchString;
        }
      };
      return HostDetector2;
    }();
    var hostDetector = new HostDetector();
    var import_os3 = require("os");
    var __awaiter2 = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var OSDetector = function() {
      function OSDetector2() {
      }
      __name(OSDetector2, "OSDetector");
      OSDetector2.prototype.detect = function(_config) {
        return __awaiter2(this, void 0, void 0, function() {
          var attributes;
          var _a32;
          return __generator2(this, function(_b22) {
            attributes = (_a32 = {}, _a32[SemanticResourceAttributes.OS_TYPE] = this._normalizeType((0, import_os3.platform)()), _a32[SemanticResourceAttributes.OS_VERSION] = (0, import_os3.release)(), _a32);
            return [2, new Resource(attributes)];
          });
        });
      };
      OSDetector2.prototype._normalizeType = function(nodePlatform) {
        switch (nodePlatform) {
          case "sunos":
            return "solaris";
          case "win32":
            return "windows";
          default:
            return nodePlatform;
        }
      };
      return OSDetector2;
    }();
    var osDetector = new OSDetector();
    var Resource = function() {
      function Resource2(attributes) {
        this.attributes = attributes;
      }
      __name(Resource2, "Resource");
      Resource2.empty = function() {
        return Resource2.EMPTY;
      };
      Resource2.default = function() {
        var _a32;
        return new Resource2((_a32 = {}, _a32[SemanticResourceAttributes.SERVICE_NAME] = defaultServiceName(), _a32[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE], _a32[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_NAME], _a32[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_VERSION], _a32));
      };
      Resource2.prototype.merge = function(other) {
        if (!other || !Object.keys(other.attributes).length)
          return this;
        var mergedAttributes = Object.assign({}, this.attributes, other.attributes);
        return new Resource2(mergedAttributes);
      };
      Resource2.EMPTY = new Resource2({});
      return Resource2;
    }();
    var __assign = function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter3 = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator3 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var BrowserDetector = function() {
      function BrowserDetector2() {
      }
      __name(BrowserDetector2, "BrowserDetector");
      BrowserDetector2.prototype.detect = function(config2) {
        return __awaiter3(this, void 0, void 0, function() {
          var isBrowser, browserResource;
          var _a32;
          return __generator3(this, function(_b22) {
            isBrowser = typeof navigator !== "undefined";
            if (!isBrowser) {
              return [2, Resource.empty()];
            }
            browserResource = (_a32 = {}, _a32[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = "browser", _a32[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = "Web Browser", _a32[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = navigator.userAgent, _a32);
            return [2, this._getResourceAttributes(browserResource, config2)];
          });
        });
      };
      BrowserDetector2.prototype._getResourceAttributes = function(browserResource, _config) {
        if (browserResource[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === "") {
          diag2.debug("BrowserDetector failed: Unable to find required browser resources. ");
          return Resource.empty();
        } else {
          return new Resource(__assign({}, browserResource));
        }
      };
      return BrowserDetector2;
    }();
    var browserDetector = new BrowserDetector();
    var __awaiter4 = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator4 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var __values4 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read5 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var EnvDetector = function() {
      function EnvDetector2() {
        this._MAX_LENGTH = 255;
        this._COMMA_SEPARATOR = ",";
        this._LABEL_KEY_VALUE_SPLITTER = "=";
        this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.";
        this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      __name(EnvDetector2, "EnvDetector");
      EnvDetector2.prototype.detect = function(_config) {
        return __awaiter4(this, void 0, void 0, function() {
          var attributes, env2, rawAttributes, serviceName, parsedAttributes;
          return __generator4(this, function(_a32) {
            attributes = {};
            env2 = getEnv();
            rawAttributes = env2.OTEL_RESOURCE_ATTRIBUTES;
            serviceName = env2.OTEL_SERVICE_NAME;
            if (rawAttributes) {
              try {
                parsedAttributes = this._parseResourceAttributes(rawAttributes);
                Object.assign(attributes, parsedAttributes);
              } catch (e) {
                diag2.debug("EnvDetector failed: " + e.message);
              }
            }
            if (serviceName) {
              attributes[SemanticResourceAttributes.SERVICE_NAME] = serviceName;
            }
            return [2, new Resource(attributes)];
          });
        });
      };
      EnvDetector2.prototype._parseResourceAttributes = function(rawEnvAttributes) {
        var e_1, _a32;
        if (!rawEnvAttributes)
          return {};
        var attributes = {};
        var rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        try {
          for (var rawAttributes_1 = __values4(rawAttributes), rawAttributes_1_1 = rawAttributes_1.next(); !rawAttributes_1_1.done; rawAttributes_1_1 = rawAttributes_1.next()) {
            var rawAttribute = rawAttributes_1_1.value;
            var keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
            if (keyValuePair.length !== 2) {
              continue;
            }
            var _b22 = __read5(keyValuePair, 2), key = _b22[0], value = _b22[1];
            key = key.trim();
            value = value.trim().split('^"|"$').join("");
            if (!this._isValidAndNotEmpty(key)) {
              throw new Error("Attribute key " + this._ERROR_MESSAGE_INVALID_CHARS);
            }
            if (!this._isValid(value)) {
              throw new Error("Attribute value " + this._ERROR_MESSAGE_INVALID_VALUE);
            }
            attributes[key] = value;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (rawAttributes_1_1 && !rawAttributes_1_1.done && (_a32 = rawAttributes_1.return))
              _a32.call(rawAttributes_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return attributes;
      };
      EnvDetector2.prototype._isValid = function(name) {
        return name.length <= this._MAX_LENGTH && this._isPrintableString(name);
      };
      EnvDetector2.prototype._isPrintableString = function(str) {
        for (var i = 0; i < str.length; i++) {
          var ch = str.charAt(i);
          if (ch <= " " || ch >= "~") {
            return false;
          }
        }
        return true;
      };
      EnvDetector2.prototype._isValidAndNotEmpty = function(str) {
        return str.length > 0 && this._isValid(str);
      };
      return EnvDetector2;
    }();
    var envDetector = new EnvDetector();
    var __assign2 = function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    var __awaiter5 = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator5 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var ProcessDetector = function() {
      function ProcessDetector2() {
      }
      __name(ProcessDetector2, "ProcessDetector");
      ProcessDetector2.prototype.detect = function(config2) {
        return __awaiter5(this, void 0, void 0, function() {
          var processResource;
          var _a32;
          return __generator5(this, function(_b22) {
            if (typeof process !== "object") {
              return [2, Resource.empty()];
            }
            processResource = (_a32 = {}, _a32[SemanticResourceAttributes.PROCESS_PID] = process.pid, _a32[SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] = process.title || "", _a32[SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1] || "", _a32[SemanticResourceAttributes.PROCESS_COMMAND_LINE] = process.argv.join(" ") || "", _a32[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = process.versions.node, _a32[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = "nodejs", _a32[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = "Node.js", _a32);
            return [2, this._getResourceAttributes(processResource, config2)];
          });
        });
      };
      ProcessDetector2.prototype._getResourceAttributes = function(processResource, _config) {
        if (processResource[SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] === "" || processResource[SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH] === "" || processResource[SemanticResourceAttributes.PROCESS_COMMAND] === "" || processResource[SemanticResourceAttributes.PROCESS_COMMAND_LINE] === "" || processResource[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === "") {
          diag2.debug("ProcessDetector failed: Unable to find required process resources. ");
          return Resource.empty();
        } else {
          return new Resource(__assign2({}, processResource));
        }
      };
      return ProcessDetector2;
    }();
    var processDetector = new ProcessDetector();
    var __values5 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var MultiSpanProcessor = function() {
      function MultiSpanProcessor2(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
      }
      __name(MultiSpanProcessor2, "MultiSpanProcessor");
      MultiSpanProcessor2.prototype.forceFlush = function() {
        var e_1, _a32;
        var promises = [];
        try {
          for (var _b22 = __values5(this._spanProcessors), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var spanProcessor = _c2.value;
            promises.push(spanProcessor.forceFlush());
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return new Promise(function(resolve) {
          Promise.all(promises).then(function() {
            resolve();
          }).catch(function(error2) {
            globalErrorHandler(error2 || new Error("MultiSpanProcessor: forceFlush failed"));
            resolve();
          });
        });
      };
      MultiSpanProcessor2.prototype.onStart = function(span, context3) {
        var e_2, _a32;
        try {
          for (var _b22 = __values5(this._spanProcessors), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var spanProcessor = _c2.value;
            spanProcessor.onStart(span, context3);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      };
      MultiSpanProcessor2.prototype.onEnd = function(span) {
        var e_3, _a32;
        try {
          for (var _b22 = __values5(this._spanProcessors), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var spanProcessor = _c2.value;
            spanProcessor.onEnd(span);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      };
      MultiSpanProcessor2.prototype.shutdown = function() {
        var e_4, _a32;
        var promises = [];
        try {
          for (var _b22 = __values5(this._spanProcessors), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var spanProcessor = _c2.value;
            promises.push(spanProcessor.shutdown());
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        return new Promise(function(resolve, reject) {
          Promise.all(promises).then(function() {
            resolve();
          }, reject);
        });
      };
      return MultiSpanProcessor2;
    }();
    var NoopSpanProcessor = function() {
      function NoopSpanProcessor2() {
      }
      __name(NoopSpanProcessor2, "NoopSpanProcessor");
      NoopSpanProcessor2.prototype.onStart = function(_span, _context) {
      };
      NoopSpanProcessor2.prototype.onEnd = function(_span) {
      };
      NoopSpanProcessor2.prototype.shutdown = function() {
        return Promise.resolve();
      };
      NoopSpanProcessor2.prototype.forceFlush = function() {
        return Promise.resolve();
      };
      return NoopSpanProcessor2;
    }();
    var ForceFlushState;
    (function(ForceFlushState2) {
      ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
      ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
      ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
      ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
    })(ForceFlushState || (ForceFlushState = {}));
    var BasicTracerProvider = function() {
      function BasicTracerProvider2(config2) {
        if (config2 === void 0) {
          config2 = {};
        }
        var _a32;
        this._registeredSpanProcessors = [];
        this._tracers = /* @__PURE__ */ new Map();
        var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config2));
        this.resource = (_a32 = mergedConfig.resource) !== null && _a32 !== void 0 ? _a32 : Resource.empty();
        this.resource = Resource.default().merge(this.resource);
        this._config = Object.assign({}, mergedConfig, {
          resource: this.resource
        });
        var defaultExporter = this._buildExporterFromEnv();
        if (defaultExporter !== void 0) {
          var batchProcessor = new BatchSpanProcessor(defaultExporter);
          this.activeSpanProcessor = batchProcessor;
        } else {
          this.activeSpanProcessor = new NoopSpanProcessor();
        }
      }
      __name(BasicTracerProvider2, "BasicTracerProvider");
      BasicTracerProvider2.prototype.getTracer = function(name, version, options) {
        var key = name + "@" + (version || "") + ":" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || "");
        if (!this._tracers.has(key)) {
          this._tracers.set(key, new Tracer({ name, version, schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl }, this._config, this));
        }
        return this._tracers.get(key);
      };
      BasicTracerProvider2.prototype.addSpanProcessor = function(spanProcessor) {
        if (this._registeredSpanProcessors.length === 0) {
          this.activeSpanProcessor.shutdown().catch(function(err) {
            return diag2.error("Error while trying to shutdown current span processor", err);
          });
        }
        this._registeredSpanProcessors.push(spanProcessor);
        this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
      };
      BasicTracerProvider2.prototype.getActiveSpanProcessor = function() {
        return this.activeSpanProcessor;
      };
      BasicTracerProvider2.prototype.register = function(config2) {
        if (config2 === void 0) {
          config2 = {};
        }
        trace.setGlobalTracerProvider(this);
        if (config2.propagator === void 0) {
          config2.propagator = this._buildPropagatorFromEnv();
        }
        if (config2.contextManager) {
          context2.setGlobalContextManager(config2.contextManager);
        }
        if (config2.propagator) {
          propagation.setGlobalPropagator(config2.propagator);
        }
      };
      BasicTracerProvider2.prototype.forceFlush = function() {
        var timeout = this._config.forceFlushTimeoutMillis;
        var promises = this._registeredSpanProcessors.map(function(spanProcessor) {
          return new Promise(function(resolve) {
            var state;
            var timeoutInterval = setTimeout(function() {
              resolve(new Error("Span processor did not completed within timeout period of " + timeout + " ms"));
              state = ForceFlushState.timeout;
            }, timeout);
            spanProcessor.forceFlush().then(function() {
              clearTimeout(timeoutInterval);
              if (state !== ForceFlushState.timeout) {
                state = ForceFlushState.resolved;
                resolve(state);
              }
            }).catch(function(error2) {
              clearTimeout(timeoutInterval);
              state = ForceFlushState.error;
              resolve(error2);
            });
          });
        });
        return new Promise(function(resolve, reject) {
          Promise.all(promises).then(function(results) {
            var errors = results.filter(function(result) {
              return result !== ForceFlushState.resolved;
            });
            if (errors.length > 0) {
              reject(errors);
            } else {
              resolve();
            }
          }).catch(function(error2) {
            return reject([error2]);
          });
        });
      };
      BasicTracerProvider2.prototype.shutdown = function() {
        return this.activeSpanProcessor.shutdown();
      };
      BasicTracerProvider2.prototype._getPropagator = function(name) {
        var _a32;
        return (_a32 = this.constructor._registeredPropagators.get(name)) === null || _a32 === void 0 ? void 0 : _a32();
      };
      BasicTracerProvider2.prototype._getSpanExporter = function(name) {
        var _a32;
        return (_a32 = this.constructor._registeredExporters.get(name)) === null || _a32 === void 0 ? void 0 : _a32();
      };
      BasicTracerProvider2.prototype._buildPropagatorFromEnv = function() {
        var _this = this;
        var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));
        var propagators = uniquePropagatorNames.map(function(name) {
          var propagator = _this._getPropagator(name);
          if (!propagator) {
            diag2.warn('Propagator "' + name + '" requested through environment variable is unavailable.');
          }
          return propagator;
        });
        var validPropagators = propagators.reduce(function(list, item) {
          if (item) {
            list.push(item);
          }
          return list;
        }, []);
        if (validPropagators.length === 0) {
          return;
        } else if (uniquePropagatorNames.length === 1) {
          return validPropagators[0];
        } else {
          return new CompositePropagator({
            propagators: validPropagators
          });
        }
      };
      BasicTracerProvider2.prototype._buildExporterFromEnv = function() {
        var exporterName = getEnv().OTEL_TRACES_EXPORTER;
        if (exporterName === "none")
          return;
        var exporter = this._getSpanExporter(exporterName);
        if (!exporter) {
          diag2.error('Exporter "' + exporterName + '" requested through environment variable is unavailable.');
        }
        return exporter;
      };
      BasicTracerProvider2._registeredPropagators = /* @__PURE__ */ new Map([
        ["tracecontext", function() {
          return new W3CTraceContextPropagator();
        }],
        ["baggage", function() {
          return new W3CBaggagePropagator();
        }]
      ]);
      BasicTracerProvider2._registeredExporters = /* @__PURE__ */ new Map();
      return BasicTracerProvider2;
    }();
    var __values6 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var ConsoleSpanExporter = function() {
      function ConsoleSpanExporter2() {
      }
      __name(ConsoleSpanExporter2, "ConsoleSpanExporter");
      ConsoleSpanExporter2.prototype.export = function(spans, resultCallback) {
        return this._sendSpans(spans, resultCallback);
      };
      ConsoleSpanExporter2.prototype.shutdown = function() {
        this._sendSpans([]);
        return Promise.resolve();
      };
      ConsoleSpanExporter2.prototype._exportInfo = function(span) {
        return {
          traceId: span.spanContext().traceId,
          parentId: span.parentSpanId,
          name: span.name,
          id: span.spanContext().spanId,
          kind: span.kind,
          timestamp: hrTimeToMicroseconds(span.startTime),
          duration: hrTimeToMicroseconds(span.duration),
          attributes: span.attributes,
          status: span.status,
          events: span.events,
          links: span.links
        };
      };
      ConsoleSpanExporter2.prototype._sendSpans = function(spans, done) {
        var e_1, _a32;
        try {
          for (var spans_1 = __values6(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()) {
            var span = spans_1_1.value;
            console.dir(this._exportInfo(span), { depth: 3 });
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (spans_1_1 && !spans_1_1.done && (_a32 = spans_1.return))
              _a32.call(spans_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (done) {
          return done({ code: ExportResultCode.SUCCESS });
        }
      };
      return ConsoleSpanExporter2;
    }();
    var __read6 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var InMemorySpanExporter = function() {
      function InMemorySpanExporter2() {
        this._finishedSpans = [];
        this._stopped = false;
      }
      __name(InMemorySpanExporter2, "InMemorySpanExporter");
      InMemorySpanExporter2.prototype.export = function(spans, resultCallback) {
        var _a32;
        if (this._stopped)
          return resultCallback({
            code: ExportResultCode.FAILED,
            error: new Error("Exporter has been stopped")
          });
        (_a32 = this._finishedSpans).push.apply(_a32, __spreadArray4([], __read6(spans), false));
        setTimeout(function() {
          return resultCallback({ code: ExportResultCode.SUCCESS });
        }, 0);
      };
      InMemorySpanExporter2.prototype.shutdown = function() {
        this._stopped = true;
        this._finishedSpans = [];
        return Promise.resolve();
      };
      InMemorySpanExporter2.prototype.reset = function() {
        this._finishedSpans = [];
      };
      InMemorySpanExporter2.prototype.getFinishedSpans = function() {
        return this._finishedSpans;
      };
      return InMemorySpanExporter2;
    }();
    var SimpleSpanProcessor = function() {
      function SimpleSpanProcessor2(_exporter) {
        this._exporter = _exporter;
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
      }
      __name(SimpleSpanProcessor2, "SimpleSpanProcessor");
      SimpleSpanProcessor2.prototype.forceFlush = function() {
        return Promise.resolve();
      };
      SimpleSpanProcessor2.prototype.onStart = function(_span, _parentContext) {
      };
      SimpleSpanProcessor2.prototype.onEnd = function(span) {
        var _this = this;
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
          return;
        }
        context2.with(suppressTracing(context2.active()), function() {
          _this._exporter.export([span], function(result) {
            var _a32;
            if (result.code !== ExportResultCode.SUCCESS) {
              globalErrorHandler((_a32 = result.error) !== null && _a32 !== void 0 ? _a32 : new Error("SimpleSpanProcessor: span export failed (status " + result + ")"));
            }
          });
        });
      };
      SimpleSpanProcessor2.prototype.shutdown = function() {
        return this._shutdownOnce.call();
      };
      SimpleSpanProcessor2.prototype._shutdown = function() {
        return this._exporter.shutdown();
      };
      return SimpleSpanProcessor2;
    }();
    async function createSpan(engineSpanEvent) {
      await new Promise((res) => setTimeout(res, 0));
      const tracer = trace.getTracer("prisma");
      engineSpanEvent.spans.forEach((engineSpan) => {
        var _a32;
        const spanContext = {
          traceId: engineSpan.trace_id,
          spanId: engineSpan.span_id,
          traceFlags: TraceFlags.SAMPLED
        };
        const links = (_a32 = engineSpan.links) == null ? void 0 : _a32.map((link) => {
          return {
            context: {
              traceId: link.trace_id,
              spanId: link.span_id,
              traceFlags: TraceFlags.SAMPLED
            }
          };
        });
        const span = new Span(
          tracer,
          ROOT_CONTEXT,
          engineSpan.name,
          spanContext,
          SpanKind.INTERNAL,
          engineSpan.parent_span_id,
          links,
          engineSpan.start_time
        );
        if (engineSpan.attributes) {
          span.setAttributes(engineSpan.attributes);
        }
        span.end(engineSpan.end_time);
      });
    }
    __name(createSpan, "createSpan");
    function getTraceParent({
      context: context3,
      tracingConfig
    }) {
      const span = trace.getSpanContext(context3 != null ? context3 : context2.active());
      if ((tracingConfig == null ? void 0 : tracingConfig.enabled) && span) {
        return `00-${span.traceId}-${span.spanId}-0${span.traceFlags}`;
      } else {
        return `00-10-10-00`;
      }
    }
    __name(getTraceParent, "getTraceParent");
    function getTracingConfig(previewFeatures) {
      const hasTracingPreviewFeatureFlagEnabled = previewFeatures.includes("tracing");
      return {
        get enabled() {
          return Boolean(globalThis.PRISMA_INSTRUMENTATION && hasTracingPreviewFeatureFlagEnabled);
        },
        get middleware() {
          return Boolean(globalThis.PRISMA_INSTRUMENTATION && globalThis.PRISMA_INSTRUMENTATION.middleware);
        }
      };
    }
    __name(getTracingConfig, "getTracingConfig");
    async function runInChildSpan(options, cb) {
      var _a32;
      if (options.enabled === false)
        return cb();
      const tracer = trace.getTracer("prisma");
      const context3 = (_a32 = options.context) != null ? _a32 : context2.active();
      if (options.active === false) {
        const span = tracer.startSpan(`prisma:client:${options.name}`, options, context3);
        try {
          return await cb(span, context3);
        } finally {
          span.end();
        }
      }
      return tracer.startActiveSpan(`prisma:client:${options.name}`, options, context3, async (span) => {
        try {
          return await cb(span, context2.active());
        } finally {
          span.end();
        }
      });
    }
    __name(runInChildSpan, "runInChildSpan");
    var import_get_stream = __toESM(require_get_stream());
    var undici = /* @__PURE__ */ __name(() => require_undici(), "undici");
    function assertHasPool(pool) {
      if (pool === void 0) {
        throw new Error("Connection has not been opened");
      }
    }
    __name(assertHasPool, "assertHasPool");
    var Connection = class {
      constructor() {
      }
      static async onHttpError(response, handler) {
        const _response = await response;
        if (_response.statusCode >= 400) {
          return handler(_response);
        }
        return _response;
      }
      open(url2, options) {
        if (this._pool)
          return;
        this._pool = new (undici()).Pool(url2, {
          connections: 1e3,
          keepAliveMaxTimeout: 6e5,
          headersTimeout: 0,
          bodyTimeout: 0,
          ...options
        });
      }
      async raw(method, endpoint, headers, body, parseResponse = true) {
        assertHasPool(this._pool);
        const response = await this._pool.request({
          path: endpoint,
          method,
          headers: {
            "Content-Type": "application/json",
            ...headers
          },
          body
        });
        const bodyString = await (0, import_get_stream.default)(response.body);
        return {
          statusCode: response.statusCode,
          headers: response.headers,
          data: parseResponse ? JSON.parse(bodyString) : bodyString
        };
      }
      post(endpoint, body, headers, parseResponse) {
        return this.raw("POST", endpoint, headers, body, parseResponse);
      }
      get(path7, headers) {
        return this.raw("GET", path7, headers);
      }
      close() {
        if (this._pool) {
          this._pool.close(() => {
          });
        }
        this._pool = void 0;
      }
    };
    __name(Connection, "Connection");
    var debug5 = src_default("prisma:engine");
    var exists3 = (0, import_util4.promisify)(import_fs5.default.exists);
    var logger = /* @__PURE__ */ __name((...args) => {
    }, "logger");
    var knownPlatforms = [...platforms, "native"];
    var engines = [];
    var socketPaths = [];
    var MAX_STARTS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
    var MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
    var BinaryEngine = class extends Engine {
      constructor({
        cwd,
        datamodelPath,
        prismaPath,
        generator,
        datasources,
        showColors,
        logQueries,
        env: env2,
        flags,
        clientVersion: clientVersion2,
        previewFeatures,
        engineEndpoint,
        enableDebugLogs,
        allowTriggerPanic,
        dirname: dirname2,
        activeProvider,
        tracingConfig,
        logEmitter
      }) {
        var _a32;
        super();
        this.startCount = 0;
        this.previewFeatures = [];
        this.stderrLogs = "";
        this.handleRequestError = /* @__PURE__ */ __name(async (error2) => {
          var _a33, _b22;
          debug5({ error: error2 });
          if (this.startPromise) {
            await this.startPromise;
          }
          const isNetworkError = [
            "ECONNRESET",
            "ECONNREFUSED",
            "UND_ERR_CLOSED",
            "UND_ERR_SOCKET",
            "UND_ERR_DESTROYED",
            "UND_ERR_ABORTED"
          ].includes(error2.code);
          if (error2 instanceof PrismaClientKnownRequestError) {
            return { error: error2, shouldRetry: false };
          }
          try {
            this.throwAsyncErrorIfExists();
            if ((_a33 = this.currentRequestPromise) == null ? void 0 : _a33.isCanceled) {
              this.throwAsyncErrorIfExists();
            } else if (isNetworkError) {
              if (this.globalKillSignalReceived && !((_b22 = this.child) == null ? void 0 : _b22.connected)) {
                throw new PrismaClientUnknownRequestError(
                  `The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited
  and your request can't be processed.
  You probably have some open handle that prevents your process from exiting.
  It could be an open http server or stream that didn't close yet.
  We recommend using the \`wtfnode\` package to debug open handles.`,
                  { clientVersion: this.clientVersion }
                );
              }
              this.throwAsyncErrorIfExists();
              if (this.startCount > MAX_STARTS) {
                for (let i = 0; i < 5; i++) {
                  await new Promise((r) => setTimeout(r, 50));
                  this.throwAsyncErrorIfExists(true);
                }
                throw new Error(`Query engine is trying to restart, but can't.
  Please look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);
              }
            }
            this.throwAsyncErrorIfExists(true);
            throw error2;
          } catch (e) {
            return { error: e, shouldRetry: isNetworkError };
          }
        }, "handleRequestError");
        this.dirname = dirname2;
        this.env = env2;
        this.cwd = this.resolveCwd(cwd);
        this.enableDebugLogs = enableDebugLogs != null ? enableDebugLogs : false;
        this.allowTriggerPanic = allowTriggerPanic != null ? allowTriggerPanic : false;
        this.datamodelPath = datamodelPath;
        this.prismaPath = (_a32 = process.env.PRISMA_QUERY_ENGINE_BINARY) != null ? _a32 : prismaPath;
        this.generator = generator;
        this.datasources = datasources;
        this.tracingConfig = tracingConfig;
        this.logEmitter = logEmitter;
        this.showColors = showColors != null ? showColors : false;
        this.logQueries = logQueries != null ? logQueries : false;
        this.clientVersion = clientVersion2;
        this.flags = flags != null ? flags : [];
        this.previewFeatures = previewFeatures != null ? previewFeatures : [];
        this.activeProvider = activeProvider;
        this.connection = new Connection();
        initHooks();
        const removedFlags = [
          "middlewares",
          "aggregateApi",
          "distinct",
          "aggregations",
          "insensitiveFilters",
          "atomicNumberOperations",
          "transactionApi",
          "transaction",
          "connectOrCreate",
          "uncheckedScalarInputs",
          "nativeTypes",
          "createMany",
          "groupBy",
          "referentialActions",
          "microsoftSqlServer"
        ];
        const removedFlagsUsed = this.previewFeatures.filter((e) => removedFlags.includes(e));
        if (removedFlagsUsed.length > 0 && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
          console.log(
            `${import_chalk3.default.blueBright("info")} The preview flags \`${removedFlagsUsed.join(
              "`, `"
            )}\` were removed, you can now safely remove them from your schema.prisma.`
          );
        }
        this.previewFeatures = this.previewFeatures.filter((e) => !removedFlags.includes(e));
        this.engineEndpoint = engineEndpoint;
        if (engineEndpoint) {
          const url2 = new import_url.URL(engineEndpoint);
          this.port = Number(url2.port);
        }
        if (this.platform) {
          if (!knownPlatforms.includes(this.platform) && !import_fs5.default.existsSync(this.platform)) {
            throw new PrismaClientInitializationError(
              `Unknown ${import_chalk3.default.red("PRISMA_QUERY_ENGINE_BINARY")} ${import_chalk3.default.redBright.bold(
                this.platform
              )}. Possible binaryTargets: ${import_chalk3.default.greenBright(
                knownPlatforms.join(", ")
              )} or a path to the query engine binary.
You may have to run ${import_chalk3.default.greenBright("prisma generate")} for your changes to take effect.`,
              this.clientVersion
            );
          }
        } else {
          void this.getPlatform();
        }
        if (this.enableDebugLogs) {
          src_default.enable("*");
        }
        engines.push(this);
        this.checkForTooManyEngines();
      }
      setError(err) {
        var _a32;
        if (isRustErrorLog(err)) {
          this.lastError = new PrismaClientRustError({
            clientVersion: this.clientVersion,
            error: err
          });
          if (this.lastError.isPanic()) {
            if (this.child) {
              this.stopPromise = killProcessAndWait(this.child);
            }
            if ((_a32 = this.currentRequestPromise) == null ? void 0 : _a32.cancel) {
              this.currentRequestPromise.cancel();
            }
          }
        }
      }
      checkForTooManyEngines() {
        if (engines.length >= 10) {
          const runningEngines = engines.filter((e) => e.child);
          if (runningEngines.length === 10) {
            console.warn(
              `${import_chalk3.default.yellow("warn(prisma-client)")} There are already 10 instances of Prisma Client actively running.`
            );
          }
        }
      }
      resolveCwd(cwd) {
        if (cwd && import_fs5.default.existsSync(cwd) && import_fs5.default.lstatSync(cwd).isDirectory()) {
          return cwd;
        }
        return process.cwd();
      }
      on(event, listener) {
        if (event === "beforeExit") {
          this.beforeExitListener = listener;
        } else {
          this.logEmitter.on(event, listener);
        }
      }
      async emitExit() {
        if (this.beforeExitListener) {
          try {
            await this.beforeExitListener();
          } catch (e) {
            console.error(e);
          }
        }
      }
      async getPlatform() {
        if (this.platformPromise) {
          return this.platformPromise;
        }
        this.platformPromise = getPlatform();
        return this.platformPromise;
      }
      getQueryEnginePath(platform3, prefix = __dirname) {
        let queryEnginePath = import_path3.default.join(prefix, `query-engine-${platform3}`);
        if (platform3 === "windows") {
          queryEnginePath = `${queryEnginePath}.exe`;
        }
        return queryEnginePath;
      }
      async resolvePrismaPath() {
        var _a3, _b2, _c;
        const searchedLocations = [];
        let enginePath;
        if (this.prismaPath) {
          return { prismaPath: this.prismaPath, searchedLocations };
        }
        const platform = await this.getPlatform();
        if (this.platform && this.platform !== platform) {
          this.incorrectlyPinnedBinaryTarget = this.platform;
        }
        this.platform = this.platform || platform;
        if (__filename.includes("BinaryEngine")) {
          enginePath = this.getQueryEnginePath(this.platform, getEnginesPath());
          return { prismaPath: enginePath, searchedLocations };
        }
        const searchLocations = [
          eval(`require('path').join(__dirname, '../../../.prisma/client')`),
          (_c = (_b2 = (_a3 = this.generator) == null ? void 0 : _a3.output) == null ? void 0 : _b2.value) != null ? _c : eval("__dirname"),
          import_path3.default.join(eval("__dirname"), ".."),
          import_path3.default.dirname(this.datamodelPath),
          this.cwd,
          "/tmp/prisma-engines"
        ];
        if (this.dirname) {
          searchLocations.push(this.dirname);
        }
        for (const location of searchLocations) {
          searchedLocations.push(location);
          debug5(`Search for Query Engine in ${location}`);
          enginePath = this.getQueryEnginePath(this.platform, location);
          if (import_fs5.default.existsSync(enginePath)) {
            return { prismaPath: enginePath, searchedLocations };
          }
        }
        enginePath = this.getQueryEnginePath(this.platform);
        return { prismaPath: enginePath != null ? enginePath : "", searchedLocations };
      }
      async getPrismaPath() {
        const { prismaPath, searchedLocations: searchedLocations2 } = await this.resolvePrismaPath();
        const platform3 = await this.getPlatform();
        if (!await exists3(prismaPath)) {
          const pinnedStr = this.incorrectlyPinnedBinaryTarget ? `
You incorrectly pinned it to ${import_chalk3.default.redBright.bold(`${this.incorrectlyPinnedBinaryTarget}`)}
` : "";
          let errorText = `Query engine binary for current platform "${import_chalk3.default.bold(
            platform3
          )}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${import_chalk3.default.underline(prismaPath)}")

Searched Locations:

${searchedLocations2.map((f) => {
            let msg = `  ${f}`;
            if (process.env.DEBUG === "node-engine-search-locations" && import_fs5.default.existsSync(f)) {
              const dir = import_fs5.default.readdirSync(f);
              msg += dir.map((d) => `    ${d}`).join("\n");
            }
            return msg;
          }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
          if (this.generator) {
            if (this.generator.binaryTargets.find((object) => object.value === this.platform) || this.generator.binaryTargets.find((object) => object.value === "native")) {
              errorText += `
You already added the platform${this.generator.binaryTargets.length > 1 ? "s" : ""} ${this.generator.binaryTargets.map((t) => `"${import_chalk3.default.bold(t.value)}"`).join(", ")} to the "${import_chalk3.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
              errorText += ``;
            } else {
              errorText += `

To solve this problem, add the platform "${this.platform}" to the "${import_chalk3.default.underline(
                "binaryTargets"
              )}" attribute in the "${import_chalk3.default.underline("generator")}" block in the "schema.prisma" file:
${import_chalk3.default.greenBright(this.getFixedGenerator())}

Then run "${import_chalk3.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
            }
          } else {
            errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
          }
          throw new PrismaClientInitializationError(errorText, this.clientVersion);
        }
        if (this.incorrectlyPinnedBinaryTarget) {
          console.error(`${import_chalk3.default.yellow("Warning:")} You pinned the platform ${import_chalk3.default.bold(
            this.incorrectlyPinnedBinaryTarget
          )}, but Prisma Client detects ${import_chalk3.default.bold(await this.getPlatform())}.
This means you should very likely pin the platform ${import_chalk3.default.greenBright(await this.getPlatform())} instead.
${import_chalk3.default.dim("In case we're mistaken, please report this to us \u{1F64F}.")}`);
        }
        if (process.platform !== "win32") {
          plusX(prismaPath);
        }
        return prismaPath;
      }
      getFixedGenerator() {
        const fixedGenerator = {
          ...this.generator,
          binaryTargets: fixBinaryTargets(this.generator.binaryTargets, this.platform)
        };
        return printGeneratorConfig(fixedGenerator);
      }
      printDatasources() {
        if (this.datasources) {
          return JSON.stringify(this.datasources);
        }
        return "[]";
      }
      async start() {
        if (this.stopPromise) {
          await this.stopPromise;
        }
        const startFn = /* @__PURE__ */ __name(async () => {
          if (!this.startPromise) {
            this.startCount++;
            this.startPromise = this.internalStart();
          }
          await this.startPromise;
          if (!this.child && !this.engineEndpoint) {
            throw new PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, {
              clientVersion: this.clientVersion
            });
          }
        }, "startFn");
        const spanOptions = {
          name: "connect",
          enabled: this.tracingConfig.enabled && !this.startPromise
        };
        return runInChildSpan(spanOptions, startFn);
      }
      getEngineEnvVars() {
        var _a32, _b22;
        const env2 = {
          PRISMA_DML_PATH: this.datamodelPath
        };
        if (this.logQueries) {
          env2.LOG_QUERIES = "true";
        }
        if (this.datasources) {
          env2.OVERWRITE_DATASOURCES = this.printDatasources();
        }
        if (!process.env.NO_COLOR && this.showColors) {
          env2.CLICOLOR_FORCE = "1";
        }
        return {
          ...this.env,
          ...process.env,
          ...env2,
          RUST_BACKTRACE: (_a32 = process.env.RUST_BACKTRACE) != null ? _a32 : "1",
          RUST_LOG: (_b22 = process.env.RUST_LOG) != null ? _b22 : "info"
        };
      }
      internalStart() {
        return new Promise(async (resolve, reject) => {
          var _a32, _b22, _c2;
          await new Promise((r) => process.nextTick(r));
          if (this.stopPromise) {
            await this.stopPromise;
          }
          if (this.engineEndpoint) {
            try {
              this.connection.open(this.engineEndpoint);
              await (0, import_p_retry.default)(() => this.connection.get("/status"), {
                retries: 10
              });
            } catch (e) {
              return reject(e);
            }
            return resolve();
          }
          try {
            if (((_a32 = this.child) == null ? void 0 : _a32.connected) || this.child && !((_b22 = this.child) == null ? void 0 : _b22.killed)) {
              debug5(`There is a child that still runs and we want to start again`);
            }
            this.lastError = void 0;
            logger("startin & resettin");
            this.globalKillSignalReceived = void 0;
            debug5({ cwd: this.cwd });
            const prismaPath = await this.getPrismaPath();
            const additionalFlag = this.allowTriggerPanic ? ["--debug"] : [];
            const flags = [
              "--enable-raw-queries",
              "--enable-metrics",
              "--enable-open-telemetry",
              ...this.flags,
              ...additionalFlag
            ];
            this.port = await this.getFreePort();
            flags.push("--port", String(this.port));
            debug5({ flags });
            const env2 = this.getEngineEnvVars();
            this.child = (0, import_child_process2.spawn)(prismaPath, flags, {
              env: env2,
              cwd: this.cwd,
              windowsHide: true,
              stdio: ["ignore", "pipe", "pipe"]
            });
            byline(this.child.stderr).on("data", (msg) => {
              const data = String(msg);
              debug5("stderr", data);
              try {
                const json = JSON.parse(data);
                if (typeof json.is_panic !== "undefined") {
                  debug5(json);
                  this.setError(json);
                  if (this.engineStartDeferred) {
                    const err = new PrismaClientInitializationError(json.message, this.clientVersion, json.error_code);
                    this.engineStartDeferred.reject(err);
                  }
                }
              } catch (e) {
                if (!data.includes("Printing to stderr") && !data.includes("Listening on ")) {
                  this.stderrLogs += "\n" + data;
                }
              }
            });
            byline(this.child.stdout).on("data", (msg) => {
              var _a4, _b3;
              const data = String(msg);
              try {
                const json = JSON.parse(data);
                debug5("stdout", getMessage(json));
                if (this.engineStartDeferred && json.level === "INFO" && json.target === "query_engine::server" && ((_b3 = (_a4 = json.fields) == null ? void 0 : _a4.message) == null ? void 0 : _b3.startsWith("Started query engine http server"))) {
                  this.connection.open(`http://127.0.0.1:${this.port}`);
                  this.engineStartDeferred.resolve();
                  this.engineStartDeferred = void 0;
                }
                if (typeof json.is_panic === "undefined") {
                  if (json.span === true) {
                    if (this.tracingConfig.enabled === true) {
                      void createSpan(json);
                    }
                    return;
                  }
                  const log3 = convertLog(json);
                  const logIsRustErrorLog = isRustErrorLog(log3);
                  if (logIsRustErrorLog) {
                    this.setError(log3);
                  } else {
                    this.logEmitter.emit(log3.level, log3);
                  }
                } else {
                  this.setError(json);
                }
              } catch (e) {
                debug5(e, data);
              }
            });
            this.child.on("exit", (code) => {
              var _a4;
              logger("removing startPromise");
              this.startPromise = void 0;
              if (this.engineStopDeferred) {
                this.engineStopDeferred.resolve(code);
                return;
              }
              this.connection.close();
              if (code !== 0 && this.engineStartDeferred && this.startCount === 1) {
                let err;
                let msg = this.stderrLogs;
                if (this.lastError) {
                  msg = getMessage(this.lastError);
                }
                if (code !== null) {
                  err = new PrismaClientInitializationError(
                    `Query engine exited with code ${code}
` + msg,
                    this.clientVersion
                  );
                } else if ((_a4 = this.child) == null ? void 0 : _a4.signalCode) {
                  err = new PrismaClientInitializationError(
                    `Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${prismaPath} is not corrupt.
` + msg,
                    this.clientVersion
                  );
                } else {
                  err = new PrismaClientInitializationError(msg, this.clientVersion);
                }
                this.engineStartDeferred.reject(err);
              }
              if (!this.child) {
                return;
              }
              if (this.lastError) {
                return;
              }
              if (code === 126) {
                this.setError({
                  timestamp: /* @__PURE__ */ new Date(),
                  target: "binary engine process exit",
                  level: "error",
                  fields: {
                    message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.`
                  }
                });
              }
            });
            this.child.on("error", (err) => {
              this.setError({
                timestamp: /* @__PURE__ */ new Date(),
                target: "binary engine process error",
                level: "error",
                fields: {
                  message: `Couldn't start query engine: ${err}`
                }
              });
              reject(err);
            });
            this.child.on("close", (code, signal) => {
              this.connection.close();
              let toEmit;
              if (code === null && signal === "SIGABRT" && this.child) {
                toEmit = new PrismaClientRustPanicError(
                  this.getErrorMessageWithLink("Panic in Query Engine with SIGABRT signal"),
                  this.clientVersion
                );
              } else if (code === 255 && signal === null && this.lastError) {
                toEmit = this.lastError;
              }
              if (toEmit) {
                this.logEmitter.emit("error", {
                  message: toEmit.message,
                  timestamp: /* @__PURE__ */ new Date(),
                  target: "binary engine process close"
                });
              }
            });
            if (this.lastError) {
              return reject(new PrismaClientInitializationError(getMessage(this.lastError), this.clientVersion));
            }
            try {
              await new Promise((resolve2, reject2) => {
                this.engineStartDeferred = { resolve: resolve2, reject: reject2 };
              });
            } catch (err) {
              (_c2 = this.child) == null ? void 0 : _c2.kill();
              throw err;
            }
            void (async () => {
              try {
                const engineVersion = await this.version(true);
                debug5(`Client Version: ${this.clientVersion}`);
                debug5(`Engine Version: ${engineVersion}`);
                debug5(`Active provider: ${this.activeProvider}`);
              } catch (e) {
                debug5(e);
              }
            })();
            this.stopPromise = void 0;
            resolve();
          } catch (e) {
            reject(e);
          }
        });
      }
      async stop() {
        const stopFn = /* @__PURE__ */ __name(async () => {
          if (!this.stopPromise) {
            this.stopPromise = this._stop();
          }
          return this.stopPromise;
        }, "stopFn");
        const spanOptions = {
          name: "disconnect",
          enabled: this.tracingConfig.enabled
        };
        return runInChildSpan(spanOptions, stopFn);
      }
      async _stop() {
        if (this.startPromise) {
          await this.startPromise;
        }
        await new Promise((resolve) => process.nextTick(resolve));
        if (this.currentRequestPromise) {
          try {
            await this.currentRequestPromise;
          } catch (e) {
          }
        }
        this.getConfigPromise = void 0;
        let stopChildPromise;
        if (this.child) {
          debug5(`Stopping Prisma engine`);
          if (this.startPromise) {
            debug5(`Waiting for start promise`);
            await this.startPromise;
          }
          debug5(`Done waiting for start promise`);
          if (this.child.exitCode === null) {
            stopChildPromise = new Promise((resolve, reject) => {
              this.engineStopDeferred = { resolve, reject };
            });
          } else {
            debug5("Child already exited with code", this.child.exitCode);
          }
          this.connection.close();
          this.child.kill();
          this.child = void 0;
        }
        if (stopChildPromise) {
          await stopChildPromise;
        }
        await new Promise((r) => process.nextTick(r));
        this.startPromise = void 0;
        this.engineStopDeferred = void 0;
      }
      kill(signal) {
        var _a32;
        this.getConfigPromise = void 0;
        this.globalKillSignalReceived = signal;
        (_a32 = this.child) == null ? void 0 : _a32.kill();
        this.connection.close();
      }
      getFreePort() {
        return new Promise((resolve, reject) => {
          const server = import_net.default.createServer((s) => s.end(""));
          server.unref();
          server.on("error", reject);
          server.listen(0, () => {
            const address = server.address();
            const port = typeof address === "string" ? parseInt(address.split(":").slice(-1)[0], 10) : address.port;
            server.close((e) => {
              if (e) {
                reject(e);
              }
              resolve(port);
            });
          });
        });
      }
      async getConfig() {
        if (!this.getConfigPromise) {
          this.getConfigPromise = this._getConfig();
        }
        return this.getConfigPromise;
      }
      async _getConfig() {
        const prismaPath = await this.getPrismaPath();
        const env2 = await this.getEngineEnvVars();
        const result = await (0, import_execa.default)(prismaPath, ["cli", "get-config"], {
          env: omit(env2, ["PORT"]),
          cwd: this.cwd
        });
        return JSON.parse(result.stdout);
      }
      async getDmmf() {
        if (!this.getDmmfPromise) {
          this.getDmmfPromise = this._getDmmf();
        }
        return this.getDmmfPromise;
      }
      async _getDmmf() {
        const prismaPath = await this.getPrismaPath();
        const env2 = await this.getEngineEnvVars();
        const result = await (0, import_execa.default)(prismaPath, ["--enable-raw-queries", "cli", "dmmf"], {
          env: omit(env2, ["PORT"]),
          cwd: this.cwd
        });
        return JSON.parse(result.stdout);
      }
      async version(forceRun = false) {
        if (this.versionPromise && !forceRun) {
          return this.versionPromise;
        }
        this.versionPromise = this.internalVersion();
        return this.versionPromise;
      }
      async internalVersion() {
        const prismaPath = await this.getPrismaPath();
        const result = await (0, import_execa.default)(prismaPath, ["--version"]);
        this.lastVersion = result.stdout;
        return this.lastVersion;
      }
      async request({
        query: query2,
        headers = {},
        numTry = 1,
        isWrite,
        transaction
      }) {
        await this.start();
        this.currentRequestPromise = this.connection.post("/", stringifyQuery(query2), runtimeHeadersToHttpHeaders(headers));
        this.lastQuery = query2;
        try {
          const { data, headers: headers2 } = await this.currentRequestPromise;
          if (data.errors) {
            if (data.errors.length === 1) {
              throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);
            }
            throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), { clientVersion: this.clientVersion });
          }
          const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
          if (this.startCount > 0) {
            this.startCount = 0;
          }
          this.currentRequestPromise = void 0;
          return { data, elapsed };
        } catch (e) {
          logger("req - e", e);
          const { error: error2, shouldRetry } = await this.handleRequestError(e);
          if (numTry <= MAX_REQUEST_RETRIES && shouldRetry && !isWrite) {
            logger("trying a retry now");
            return this.request({ query: query2, headers, numTry: numTry + 1, isWrite, transaction });
          }
          throw error2;
        }
      }
      async requestBatch({
        queries,
        headers = {},
        transaction,
        numTry = 1,
        containsWrite
      }) {
        await this.start();
        const request2 = {
          batch: queries.map((query2) => ({ query: query2, variables: {} })),
          transaction: Boolean(transaction),
          isolationLevel: transaction == null ? void 0 : transaction.isolationLevel
        };
        this.lastQuery = JSON.stringify(request2);
        this.currentRequestPromise = this.connection.post("/", this.lastQuery, runtimeHeadersToHttpHeaders(headers));
        return this.currentRequestPromise.then(({ data, headers: headers2 }) => {
          const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
          const { batchResult, errors } = data;
          if (Array.isArray(batchResult)) {
            return batchResult.map((result) => {
              if (result.errors && result.errors.length > 0) {
                return prismaGraphQLToJSError(result.errors[0], this.clientVersion);
              }
              return {
                data: result,
                elapsed
              };
            });
          } else {
            throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);
          }
        }).catch(async (e) => {
          const { error: error2, shouldRetry } = await this.handleRequestError(e);
          if (shouldRetry && !containsWrite) {
            if (numTry <= MAX_REQUEST_RETRIES) {
              return this.requestBatch({
                queries,
                headers,
                transaction,
                numTry: numTry + 1,
                containsWrite
              });
            }
          }
          throw error2;
        });
      }
      async transaction(action, headers, arg2) {
        var _a32, _b22;
        await this.start();
        if (action === "start") {
          const jsonOptions = JSON.stringify({
            max_wait: (_a32 = arg2 == null ? void 0 : arg2.maxWait) != null ? _a32 : 2e3,
            timeout: (_b22 = arg2 == null ? void 0 : arg2.timeout) != null ? _b22 : 5e3,
            isolation_level: arg2 == null ? void 0 : arg2.isolationLevel
          });
          const result = await Connection.onHttpError(
            this.connection.post(
              "/transaction/start",
              jsonOptions,
              runtimeHeadersToHttpHeaders(headers)
            ),
            (result2) => this.transactionHttpErrorHandler(result2)
          );
          return result.data;
        } else if (action === "commit") {
          await Connection.onHttpError(
            this.connection.post(`/transaction/${arg2.id}/commit`),
            (result) => this.transactionHttpErrorHandler(result)
          );
        } else if (action === "rollback") {
          await Connection.onHttpError(
            this.connection.post(`/transaction/${arg2.id}/rollback`),
            (result) => this.transactionHttpErrorHandler(result)
          );
        }
        return void 0;
      }
      get hasMaxRestarts() {
        return this.startCount >= MAX_STARTS;
      }
      throwAsyncErrorIfExists(forceThrow = false) {
        logger("throwAsyncErrorIfExists", this.startCount, this.hasMaxRestarts);
        if (this.lastError && (this.hasMaxRestarts || forceThrow)) {
          const lastError = this.lastError;
          this.lastError = void 0;
          if (lastError.isPanic()) {
            throw new PrismaClientRustPanicError(this.getErrorMessageWithLink(getMessage(lastError)), this.clientVersion);
          } else {
            throw new PrismaClientUnknownRequestError(this.getErrorMessageWithLink(getMessage(lastError)), {
              clientVersion: this.clientVersion
            });
          }
        }
      }
      getErrorMessageWithLink(title) {
        return getErrorMessageWithLink({
          platform: this.platform,
          title,
          version: this.clientVersion,
          engineVersion: this.lastVersion,
          database: this.lastActiveProvider,
          query: this.lastQuery
        });
      }
      async metrics({ format: format2, globalLabels }) {
        await this.start();
        const parseResponse = format2 === "json";
        const response = await this.connection.post(
          `/metrics?format=${encodeURIComponent(format2)}`,
          JSON.stringify(globalLabels),
          null,
          parseResponse
        );
        return response.data;
      }
      transactionHttpErrorHandler(result) {
        const response = result.data;
        throw new PrismaClientKnownRequestError(response.message, {
          code: response.error_code,
          clientVersion: this.clientVersion,
          meta: response.meta
        });
      }
    };
    __name(BinaryEngine, "BinaryEngine");
    function stringifyQuery(q) {
      return `{"variables":{},"query":${JSON.stringify(q)}}`;
    }
    __name(stringifyQuery, "stringifyQuery");
    function runtimeHeadersToHttpHeaders(headers) {
      if (headers.transactionId) {
        const { transactionId, ...httpHeaders } = headers;
        httpHeaders["X-transaction-id"] = transactionId;
        return httpHeaders;
      }
      return headers;
    }
    __name(runtimeHeadersToHttpHeaders, "runtimeHeadersToHttpHeaders");
    function hookProcess(handler, exit = false) {
      process.once(handler, async () => {
        for (const engine of engines) {
          await engine.emitExit();
          engine.kill(handler);
        }
        engines.splice(0, engines.length);
        if (socketPaths.length > 0) {
          for (const socketPath of socketPaths) {
            try {
              import_fs5.default.unlinkSync(socketPath);
            } catch (e) {
            }
          }
        }
        if (exit && process.listenerCount(handler) === 0) {
          process.exit();
        }
      });
    }
    __name(hookProcess, "hookProcess");
    var hooksInitialized = false;
    function initHooks() {
      if (!hooksInitialized) {
        hookProcess("beforeExit");
        hookProcess("exit");
        hookProcess("SIGINT", true);
        hookProcess("SIGUSR2", true);
        hookProcess("SIGTERM", true);
        hooksInitialized = true;
      }
    }
    __name(initHooks, "initHooks");
    function killProcessAndWait(childProcess) {
      return new Promise((resolve) => {
        childProcess.once("exit", resolve);
        childProcess.kill();
      });
    }
    __name(killProcessAndWait, "killProcessAndWait");
    function hasBatchIndex(value) {
      return typeof value["batchRequestIdx"] === "number";
    }
    __name(hasBatchIndex, "hasBatchIndex");
    var PrismaClientError = class extends Error {
      constructor(message, info2) {
        super(message);
        this.clientVersion = info2.clientVersion;
        this.cause = info2.cause;
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    __name(PrismaClientError, "PrismaClientError");
    var DataProxyError = class extends PrismaClientError {
      constructor(message, info2) {
        var _a32;
        super(message, info2);
        this.isRetryable = (_a32 = info2.isRetryable) != null ? _a32 : true;
      }
    };
    __name(DataProxyError, "DataProxyError");
    function setRetryable(info2, retryable) {
      return {
        ...info2,
        isRetryable: retryable
      };
    }
    __name(setRetryable, "setRetryable");
    var ForcedRetryError = class extends DataProxyError {
      constructor(info2) {
        super("This request must be retried", setRetryable(info2, true));
        this.name = "ForcedRetryError";
        this.code = "P5001";
      }
    };
    __name(ForcedRetryError, "ForcedRetryError");
    var InvalidDatasourceError = class extends DataProxyError {
      constructor(message, info2) {
        super(message, setRetryable(info2, false));
        this.name = "InvalidDatasourceError";
        this.code = "P5002";
      }
    };
    __name(InvalidDatasourceError, "InvalidDatasourceError");
    var NotImplementedYetError = class extends DataProxyError {
      constructor(message, info2) {
        super(message, setRetryable(info2, false));
        this.name = "NotImplementedYetError";
        this.code = "P5004";
      }
    };
    __name(NotImplementedYetError, "NotImplementedYetError");
    var DataProxyAPIError = class extends DataProxyError {
      constructor(message, info2) {
        var _a32;
        super(message, info2);
        this.response = info2.response;
        const requestId = (_a32 = this.response.headers) == null ? void 0 : _a32["Prisma-Request-Id"];
        if (requestId) {
          const messageSuffix = `(The request id was: ${requestId})`;
          this.message = this.message + " " + messageSuffix;
        }
      }
    };
    __name(DataProxyAPIError, "DataProxyAPIError");
    var SchemaMissingError = class extends DataProxyAPIError {
      constructor(info2) {
        super("Schema needs to be uploaded", setRetryable(info2, true));
        this.name = "SchemaMissingError";
        this.code = "P5005";
      }
    };
    __name(SchemaMissingError, "SchemaMissingError");
    var BAD_REQUEST_DEFAULT_MESSAGE = "This request could not be understood by the server";
    var BadRequestError = class extends DataProxyAPIError {
      constructor(info2, message, code) {
        super(message || BAD_REQUEST_DEFAULT_MESSAGE, setRetryable(info2, false));
        this.name = "BadRequestError";
        this.code = "P5000";
        if (code)
          this.code = code;
      }
    };
    __name(BadRequestError, "BadRequestError");
    var HealthcheckTimeoutError = class extends DataProxyAPIError {
      constructor(info2, logs) {
        super("Engine not started: healthcheck timeout", setRetryable(info2, true));
        this.name = "HealthcheckTimeoutError";
        this.code = "P5013";
        this.logs = logs;
      }
    };
    __name(HealthcheckTimeoutError, "HealthcheckTimeoutError");
    var EngineStartupError = class extends DataProxyAPIError {
      constructor(info2, message, logs) {
        super(message, setRetryable(info2, true));
        this.name = "EngineStartupError";
        this.code = "P5014";
        this.logs = logs;
      }
    };
    __name(EngineStartupError, "EngineStartupError");
    var EngineVersionNotSupportedError = class extends DataProxyAPIError {
      constructor(info2) {
        super("Engine version is not supported", setRetryable(info2, false));
        this.name = "EngineVersionNotSupportedError";
        this.code = "P5012";
      }
    };
    __name(EngineVersionNotSupportedError, "EngineVersionNotSupportedError");
    var GATEWAY_TIMEOUT_DEFAULT_MESSAGE = "Request timed out";
    var GatewayTimeoutError = class extends DataProxyAPIError {
      constructor(info2, message = GATEWAY_TIMEOUT_DEFAULT_MESSAGE) {
        super(message, setRetryable(info2, false));
        this.name = "GatewayTimeoutError";
        this.code = "P5009";
      }
    };
    __name(GatewayTimeoutError, "GatewayTimeoutError");
    var INTERACTIVE_TRANSACTION_ERROR_DEFAULT_MESSAGE = "Interactive transaction error";
    var InteractiveTransactionError = class extends DataProxyAPIError {
      constructor(info2, message = INTERACTIVE_TRANSACTION_ERROR_DEFAULT_MESSAGE) {
        super(message, setRetryable(info2, false));
        this.name = "InteractiveTransactionError";
        this.code = "P5015";
      }
    };
    __name(InteractiveTransactionError, "InteractiveTransactionError");
    var INVALID_REQUEST_DEFAULT_MESSAGE = "Request parameters are invalid";
    var InvalidRequestError = class extends DataProxyAPIError {
      constructor(info2, message = INVALID_REQUEST_DEFAULT_MESSAGE) {
        super(message, setRetryable(info2, false));
        this.name = "InvalidRequestError";
        this.code = "P5011";
      }
    };
    __name(InvalidRequestError, "InvalidRequestError");
    var NOT_FOUND_DEFAULT_MESSAGE = "Requested resource does not exist";
    var NotFoundError = class extends DataProxyAPIError {
      constructor(info2, message = NOT_FOUND_DEFAULT_MESSAGE) {
        super(message, setRetryable(info2, false));
        this.name = "NotFoundError";
        this.code = "P5003";
      }
    };
    __name(NotFoundError, "NotFoundError");
    var SERVER_ERROR_DEFAULT_MESSAGE = "Unknown server error";
    var ServerError = class extends DataProxyAPIError {
      constructor(info2, message, logs) {
        super(message || SERVER_ERROR_DEFAULT_MESSAGE, setRetryable(info2, true));
        this.name = "ServerError";
        this.code = "P5006";
        this.logs = logs;
      }
    };
    __name(ServerError, "ServerError");
    var UNAUTHORIZED_DEFAULT_MESSAGE = "Unauthorized, check your connection string";
    var UnauthorizedError = class extends DataProxyAPIError {
      constructor(info2, message = UNAUTHORIZED_DEFAULT_MESSAGE) {
        super(message, setRetryable(info2, false));
        this.name = "UnauthorizedError";
        this.code = "P5007";
      }
    };
    __name(UnauthorizedError, "UnauthorizedError");
    var USAGE_EXCEEDED_DEFAULT_MESSAGE = "Usage exceeded, retry again later";
    var UsageExceededError = class extends DataProxyAPIError {
      constructor(info2, message = USAGE_EXCEEDED_DEFAULT_MESSAGE) {
        super(message, setRetryable(info2, true));
        this.name = "UsageExceededError";
        this.code = "P5008";
      }
    };
    __name(UsageExceededError, "UsageExceededError");
    async function getResponseErrorBody(response) {
      let text;
      try {
        text = await response.text();
      } catch (e) {
        return { type: "EmptyError" };
      }
      try {
        const error2 = JSON.parse(text);
        if (typeof error2 === "string") {
          switch (error2) {
            case "InternalDataProxyError":
              return { type: "DataProxyError", body: error2 };
            default:
              return { type: "UnknownTextError", body: error2 };
          }
        }
        if (typeof error2 === "object" && error2 !== null) {
          if ("is_panic" in error2 && "message" in error2 && "error_code" in error2) {
            return { type: "QueryEngineError", body: error2 };
          }
          if ("EngineNotStarted" in error2 || "InteractiveTransactionMisrouted" in error2 || "InvalidRequestError" in error2) {
            const reason = Object.values(error2)[0].reason;
            if (typeof reason === "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(reason)) {
              return { type: "UnknownJsonError", body: error2 };
            }
            return { type: "DataProxyError", body: error2 };
          }
        }
        return { type: "UnknownJsonError", body: error2 };
      } catch (e) {
        return text === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: text };
      }
    }
    __name(getResponseErrorBody, "getResponseErrorBody");
    async function responseToError(response, clientVersion2) {
      if (response.ok)
        return void 0;
      const info2 = { clientVersion: clientVersion2, response };
      const error2 = await getResponseErrorBody(response);
      if (error2.type === "QueryEngineError") {
        throw new PrismaClientKnownRequestError(error2.body.message, { code: error2.body.error_code, clientVersion: clientVersion2 });
      }
      if (error2.type === "DataProxyError") {
        if (error2.body === "InternalDataProxyError") {
          throw new ServerError(info2, "Internal Data Proxy error");
        }
        if ("EngineNotStarted" in error2.body) {
          if (error2.body.EngineNotStarted.reason === "SchemaMissing") {
            return new SchemaMissingError(info2);
          }
          if (error2.body.EngineNotStarted.reason === "EngineVersionNotSupported") {
            throw new EngineVersionNotSupportedError(info2);
          }
          if ("EngineStartupError" in error2.body.EngineNotStarted.reason) {
            const { msg, logs } = error2.body.EngineNotStarted.reason.EngineStartupError;
            throw new EngineStartupError(info2, msg, logs);
          }
          if ("KnownEngineStartupError" in error2.body.EngineNotStarted.reason) {
            const { msg, error_code } = error2.body.EngineNotStarted.reason.KnownEngineStartupError;
            throw new PrismaClientInitializationError(msg, clientVersion2, error_code);
          }
          if ("HealthcheckTimeout" in error2.body.EngineNotStarted.reason) {
            const { logs } = error2.body.EngineNotStarted.reason.HealthcheckTimeout;
            throw new HealthcheckTimeoutError(info2, logs);
          }
        }
        if ("InteractiveTransactionMisrouted" in error2.body) {
          const messageByReason = {
            IDParseError: "Could not parse interactive transaction ID",
            NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID",
            TransactionStartError: "Could not start interactive transaction"
          };
          throw new InteractiveTransactionError(info2, messageByReason[error2.body.InteractiveTransactionMisrouted.reason]);
        }
        if ("InvalidRequestError" in error2.body) {
          throw new InvalidRequestError(info2, error2.body.InvalidRequestError.reason);
        }
      }
      if (response.status === 401 || response.status === 403) {
        throw new UnauthorizedError(info2, buildErrorMessage(UNAUTHORIZED_DEFAULT_MESSAGE, error2));
      }
      if (response.status === 404) {
        return new NotFoundError(info2, buildErrorMessage(NOT_FOUND_DEFAULT_MESSAGE, error2));
      }
      if (response.status === 429) {
        throw new UsageExceededError(info2, buildErrorMessage(USAGE_EXCEEDED_DEFAULT_MESSAGE, error2));
      }
      if (response.status === 504) {
        throw new GatewayTimeoutError(info2, buildErrorMessage(GATEWAY_TIMEOUT_DEFAULT_MESSAGE, error2));
      }
      if (response.status >= 500) {
        throw new ServerError(info2, buildErrorMessage(SERVER_ERROR_DEFAULT_MESSAGE, error2));
      }
      if (response.status >= 400) {
        throw new BadRequestError(info2, buildErrorMessage(BAD_REQUEST_DEFAULT_MESSAGE, error2));
      }
      return void 0;
    }
    __name(responseToError, "responseToError");
    function buildErrorMessage(defaultMessage, errorBody) {
      if (errorBody.type === "EmptyError") {
        return defaultMessage;
      }
      return `${defaultMessage}: ${JSON.stringify(errorBody)}`;
    }
    __name(buildErrorMessage, "buildErrorMessage");
    var BACKOFF_INTERVAL = 50;
    function backOff(n) {
      const baseDelay = Math.pow(2, n) * BACKOFF_INTERVAL;
      const jitter = Math.ceil(Math.random() * baseDelay) - Math.ceil(baseDelay / 2);
      const total = baseDelay + jitter;
      return new Promise((done) => setTimeout(() => done(total), total));
    }
    __name(backOff, "backOff");
    var devDependencies = {
      "@prisma/debug": "workspace:4.7.1",
      "@prisma/engines-version": "4.7.1-1.272861e07ab64f234d3ffc4094e32bd61775599c",
      "@prisma/fetch-engine": "workspace:4.7.1",
      "@prisma/get-platform": "workspace:4.7.1",
      "@swc/core": "1.3.14",
      "@swc/jest": "0.2.23",
      "@types/jest": "28.1.8",
      "@types/node": "16.18.3",
      execa: "5.1.1",
      jest: "28.1.3",
      typescript: "4.8.4"
    };
    var RequestError = class extends DataProxyError {
      constructor(message, info2) {
        super(`Cannot fetch data from service:
${message}`, setRetryable(info2, true));
        this.name = "RequestError";
        this.code = "P5010";
      }
    };
    __name(RequestError, "RequestError");
    function getJSRuntimeName() {
      if (typeof self === "undefined") {
        return "node";
      }
      return "browser";
    }
    __name(getJSRuntimeName, "getJSRuntimeName");
    async function request(url2, options) {
      var _a32;
      const clientVersion2 = options.clientVersion;
      const jsRuntimeName = getJSRuntimeName();
      try {
        if (jsRuntimeName === "browser") {
          return await fetch(url2, options);
        } else {
          return await nodeFetch(url2, options);
        }
      } catch (e) {
        const message = (_a32 = e.message) != null ? _a32 : "Unknown error";
        throw new RequestError(message, { clientVersion: clientVersion2 });
      }
    }
    __name(request, "request");
    function buildHeaders(options) {
      return {
        ...options.headers,
        "Content-Type": "application/json"
      };
    }
    __name(buildHeaders, "buildHeaders");
    function buildOptions(options) {
      return {
        method: options.method,
        headers: buildHeaders(options)
      };
    }
    __name(buildOptions, "buildOptions");
    function buildResponse(incomingData, response) {
      return {
        text: () => Buffer.concat(incomingData).toString(),
        json: () => JSON.parse(Buffer.concat(incomingData).toString()),
        ok: response.statusCode >= 200 && response.statusCode <= 299,
        status: response.statusCode,
        url: response.url,
        headers: response.headers
      };
    }
    __name(buildResponse, "buildResponse");
    async function nodeFetch(url2, options = {}) {
      const https3 = include("https");
      const httpsOptions = buildOptions(options);
      const incomingData = [];
      const { origin } = new URL(url2);
      return new Promise((resolve, reject) => {
        var _a32;
        const request2 = https3.request(url2, httpsOptions, (response) => {
          const { statusCode, headers: { location } } = response;
          if (statusCode >= 301 && statusCode <= 399 && location) {
            if (location.startsWith("http") === false) {
              resolve(nodeFetch(`${origin}${location}`, options));
            } else {
              resolve(nodeFetch(location, options));
            }
          }
          response.on("data", (chunk) => incomingData.push(chunk));
          response.on("end", () => resolve(buildResponse(incomingData, response)));
          response.on("error", reject);
        });
        request2.on("error", reject);
        request2.end((_a32 = options.body) != null ? _a32 : "");
      });
    }
    __name(nodeFetch, "nodeFetch");
    var include = typeof require !== "undefined" ? require : () => {
    };
    var semverRegex = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
    var debug6 = src_default("prisma:client:dataproxyEngine");
    async function _getClientVersion(config2) {
      var _a32, _b22, _c2;
      const engineVersion = devDependencies["@prisma/engines-version"];
      const clientVersion2 = (_a32 = config2.clientVersion) != null ? _a32 : "unknown";
      if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION) {
        return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
      }
      const [version, suffix] = (_b22 = clientVersion2 == null ? void 0 : clientVersion2.split("-")) != null ? _b22 : [];
      if (suffix === void 0 && semverRegex.test(version)) {
        return version;
      }
      if (suffix !== void 0 || clientVersion2 === "0.0.0") {
        const [version2] = (_c2 = engineVersion.split("-")) != null ? _c2 : [];
        const [major22, minor2, patch] = version2.split(".");
        const pkgURL = prismaPkgURL(`<=${major22}.${minor2}.${patch}`);
        const res = await request(pkgURL, { clientVersion: clientVersion2 });
        if (!res.ok) {
          throw new Error(
            `Failed to fetch stable Prisma version, unpkg.com status ${res.status} ${res.statusText}, response body: ${await res.text() || "<empty body>"}`
          );
        }
        const bodyAsText = await res.text();
        debug6("length of body fetched from unpkg.com", bodyAsText.length);
        let bodyAsJson;
        try {
          bodyAsJson = JSON.parse(bodyAsText);
        } catch (e) {
          console.error("JSON.parse error: body fetched from unpkg.com: ", bodyAsText);
          throw e;
        }
        return bodyAsJson["version"];
      }
      throw new NotImplementedYetError("Only `major.minor.patch` versions are supported by Prisma Data Proxy.", {
        clientVersion: clientVersion2
      });
    }
    __name(_getClientVersion, "_getClientVersion");
    async function getClientVersion(config2) {
      const version = await _getClientVersion(config2);
      debug6("version", version);
      return version;
    }
    __name(getClientVersion, "getClientVersion");
    function prismaPkgURL(version) {
      return encodeURI(`https://unpkg.com/prisma@${version}/package.json`);
    }
    __name(prismaPkgURL, "prismaPkgURL");
    var MAX_RETRIES = 10;
    var P = Promise.resolve();
    var debug7 = src_default("prisma:client:dataproxyEngine");
    var DataProxyEngine = class extends Engine {
      constructor(config2) {
        var _a32, _b22, _c2, _d2;
        super();
        this.config = config2;
        this.env = { ...this.config.env, ...process.env };
        this.inlineSchema = (_a32 = config2.inlineSchema) != null ? _a32 : "";
        this.inlineDatasources = (_b22 = config2.inlineDatasources) != null ? _b22 : {};
        this.inlineSchemaHash = (_c2 = config2.inlineSchemaHash) != null ? _c2 : "";
        this.clientVersion = (_d2 = config2.clientVersion) != null ? _d2 : "unknown";
        this.logEmitter = config2.logEmitter;
        const [host, apiKey] = this.extractHostAndApiKey();
        this.remoteClientVersion = P.then(() => getClientVersion(this.config));
        this.headers = { Authorization: `Bearer ${apiKey}` };
        this.host = host;
        debug7("host", this.host);
      }
      version() {
        return "unknown";
      }
      async start() {
      }
      async stop() {
      }
      on(event, listener) {
        if (event === "beforeExit") {
          throw new NotImplementedYetError("beforeExit event is not yet supported", {
            clientVersion: this.clientVersion
          });
        } else {
          this.logEmitter.on(event, listener);
        }
      }
      async url(s) {
        return `https://${this.host}/${await this.remoteClientVersion}/${this.inlineSchemaHash}/${s}`;
      }
      async getConfig() {
        return Promise.resolve({
          datasources: [
            {
              activeProvider: this.config.activeProvider
            }
          ]
        });
      }
      getDmmf() {
        throw new NotImplementedYetError("getDmmf is not yet supported", {
          clientVersion: this.clientVersion
        });
      }
      async uploadSchema() {
        const response = await request(await this.url("schema"), {
          method: "PUT",
          headers: this.headers,
          body: this.inlineSchema,
          clientVersion: this.clientVersion
        });
        if (!response.ok) {
          debug7("schema response status", response.status);
        }
        const err = await responseToError(response, this.clientVersion);
        if (err) {
          this.logEmitter.emit("warn", { message: `Error while uploading schema: ${err.message}` });
          throw err;
        } else {
          this.logEmitter.emit("info", {
            message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`
          });
        }
      }
      request({ query: query2, headers = {}, transaction }) {
        this.logEmitter.emit("query", { query: query2 });
        return this.requestInternal({ query: query2, variables: {} }, headers, transaction);
      }
      async requestBatch({
        queries,
        headers = {},
        transaction
      }) {
        const isTransaction = Boolean(transaction);
        this.logEmitter.emit("query", {
          query: `Batch${isTransaction ? " in transaction" : ""} (${queries.length}):
${queries.join("\n")}`
        });
        const body = {
          batch: queries.map((query2) => ({ query: query2, variables: {} })),
          transaction: isTransaction,
          isolationLevel: transaction == null ? void 0 : transaction.isolationLevel
        };
        const { batchResult, elapsed } = await this.requestInternal(body, headers);
        return batchResult.map((result) => {
          if ("errors" in result && result.errors.length > 0) {
            return prismaGraphQLToJSError(result.errors[0], this.clientVersion);
          }
          return {
            data: result,
            elapsed
          };
        });
      }
      requestInternal(body, headers, itx) {
        return this.withRetry({
          actionGerund: "querying",
          callback: async ({ logHttpCall }) => {
            const url2 = itx ? `${itx.payload.endpoint}/graphql` : await this.url("graphql");
            logHttpCall(url2);
            const response = await request(url2, {
              method: "POST",
              headers: { ...runtimeHeadersToHttpHeaders2(headers), ...this.headers },
              body: JSON.stringify(body),
              clientVersion: this.clientVersion
            });
            if (!response.ok) {
              debug7("graphql response status", response.status);
            }
            const e = await responseToError(response, this.clientVersion);
            await this.handleError(e);
            const data = await response.json();
            if (data.errors) {
              if (data.errors.length === 1) {
                throw prismaGraphQLToJSError(data.errors[0], this.config.clientVersion);
              } else {
                throw new PrismaClientUnknownRequestError(data.errors, { clientVersion: this.config.clientVersion });
              }
            }
            return data;
          }
        });
      }
      async transaction(action, headers, arg2) {
        const actionToGerund = {
          start: "starting",
          commit: "committing",
          rollback: "rolling back"
        };
        return this.withRetry({
          actionGerund: `${actionToGerund[action]} transaction`,
          callback: async ({ logHttpCall }) => {
            var _a32, _b22;
            if (action === "start") {
              const body = JSON.stringify({
                max_wait: (_a32 = arg2 == null ? void 0 : arg2.maxWait) != null ? _a32 : 2e3,
                timeout: (_b22 = arg2 == null ? void 0 : arg2.timeout) != null ? _b22 : 5e3,
                isolation_level: arg2 == null ? void 0 : arg2.isolationLevel
              });
              const url2 = await this.url("transaction/start");
              logHttpCall(url2);
              const response = await request(url2, {
                method: "POST",
                headers: { ...runtimeHeadersToHttpHeaders2(headers), ...this.headers },
                body,
                clientVersion: this.clientVersion
              });
              const err = await responseToError(response, this.clientVersion);
              await this.handleError(err);
              const json = await response.json();
              const id = json.id;
              const endpoint = json["data-proxy"].endpoint;
              return { id, payload: { endpoint } };
            } else {
              const url2 = `${arg2.payload.endpoint}/${action}`;
              logHttpCall(url2);
              const response = await request(url2, {
                method: "POST",
                headers: { ...runtimeHeadersToHttpHeaders2(headers), ...this.headers },
                clientVersion: this.clientVersion
              });
              const err = await responseToError(response, this.clientVersion);
              await this.handleError(err);
              return void 0;
            }
          }
        });
      }
      extractHostAndApiKey() {
        const datasources = this.mergeOverriddenDatasources();
        const mainDatasourceName = Object.keys(datasources)[0];
        const mainDatasource = datasources[mainDatasourceName];
        const dataProxyURL = this.resolveDatasourceURL(mainDatasourceName, mainDatasource);
        let url2;
        try {
          url2 = new URL(dataProxyURL);
        } catch (e) {
          throw new InvalidDatasourceError("Could not parse URL of the datasource", {
            clientVersion: this.clientVersion
          });
        }
        const { protocol, host, searchParams } = url2;
        if (protocol !== "prisma:") {
          throw new InvalidDatasourceError("Datasource URL must use prisma:// protocol when --data-proxy is used", {
            clientVersion: this.clientVersion
          });
        }
        const apiKey = searchParams.get("api_key");
        if (apiKey === null || apiKey.length < 1) {
          throw new InvalidDatasourceError("No valid API key found in the datasource URL", {
            clientVersion: this.clientVersion
          });
        }
        return [host, apiKey];
      }
      mergeOverriddenDatasources() {
        if (this.config.datasources === void 0) {
          return this.inlineDatasources;
        }
        const finalDatasources = { ...this.inlineDatasources };
        for (const override of this.config.datasources) {
          if (!this.inlineDatasources[override.name]) {
            throw new Error(`Unknown datasource: ${override.name}`);
          }
          finalDatasources[override.name] = {
            url: {
              fromEnvVar: null,
              value: override.url
            }
          };
        }
        return finalDatasources;
      }
      resolveDatasourceURL(name, datasource) {
        if (datasource.url.value) {
          return datasource.url.value;
        }
        if (datasource.url.fromEnvVar) {
          const envVar = datasource.url.fromEnvVar;
          const loadedEnvURL = this.env[envVar];
          if (loadedEnvURL === void 0) {
            throw new InvalidDatasourceError(
              `Datasource "${name}" references an environment variable "${envVar}" that is not set`,
              {
                clientVersion: this.clientVersion
              }
            );
          }
          return loadedEnvURL;
        }
        throw new InvalidDatasourceError(
          `Datasource "${name}" specification is invalid: both value and fromEnvVar are null`,
          {
            clientVersion: this.clientVersion
          }
        );
      }
      metrics(options) {
        throw new NotImplementedYetError("Metric are not yet supported for Data Proxy", {
          clientVersion: this.clientVersion
        });
      }
      async withRetry(args) {
        var _a32;
        for (let attempt = 0; ; attempt++) {
          const logHttpCall = /* @__PURE__ */ __name((url2) => {
            this.logEmitter.emit("info", {
              message: `Calling ${url2} (n=${attempt})`
            });
          }, "logHttpCall");
          try {
            return await args.callback({ logHttpCall });
          } catch (e) {
            if (!(e instanceof DataProxyError))
              throw e;
            if (!e.isRetryable)
              throw e;
            if (attempt >= MAX_RETRIES) {
              if (e instanceof ForcedRetryError) {
                throw e.cause;
              } else {
                throw e;
              }
            }
            this.logEmitter.emit("warn", {
              message: `Attempt ${attempt + 1}/${MAX_RETRIES} failed for ${args.actionGerund}: ${(_a32 = e.message) != null ? _a32 : "(unknown)"}`
            });
            const delay2 = await backOff(attempt);
            this.logEmitter.emit("warn", { message: `Retrying after ${delay2}ms` });
          }
        }
      }
      async handleError(error2) {
        if (error2 instanceof SchemaMissingError) {
          await this.uploadSchema();
          throw new ForcedRetryError({
            clientVersion: this.clientVersion,
            cause: error2
          });
        } else if (error2) {
          throw error2;
        }
      }
    };
    __name(DataProxyEngine, "DataProxyEngine");
    function runtimeHeadersToHttpHeaders2(headers) {
      if (headers.transactionId) {
        const httpHeaders = { ...headers };
        delete httpHeaders.transactionId;
        return httpHeaders;
      }
      return headers;
    }
    __name(runtimeHeadersToHttpHeaders2, "runtimeHeadersToHttpHeaders");
    var import_chalk5 = __toESM(require_source());
    var import_fs7 = __toESM(require("fs"));
    var import_chalk4 = __toESM(require_source());
    var import_fs6 = __toESM(require("fs"));
    var import_path4 = __toESM(require("path"));
    var debug8 = src_default("prisma:client:libraryEngine:loader");
    var DefaultLibraryLoader = class {
      constructor(config2) {
        this.libQueryEnginePath = null;
        this.platform = null;
        this.config = config2;
      }
      async loadLibrary() {
        if (!this.libQueryEnginePath) {
          this.libQueryEnginePath = await this.getLibQueryEnginePath();
        }
        debug8(`loadEngine using ${this.libQueryEnginePath}`);
        try {
          return eval("require")(this.libQueryEnginePath);
        } catch (e) {
          if (import_fs6.default.existsSync(this.libQueryEnginePath)) {
            if (this.libQueryEnginePath.endsWith(".node")) {
              throw new PrismaClientInitializationError(
                `Unable to load Node-API Library from ${import_chalk4.default.dim(this.libQueryEnginePath)}, Library may be corrupt`,
                this.config.clientVersion
              );
            } else {
              throw new PrismaClientInitializationError(
                `Expected an Node-API Library but received ${import_chalk4.default.dim(this.libQueryEnginePath)}`,
                this.config.clientVersion
              );
            }
          } else {
            throw new PrismaClientInitializationError(
              `Unable to load Node-API Library from ${import_chalk4.default.dim(this.libQueryEnginePath)}, It does not exist`,
              this.config.clientVersion
            );
          }
        }
      }
      async getLibQueryEnginePath() {
        var _a32, _b22, _c2, _d2;
        const libPath = (_a32 = process.env.PRISMA_QUERY_ENGINE_LIBRARY) != null ? _a32 : this.config.prismaPath;
        if (libPath && import_fs6.default.existsSync(libPath) && libPath.endsWith(".node")) {
          return libPath;
        }
        this.platform = (_b22 = this.platform) != null ? _b22 : await getPlatform();
        const { enginePath: enginePath2, searchedLocations: searchedLocations2 } = await this.resolveEnginePath();
        if (!import_fs6.default.existsSync(enginePath2)) {
          const incorrectPinnedPlatformErrorStr = this.platform ? `
You incorrectly pinned it to ${import_chalk4.default.redBright.bold(`${this.platform}`)}
` : "";
          let errorText = `Query engine library for current platform "${import_chalk4.default.bold(
            this.platform
          )}" could not be found.${incorrectPinnedPlatformErrorStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${import_chalk4.default.underline(enginePath2)}")

Searched Locations:

${searchedLocations2.map((f) => {
            let msg = `  ${f}`;
            if (process.env.DEBUG === "node-engine-search-locations" && import_fs6.default.existsSync(f)) {
              const dir = import_fs6.default.readdirSync(f);
              msg += dir.map((d) => `    ${d}`).join("\n");
            }
            return msg;
          }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
          if (this.config.generator) {
            this.platform = (_c2 = this.platform) != null ? _c2 : await getPlatform();
            if (this.config.generator.binaryTargets.find((object) => object.value === this.platform) || this.config.generator.binaryTargets.find((object) => object.value === "native")) {
              errorText += `
You already added the platform${this.config.generator.binaryTargets.length > 1 ? "s" : ""} ${this.config.generator.binaryTargets.map((t) => `"${import_chalk4.default.bold(t.value)}"`).join(", ")} to the "${import_chalk4.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
              errorText += ``;
            } else {
              errorText += `

To solve this problem, add the platform "${this.platform}" to the "${import_chalk4.default.underline(
                "binaryTargets"
              )}" attribute in the "${import_chalk4.default.underline("generator")}" block in the "schema.prisma" file:
${import_chalk4.default.greenBright(this.getFixedGenerator())}

Then run "${import_chalk4.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
            }
          } else {
            errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
          }
          throw new PrismaClientInitializationError(errorText, this.config.clientVersion);
        }
        this.platform = (_d2 = this.platform) != null ? _d2 : await getPlatform();
        return enginePath2;
      }
      async resolveEnginePath() {
        var _a3, _b2, _c, _d;
        const searchedLocations = [];
        let enginePath;
        if (this.libQueryEnginePath) {
          return { enginePath: this.libQueryEnginePath, searchedLocations };
        }
        this.platform = (_a3 = this.platform) != null ? _a3 : await getPlatform();
        if (__filename.includes("DefaultLibraryLoader")) {
          enginePath = import_path4.default.join(getEnginesPath(), getNodeAPIName(this.platform, "fs"));
          return { enginePath, searchedLocations };
        }
        const dirname = eval("__dirname");
        const searchLocations = [
          import_path4.default.resolve(dirname, "../../../.prisma/client"),
          (_d = (_c = (_b2 = this.config.generator) == null ? void 0 : _b2.output) == null ? void 0 : _c.value) != null ? _d : dirname,
          import_path4.default.resolve(dirname, ".."),
          import_path4.default.dirname(this.config.datamodelPath),
          this.config.cwd,
          "/tmp/prisma-engines"
        ];
        if (this.config.dirname) {
          searchLocations.push(this.config.dirname);
        }
        for (const location of searchLocations) {
          searchedLocations.push(location);
          debug8(`Searching for Query Engine Library in ${location}`);
          enginePath = import_path4.default.join(location, getNodeAPIName(this.platform, "fs"));
          if (import_fs6.default.existsSync(enginePath)) {
            return { enginePath, searchedLocations };
          }
        }
        enginePath = import_path4.default.join(__dirname, getNodeAPIName(this.platform, "fs"));
        return { enginePath: enginePath != null ? enginePath : "", searchedLocations };
      }
      getFixedGenerator() {
        const fixedGenerator = {
          ...this.config.generator,
          binaryTargets: fixBinaryTargets(this.config.generator.binaryTargets, this.platform)
        };
        return printGeneratorConfig(fixedGenerator);
      }
    };
    __name(DefaultLibraryLoader, "DefaultLibraryLoader");
    var debug9 = src_default("prisma:client:libraryEngine:exitHooks");
    var ExitHooks = class {
      constructor() {
        this.nextOwnerId = 1;
        this.ownerToIdMap = /* @__PURE__ */ new WeakMap();
        this.idToListenerMap = /* @__PURE__ */ new Map();
        this.areHooksInstalled = false;
      }
      install() {
        if (this.areHooksInstalled) {
          return;
        }
        this.installHook("beforeExit");
        this.installHook("exit");
        this.installHook("SIGINT", true);
        this.installHook("SIGUSR2", true);
        this.installHook("SIGTERM", true);
        this.areHooksInstalled = true;
      }
      setListener(owner, listener) {
        if (listener) {
          let id = this.ownerToIdMap.get(owner);
          if (!id) {
            id = this.nextOwnerId++;
            this.ownerToIdMap.set(owner, id);
          }
          this.idToListenerMap.set(id, listener);
        } else {
          const id = this.ownerToIdMap.get(owner);
          if (id !== void 0) {
            this.ownerToIdMap.delete(owner);
            this.idToListenerMap.delete(id);
          }
        }
      }
      getListener(owner) {
        const id = this.ownerToIdMap.get(owner);
        if (id === void 0) {
          return void 0;
        }
        return this.idToListenerMap.get(id);
      }
      installHook(event, shouldExit = false) {
        process.once(event, async (code) => {
          debug9(`exit event received: ${event}`);
          for (const listener of this.idToListenerMap.values()) {
            await listener();
          }
          this.idToListenerMap.clear();
          if (shouldExit && process.listenerCount(event) === 0) {
            process.exit(code);
          }
        });
      }
    };
    __name(ExitHooks, "ExitHooks");
    var debug10 = src_default("prisma:client:libraryEngine");
    function isQueryEvent(event) {
      return event["item_type"] === "query" && "query" in event;
    }
    __name(isQueryEvent, "isQueryEvent");
    function isPanicEvent(event) {
      if ("level" in event) {
        return event.level === "error" && event["message"] === "PANIC";
      } else {
        return false;
      }
    }
    __name(isPanicEvent, "isPanicEvent");
    var knownPlatforms2 = [...platforms, "native"];
    var engineInstanceCount = 0;
    var exitHooks = new ExitHooks();
    var LibraryEngine = class extends Engine {
      constructor(config2, loader = new DefaultLibraryLoader(config2)) {
        var _a32, _b22;
        super();
        this.datamodel = import_fs7.default.readFileSync(config2.datamodelPath, "utf-8");
        this.config = config2;
        this.libraryStarted = false;
        this.logQueries = (_a32 = config2.logQueries) != null ? _a32 : false;
        this.logLevel = (_b22 = config2.logLevel) != null ? _b22 : "error";
        this.libraryLoader = loader;
        this.logEmitter = config2.logEmitter;
        this.datasourceOverrides = config2.datasources ? this.convertDatasources(config2.datasources) : {};
        if (config2.enableDebugLogs) {
          this.logLevel = "debug";
        }
        this.libraryInstantiationPromise = this.instantiateLibrary();
        exitHooks.install();
        this.checkForTooManyEngines();
      }
      get beforeExitListener() {
        return exitHooks.getListener(this);
      }
      set beforeExitListener(listener) {
        exitHooks.setListener(this, listener);
      }
      checkForTooManyEngines() {
        if (engineInstanceCount === 10) {
          console.warn(
            `${import_chalk5.default.yellow("warn(prisma-client)")} There are already 10 instances of Prisma Client actively running.`
          );
        }
      }
      async transaction(action, headers, arg2) {
        var _a32, _b22, _c2, _d2, _e;
        await this.start();
        const headerStr = JSON.stringify(headers);
        let result;
        if (action === "start") {
          const jsonOptions = JSON.stringify({
            max_wait: (_a32 = arg2 == null ? void 0 : arg2.maxWait) != null ? _a32 : 2e3,
            timeout: (_b22 = arg2 == null ? void 0 : arg2.timeout) != null ? _b22 : 5e3,
            isolation_level: arg2 == null ? void 0 : arg2.isolationLevel
          });
          result = await ((_c2 = this.engine) == null ? void 0 : _c2.startTransaction(jsonOptions, headerStr));
        } else if (action === "commit") {
          result = await ((_d2 = this.engine) == null ? void 0 : _d2.commitTransaction(arg2.id, headerStr));
        } else if (action === "rollback") {
          result = await ((_e = this.engine) == null ? void 0 : _e.rollbackTransaction(arg2.id, headerStr));
        }
        const response = this.parseEngineResponse(result);
        if (response.error_code) {
          throw new PrismaClientKnownRequestError(response.message, {
            code: response.error_code,
            clientVersion: this.config.clientVersion,
            meta: response.meta
          });
        }
        return response;
      }
      async instantiateLibrary() {
        debug10("internalSetup");
        if (this.libraryInstantiationPromise) {
          return this.libraryInstantiationPromise;
        }
        await isNodeAPISupported();
        this.platform = await this.getPlatform();
        await this.loadEngine();
        this.version();
      }
      async getPlatform() {
        if (this.platform)
          return this.platform;
        const platform3 = await getPlatform();
        if (!knownPlatforms2.includes(platform3)) {
          throw new PrismaClientInitializationError(
            `Unknown ${import_chalk5.default.red("PRISMA_QUERY_ENGINE_LIBRARY")} ${import_chalk5.default.redBright.bold(
              platform3
            )}. Possible binaryTargets: ${import_chalk5.default.greenBright(
              knownPlatforms2.join(", ")
            )} or a path to the query engine library.
You may have to run ${import_chalk5.default.greenBright("prisma generate")} for your changes to take effect.`,
            this.config.clientVersion
          );
        }
        return platform3;
      }
      parseEngineResponse(response) {
        if (!response) {
          throw new PrismaClientUnknownRequestError(`Response from the Engine was empty`, {
            clientVersion: this.config.clientVersion
          });
        }
        try {
          const config2 = JSON.parse(response);
          return config2;
        } catch (err) {
          throw new PrismaClientUnknownRequestError(`Unable to JSON.parse response from engine`, {
            clientVersion: this.config.clientVersion
          });
        }
      }
      convertDatasources(datasources) {
        const obj = /* @__PURE__ */ Object.create(null);
        for (const { name, url: url2 } of datasources) {
          obj[name] = url2;
        }
        return obj;
      }
      async loadEngine() {
        var _a32;
        if (!this.engine) {
          if (!this.QueryEngineConstructor) {
            this.library = await this.libraryLoader.loadLibrary();
            this.QueryEngineConstructor = this.library.QueryEngine;
          }
          try {
            const weakThis = new WeakRef(this);
            this.engine = new this.QueryEngineConstructor(
              {
                datamodel: this.datamodel,
                env: process.env,
                logQueries: (_a32 = this.config.logQueries) != null ? _a32 : false,
                ignoreEnvVarErrors: false,
                datasourceOverrides: this.datasourceOverrides,
                logLevel: this.logLevel,
                configDir: this.config.cwd
              },
              (log3) => {
                var _a4;
                (_a4 = weakThis.deref()) == null ? void 0 : _a4.logger(log3);
              }
            );
            engineInstanceCount++;
          } catch (_e) {
            const e = _e;
            const error2 = this.parseInitError(e.message);
            if (typeof error2 === "string") {
              throw e;
            } else {
              throw new PrismaClientInitializationError(error2.message, this.config.clientVersion, error2.error_code);
            }
          }
        }
      }
      logger(log3) {
        var _a32;
        const event = this.parseEngineResponse(log3);
        if (!event)
          return;
        if ("span" in event) {
          if (this.config.tracingConfig.enabled === true) {
            void createSpan(event);
          }
          return;
        }
        event.level = (_a32 = event == null ? void 0 : event.level.toLowerCase()) != null ? _a32 : "unknown";
        if (isQueryEvent(event)) {
          this.logEmitter.emit("query", {
            timestamp: /* @__PURE__ */ new Date(),
            query: event.query,
            params: event.params,
            duration: Number(event.duration_ms),
            target: event.module_path
          });
        } else if (isPanicEvent(event)) {
          this.loggerRustPanic = new PrismaClientRustPanicError(
            this.getErrorMessageWithLink(
              `${event.message}: ${event.reason} in ${event.file}:${event.line}:${event.column}`
            ),
            this.config.clientVersion
          );
        } else {
          this.logEmitter.emit(event.level, {
            timestamp: /* @__PURE__ */ new Date(),
            message: event.message,
            target: event.module_path
          });
        }
      }
      getErrorMessageWithLink(title) {
        var _a32;
        return getErrorMessageWithLink({
          platform: this.platform,
          title,
          version: this.config.clientVersion,
          engineVersion: (_a32 = this.versionInfo) == null ? void 0 : _a32.commit,
          database: this.config.activeProvider,
          query: this.lastQuery
        });
      }
      parseInitError(str) {
        try {
          const error2 = JSON.parse(str);
          return error2;
        } catch (e) {
        }
        return str;
      }
      parseRequestError(str) {
        try {
          const error2 = JSON.parse(str);
          return error2;
        } catch (e) {
        }
        return str;
      }
      on(event, listener) {
        if (event === "beforeExit") {
          this.beforeExitListener = listener;
        } else {
          this.logEmitter.on(event, listener);
        }
      }
      async start() {
        await this.libraryInstantiationPromise;
        await this.libraryStoppingPromise;
        if (this.libraryStartingPromise) {
          debug10(`library already starting, this.libraryStarted: ${this.libraryStarted}`);
          return this.libraryStartingPromise;
        }
        if (this.libraryStarted) {
          return;
        }
        const startFn = /* @__PURE__ */ __name(async () => {
          var _a32;
          debug10("library starting");
          try {
            const headers = {
              traceparent: getTraceParent({ tracingConfig: this.config.tracingConfig })
            };
            await ((_a32 = this.engine) == null ? void 0 : _a32.connect(JSON.stringify(headers)));
            this.libraryStarted = true;
            debug10("library started");
          } catch (err) {
            const error2 = this.parseInitError(err.message);
            if (typeof error2 === "string") {
              throw err;
            } else {
              throw new PrismaClientInitializationError(error2.message, this.config.clientVersion, error2.error_code);
            }
          } finally {
            this.libraryStartingPromise = void 0;
          }
        }, "startFn");
        const spanConfig = {
          name: "connect",
          enabled: this.config.tracingConfig.enabled
        };
        this.libraryStartingPromise = runInChildSpan(spanConfig, startFn);
        return this.libraryStartingPromise;
      }
      async stop() {
        await this.libraryStartingPromise;
        await this.executingQueryPromise;
        if (this.libraryStoppingPromise) {
          debug10("library is already stopping");
          return this.libraryStoppingPromise;
        }
        if (!this.libraryStarted) {
          return;
        }
        const stopFn = /* @__PURE__ */ __name(async () => {
          var _a32;
          await new Promise((r) => setTimeout(r, 5));
          debug10("library stopping");
          const headers = {
            traceparent: getTraceParent({ tracingConfig: this.config.tracingConfig })
          };
          await ((_a32 = this.engine) == null ? void 0 : _a32.disconnect(JSON.stringify(headers)));
          this.libraryStarted = false;
          this.libraryStoppingPromise = void 0;
          debug10("library stopped");
        }, "stopFn");
        const spanConfig = {
          name: "disconnect",
          enabled: this.config.tracingConfig.enabled
        };
        this.libraryStoppingPromise = runInChildSpan(spanConfig, stopFn);
        return this.libraryStoppingPromise;
      }
      async getConfig() {
        await this.libraryInstantiationPromise;
        return this.library.getConfig({
          datamodel: this.datamodel,
          datasourceOverrides: this.datasourceOverrides,
          ignoreEnvVarErrors: true,
          env: process.env
        });
      }
      async getDmmf() {
        await this.libraryInstantiationPromise;
        return JSON.parse(await this.library.dmmf(this.datamodel));
      }
      version() {
        var _a32, _b22, _c2;
        this.versionInfo = (_a32 = this.library) == null ? void 0 : _a32.version();
        return (_c2 = (_b22 = this.versionInfo) == null ? void 0 : _b22.version) != null ? _c2 : "unknown";
      }
      debugPanic(message) {
        var _a32;
        return (_a32 = this.library) == null ? void 0 : _a32.debugPanic(message);
      }
      async request({ query: query2, headers = {} }) {
        var _a32, _b22;
        debug10(`sending request, this.libraryStarted: ${this.libraryStarted}`);
        const request2 = { query: query2, variables: {} };
        const headerStr = JSON.stringify(headers);
        const queryStr = JSON.stringify(request2);
        try {
          await this.start();
          this.executingQueryPromise = (_a32 = this.engine) == null ? void 0 : _a32.query(queryStr, headerStr, headers.transactionId);
          this.lastQuery = queryStr;
          const data = this.parseEngineResponse(await this.executingQueryPromise);
          if (data.errors) {
            if (data.errors.length === 1) {
              throw this.buildQueryError(data.errors[0]);
            }
            throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), {
              clientVersion: this.config.clientVersion
            });
          } else if (this.loggerRustPanic) {
            throw this.loggerRustPanic;
          }
          return { data, elapsed: 0 };
        } catch (e) {
          if (e instanceof PrismaClientInitializationError) {
            throw e;
          }
          if (e.code === "GenericFailure" && ((_b22 = e.message) == null ? void 0 : _b22.startsWith("PANIC:"))) {
            throw new PrismaClientRustPanicError(this.getErrorMessageWithLink(e.message), this.config.clientVersion);
          }
          const error2 = this.parseRequestError(e.message);
          if (typeof error2 === "string") {
            throw e;
          } else {
            throw new PrismaClientUnknownRequestError(`${error2.message}
${error2.backtrace}`, {
              clientVersion: this.config.clientVersion
            });
          }
        }
      }
      async requestBatch({
        queries,
        headers = {},
        transaction
      }) {
        debug10("requestBatch");
        const request2 = {
          batch: queries.map((query2) => ({ query: query2, variables: {} })),
          transaction: Boolean(transaction),
          isolationLevel: transaction == null ? void 0 : transaction.isolationLevel
        };
        await this.start();
        this.lastQuery = JSON.stringify(request2);
        this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify(headers), headers.transactionId);
        const result = await this.executingQueryPromise;
        const data = this.parseEngineResponse(result);
        if (data.errors) {
          if (data.errors.length === 1) {
            throw this.buildQueryError(data.errors[0]);
          }
          throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), {
            clientVersion: this.config.clientVersion
          });
        }
        const { batchResult, errors } = data;
        if (Array.isArray(batchResult)) {
          return batchResult.map((result2) => {
            var _a32;
            if (result2.errors && result2.errors.length > 0) {
              return (_a32 = this.loggerRustPanic) != null ? _a32 : this.buildQueryError(result2.errors[0]);
            }
            return {
              data: result2,
              elapsed: 0
            };
          });
        } else {
          if (errors && errors.length === 1) {
            throw new Error(errors[0].error);
          }
          throw new Error(JSON.stringify(data));
        }
      }
      buildQueryError(error2) {
        if (error2.user_facing_error.is_panic) {
          return new PrismaClientRustPanicError(
            this.getErrorMessageWithLink(error2.user_facing_error.message),
            this.config.clientVersion
          );
        }
        return prismaGraphQLToJSError(error2, this.config.clientVersion);
      }
      async metrics(options) {
        await this.start();
        const responseString = await this.engine.metrics(JSON.stringify(options));
        if (options.format === "prometheus") {
          return responseString;
        }
        return this.parseEngineResponse(responseString);
      }
    };
    __name(LibraryEngine, "LibraryEngine");
    var DMMF;
    ((DMMF2) => {
      let ModelAction;
      ((ModelAction2) => {
        ModelAction2["findUnique"] = "findUnique";
        ModelAction2["findUniqueOrThrow"] = "findUniqueOrThrow";
        ModelAction2["findFirst"] = "findFirst";
        ModelAction2["findFirstOrThrow"] = "findFirstOrThrow";
        ModelAction2["findMany"] = "findMany";
        ModelAction2["create"] = "create";
        ModelAction2["createMany"] = "createMany";
        ModelAction2["update"] = "update";
        ModelAction2["updateMany"] = "updateMany";
        ModelAction2["upsert"] = "upsert";
        ModelAction2["delete"] = "delete";
        ModelAction2["deleteMany"] = "deleteMany";
        ModelAction2["groupBy"] = "groupBy";
        ModelAction2["count"] = "count";
        ModelAction2["aggregate"] = "aggregate";
        ModelAction2["findRaw"] = "findRaw";
        ModelAction2["aggregateRaw"] = "aggregateRaw";
      })(ModelAction = DMMF2.ModelAction || (DMMF2.ModelAction = {}));
    })(DMMF || (DMMF = {}));
    var logger_exports = {};
    __export(logger_exports, {
      error: () => error,
      info: () => info,
      log: () => log,
      query: () => query,
      should: () => should,
      tags: () => tags,
      warn: () => warn
    });
    var import_chalk6 = __toESM(require_source());
    var tags = {
      error: import_chalk6.default.red("prisma:error"),
      warn: import_chalk6.default.yellow("prisma:warn"),
      info: import_chalk6.default.cyan("prisma:info"),
      query: import_chalk6.default.blue("prisma:query")
    };
    var should = {
      warn: () => !process.env.PRISMA_DISABLE_WARNINGS
    };
    function log(...data) {
      console.log(...data);
    }
    __name(log, "log");
    function warn(message, ...optionalParams) {
      if (should.warn()) {
        console.warn(`${tags.warn} ${message}`, ...optionalParams);
      }
    }
    __name(warn, "warn");
    function info(message, ...optionalParams) {
      console.info(`${tags.info} ${message}`, ...optionalParams);
    }
    __name(info, "info");
    function error(message, ...optionalParams) {
      console.error(`${tags.error} ${message}`, ...optionalParams);
    }
    __name(error, "error");
    function query(message, ...optionalParams) {
      console.log(`${tags.query} ${message}`, ...optionalParams);
    }
    __name(query, "query");
    function callOnce(fn) {
      let result;
      return (...args) => result != null ? result : result = fn(...args);
    }
    __name(callOnce, "callOnce");
    function hasOwnProperty2(object, key) {
      return Object.prototype.hasOwnProperty.call(object, key);
    }
    __name(hasOwnProperty2, "hasOwnProperty");
    function isPromiseLike(value) {
      return value != null && typeof value["then"] === "function";
    }
    __name(isPromiseLike, "isPromiseLike");
    var keyBy = /* @__PURE__ */ __name((collection, iteratee) => {
      return collection.reduce((acc, curr) => {
        acc[iteratee(curr)] = curr;
        return acc;
      }, {});
    }, "keyBy");
    function mapObjectValues(object, mapper) {
      return Object.fromEntries(
        Object.entries(object).map(([key, value]) => [key, mapper(value, key)])
      );
    }
    __name(mapObjectValues, "mapObjectValues");
    var alreadyWarned = /* @__PURE__ */ new Set();
    var warnOnce = /* @__PURE__ */ __name((key, message, ...args) => {
      if (!alreadyWarned.has(key)) {
        alreadyWarned.add(key);
        warn(message, ...args);
      }
    }, "warnOnce");
    var PrismaClientExtensionError = class extends Error {
      constructor(extensionName, cause) {
        super(`${getTitleFromExtensionName(extensionName)}: ${getMessageFromCause(cause)}`, { cause });
        this.extensionName = extensionName;
        this.name = "PrismaClientExtensionError";
        if (!this.cause) {
          this.cause = cause;
        }
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, PrismaClientExtensionError);
        }
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientExtensionError";
      }
    };
    __name(PrismaClientExtensionError, "PrismaClientExtensionError");
    function getTitleFromExtensionName(extensionName) {
      if (extensionName) {
        return `Error caused by extension "${extensionName}"`;
      }
      return "Error caused by an extension";
    }
    __name(getTitleFromExtensionName, "getTitleFromExtensionName");
    function getMessageFromCause(cause) {
      if (cause instanceof Error) {
        return cause.message;
      }
      return `${cause}`;
    }
    __name(getMessageFromCause, "getMessageFromCause");
    function wrapExtensionCallback(name, fn) {
      return function(...args) {
        try {
          const result = fn.apply(this, args);
          if (isPromiseLike(result)) {
            return result.then(void 0, (error2) => Promise.reject(new PrismaClientExtensionError(name, error2)));
          }
          return result;
        } catch (error2) {
          throw new PrismaClientExtensionError(name, error2);
        }
      };
    }
    __name(wrapExtensionCallback, "wrapExtensionCallback");
    function wrapAllExtensionCallbacks(name, object) {
      if (!object) {
        return object;
      }
      return mapObjectValues(
        object,
        (prop) => typeof prop === "function" ? wrapExtensionCallback(name, prop) : prop
      );
    }
    __name(wrapAllExtensionCallbacks, "wrapAllExtensionCallbacks");
    var MetricsClient = class {
      constructor(engine) {
        this._engine = engine;
      }
      prometheus(options) {
        return this._engine.metrics({ format: "prometheus", ...options });
      }
      json(options) {
        return this._engine.metrics({ format: "json", ...options });
      }
    };
    __name(MetricsClient, "MetricsClient");
    function applyMixins(derivedCtor, constructors) {
      var _a32;
      for (const baseCtor of constructors) {
        for (const name of Object.getOwnPropertyNames(baseCtor.prototype)) {
          Object.defineProperty(
            derivedCtor.prototype,
            name,
            (_a32 = Object.getOwnPropertyDescriptor(baseCtor.prototype, name)) != null ? _a32 : /* @__PURE__ */ Object.create(null)
          );
        }
      }
    }
    __name(applyMixins, "applyMixins");
    var import_chalk7 = __toESM(require_source());
    var EXP_LIMIT = 9e15;
    var MAX_DIGITS = 1e9;
    var NUMERALS = "0123456789abcdef";
    var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var DEFAULTS = {
      precision: 20,
      rounding: 4,
      modulo: 1,
      toExpNeg: -7,
      toExpPos: 21,
      minE: -EXP_LIMIT,
      maxE: EXP_LIMIT,
      crypto: false
    };
    var inexact;
    var quadrant;
    var external = true;
    var decimalError = "[DecimalError] ";
    var invalidArgument = decimalError + "Invalid argument: ";
    var precisionLimitExceeded = decimalError + "Precision limit exceeded";
    var cryptoUnavailable = decimalError + "crypto unavailable";
    var tag = "[object Decimal]";
    var mathfloor = Math.floor;
    var mathpow = Math.pow;
    var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var BASE = 1e7;
    var LOG_BASE = 7;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var LN10_PRECISION = LN10.length - 1;
    var PI_PRECISION = PI.length - 1;
    var P2 = { toStringTag: tag };
    P2.absoluteValue = P2.abs = function() {
      var x = new this.constructor(this);
      if (x.s < 0)
        x.s = 1;
      return finalise(x);
    };
    P2.ceil = function() {
      return finalise(new this.constructor(this), this.e + 1, 2);
    };
    P2.clampedTo = P2.clamp = function(min2, max2) {
      var k, x = this, Ctor = x.constructor;
      min2 = new Ctor(min2);
      max2 = new Ctor(max2);
      if (!min2.s || !max2.s)
        return new Ctor(NaN);
      if (min2.gt(max2))
        throw Error(invalidArgument + max2);
      k = x.cmp(min2);
      return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
    };
    P2.comparedTo = P2.cmp = function(y) {
      var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
      if (!xd || !yd) {
        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
      }
      if (!xd[0] || !yd[0])
        return xd[0] ? xs : yd[0] ? -ys : 0;
      if (xs !== ys)
        return xs;
      if (x.e !== y.e)
        return x.e > y.e ^ xs < 0 ? 1 : -1;
      xdL = xd.length;
      ydL = yd.length;
      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (xd[i] !== yd[i])
          return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
      }
      return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
    };
    P2.cosine = P2.cos = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.d)
        return new Ctor(NaN);
      if (!x.d[0])
        return new Ctor(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;
      x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
    };
    P2.cubeRoot = P2.cbrt = function() {
      var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero())
        return new Ctor(x);
      external = false;
      s = x.s * mathpow(x.s * x, 1 / 3);
      if (!s || Math.abs(s) == 1 / 0) {
        n = digitsToString(x.d);
        e = x.e;
        if (s = (e - n.length + 1) % 3)
          n += s == 1 || s == -2 ? "0" : "00";
        s = mathpow(n, 1 / 3);
        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new Ctor(n);
        r.s = x.s;
      } else {
        r = new Ctor(s.toString());
      }
      sd = (e = Ctor.precision) + 3;
      for (; ; ) {
        t = r;
        t3 = t.times(t).times(t);
        t3plusx = t3.plus(x);
        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              finalise(t, e + 1, 0);
              if (t.times(t).times(t).eq(x)) {
                r = t;
                break;
              }
            }
            sd += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              finalise(r, e + 1, 1);
              m = !r.times(r).times(r).eq(x);
            }
            break;
          }
        }
      }
      external = true;
      return finalise(r, e, Ctor.rounding, m);
    };
    P2.decimalPlaces = P2.dp = function() {
      var w, d = this.d, n = NaN;
      if (d) {
        w = d.length - 1;
        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
        w = d[w];
        if (w)
          for (; w % 10 == 0; w /= 10)
            n--;
        if (n < 0)
          n = 0;
      }
      return n;
    };
    P2.dividedBy = P2.div = function(y) {
      return divide(this, new this.constructor(y));
    };
    P2.dividedToIntegerBy = P2.divToInt = function(y) {
      var x = this, Ctor = x.constructor;
      return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
    };
    P2.equals = P2.eq = function(y) {
      return this.cmp(y) === 0;
    };
    P2.floor = function() {
      return finalise(new this.constructor(this), this.e + 1, 3);
    };
    P2.greaterThan = P2.gt = function(y) {
      return this.cmp(y) > 0;
    };
    P2.greaterThanOrEqualTo = P2.gte = function(y) {
      var k = this.cmp(y);
      return k == 1 || k === 0;
    };
    P2.hyperbolicCosine = P2.cosh = function() {
      var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
      if (!x.isFinite())
        return new Ctor(x.s ? 1 / 0 : NaN);
      if (x.isZero())
        return one;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;
      if (len < 32) {
        k = Math.ceil(len / 3);
        n = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        n = "2.3283064365386962890625e-10";
      }
      x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
      var cosh2_x, i = k, d8 = new Ctor(8);
      for (; i--; ) {
        cosh2_x = x.times(x);
        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
      }
      return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
    };
    P2.hyperbolicSine = P2.sinh = function() {
      var k, pr, rm, len, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;
      if (len < 3) {
        x = taylorSeries(Ctor, 2, x, x, true);
      } else {
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x, true);
        var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sinh2_x = x.times(x);
          x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
        }
      }
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(x, pr, rm, true);
    };
    P2.hyperbolicTangent = P2.tanh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(x.s);
      if (x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 7;
      Ctor.rounding = 1;
      return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
    };
    P2.inverseCosine = P2.acos = function() {
      var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
      if (k !== -1) {
        return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
      }
      if (x.isZero())
        return getPi(Ctor, pr + 4, rm).times(0.5);
      Ctor.precision = pr + 6;
      Ctor.rounding = 1;
      x = x.asin();
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return halfPi.minus(x);
    };
    P2.inverseHyperbolicCosine = P2.acosh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (x.lte(1))
        return new Ctor(x.eq(1) ? 0 : NaN);
      if (!x.isFinite())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
      Ctor.rounding = 1;
      external = false;
      x = x.times(x).minus(1).sqrt().plus(x);
      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.ln();
    };
    P2.inverseHyperbolicSine = P2.asinh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
      Ctor.rounding = 1;
      external = false;
      x = x.times(x).plus(1).sqrt().plus(x);
      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.ln();
    };
    P2.inverseHyperbolicTangent = P2.atanh = function() {
      var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(NaN);
      if (x.e >= 0)
        return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      xsd = x.sd();
      if (Math.max(xsd, pr) < 2 * -x.e - 1)
        return finalise(new Ctor(x), pr, rm, true);
      Ctor.precision = wpr = xsd - x.e;
      x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
      Ctor.precision = pr + 4;
      Ctor.rounding = 1;
      x = x.ln();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(0.5);
    };
    P2.inverseSine = P2.asin = function() {
      var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
      if (x.isZero())
        return new Ctor(x);
      k = x.abs().cmp(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (k !== -1) {
        if (k === 0) {
          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
          halfPi.s = x.s;
          return halfPi;
        }
        return new Ctor(NaN);
      }
      Ctor.precision = pr + 6;
      Ctor.rounding = 1;
      x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(2);
    };
    P2.inverseTangent = P2.atan = function() {
      var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
      if (!x.isFinite()) {
        if (!x.s)
          return new Ctor(NaN);
        if (pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.5);
          r.s = x.s;
          return r;
        }
      } else if (x.isZero()) {
        return new Ctor(x);
      } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.25);
        r.s = x.s;
        return r;
      }
      Ctor.precision = wpr = pr + 10;
      Ctor.rounding = 1;
      k = Math.min(28, wpr / LOG_BASE + 2 | 0);
      for (i = k; i; --i)
        x = x.div(x.times(x).plus(1).sqrt().plus(1));
      external = false;
      j = Math.ceil(wpr / LOG_BASE);
      n = 1;
      x2 = x.times(x);
      r = new Ctor(x);
      px = x;
      for (; i !== -1; ) {
        px = px.times(x2);
        t = r.minus(px.div(n += 2));
        px = px.times(x2);
        r = t.plus(px.div(n += 2));
        if (r.d[j] !== void 0)
          for (i = j; r.d[i] === t.d[i] && i--; )
            ;
      }
      if (k)
        r = r.times(2 << k - 1);
      external = true;
      return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
    };
    P2.isFinite = function() {
      return !!this.d;
    };
    P2.isInteger = P2.isInt = function() {
      return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
    };
    P2.isNaN = function() {
      return !this.s;
    };
    P2.isNegative = P2.isNeg = function() {
      return this.s < 0;
    };
    P2.isPositive = P2.isPos = function() {
      return this.s > 0;
    };
    P2.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    P2.lessThan = P2.lt = function(y) {
      return this.cmp(y) < 0;
    };
    P2.lessThanOrEqualTo = P2.lte = function(y) {
      return this.cmp(y) < 1;
    };
    P2.logarithm = P2.log = function(base) {
      var isBase10, d, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
      if (base == null) {
        base = new Ctor(10);
        isBase10 = true;
      } else {
        base = new Ctor(base);
        d = base.d;
        if (base.s < 0 || !d || !d[0] || base.eq(1))
          return new Ctor(NaN);
        isBase10 = base.eq(10);
      }
      d = arg2.d;
      if (arg2.s < 0 || !d || !d[0] || arg2.eq(1)) {
        return new Ctor(d && !d[0] ? -1 / 0 : arg2.s != 1 ? NaN : d ? 0 : 1 / 0);
      }
      if (isBase10) {
        if (d.length > 1) {
          inf = true;
        } else {
          for (k = d[0]; k % 10 === 0; )
            k /= 10;
          inf = k !== 1;
        }
      }
      external = false;
      sd = pr + guard;
      num = naturalLogarithm(arg2, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (checkRoundingDigits(r.d, k = pr, rm)) {
        do {
          sd += 10;
          num = naturalLogarithm(arg2, sd);
          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
          r = divide(num, denominator, sd, 1);
          if (!inf) {
            if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
            break;
          }
        } while (checkRoundingDigits(r.d, k += 10, rm));
      }
      external = true;
      return finalise(r, pr, rm);
    };
    P2.minus = P2.sub = function(y) {
      var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.d) {
        if (!x.s || !y.s)
          y = new Ctor(NaN);
        else if (x.d)
          y.s = -y.s;
        else
          y = new Ctor(y.d || x.s !== y.s ? x : NaN);
        return y;
      }
      if (x.s != y.s) {
        y.s = -y.s;
        return x.plus(y);
      }
      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (!xd[0] || !yd[0]) {
        if (yd[0])
          y.s = -y.s;
        else if (xd[0])
          y = new Ctor(x);
        else
          return new Ctor(rm === 3 ? -0 : 0);
        return external ? finalise(y, pr, rm) : y;
      }
      e = mathfloor(y.e / LOG_BASE);
      xe = mathfloor(x.e / LOG_BASE);
      xd = xd.slice();
      k = xe - e;
      if (k) {
        xLTy = k < 0;
        if (xLTy) {
          d = xd;
          k = -k;
          len = yd.length;
        } else {
          d = yd;
          e = xe;
          len = xd.length;
        }
        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
        if (k > i) {
          k = i;
          d.length = 1;
        }
        d.reverse();
        for (i = k; i--; )
          d.push(0);
        d.reverse();
      } else {
        i = xd.length;
        len = yd.length;
        xLTy = i < len;
        if (xLTy)
          len = i;
        for (i = 0; i < len; i++) {
          if (xd[i] != yd[i]) {
            xLTy = xd[i] < yd[i];
            break;
          }
        }
        k = 0;
      }
      if (xLTy) {
        d = xd;
        xd = yd;
        yd = d;
        y.s = -y.s;
      }
      len = xd.length;
      for (i = yd.length - len; i > 0; --i)
        xd[len++] = 0;
      for (i = yd.length; i > k; ) {
        if (xd[--i] < yd[i]) {
          for (j = i; j && xd[--j] === 0; )
            xd[j] = BASE - 1;
          --xd[j];
          xd[i] += BASE;
        }
        xd[i] -= yd[i];
      }
      for (; xd[--len] === 0; )
        xd.pop();
      for (; xd[0] === 0; xd.shift())
        --e;
      if (!xd[0])
        return new Ctor(rm === 3 ? -0 : 0);
      y.d = xd;
      y.e = getBase10Exponent(xd, e);
      return external ? finalise(y, pr, rm) : y;
    };
    P2.modulo = P2.mod = function(y) {
      var q, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.s || y.d && !y.d[0])
        return new Ctor(NaN);
      if (!y.d || x.d && !x.d[0]) {
        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
      }
      external = false;
      if (Ctor.modulo == 9) {
        q = divide(x, y.abs(), 0, 3, 1);
        q.s *= y.s;
      } else {
        q = divide(x, y, 0, Ctor.modulo, 1);
      }
      q = q.times(y);
      external = true;
      return x.minus(q);
    };
    P2.naturalExponential = P2.exp = function() {
      return naturalExponential(this);
    };
    P2.naturalLogarithm = P2.ln = function() {
      return naturalLogarithm(this);
    };
    P2.negated = P2.neg = function() {
      var x = new this.constructor(this);
      x.s = -x.s;
      return finalise(x);
    };
    P2.plus = P2.add = function(y) {
      var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.d) {
        if (!x.s || !y.s)
          y = new Ctor(NaN);
        else if (!x.d)
          y = new Ctor(y.d || x.s === y.s ? x : NaN);
        return y;
      }
      if (x.s != y.s) {
        y.s = -y.s;
        return x.minus(y);
      }
      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (!xd[0] || !yd[0]) {
        if (!yd[0])
          y = new Ctor(x);
        return external ? finalise(y, pr, rm) : y;
      }
      k = mathfloor(x.e / LOG_BASE);
      e = mathfloor(y.e / LOG_BASE);
      xd = xd.slice();
      i = k - e;
      if (i) {
        if (i < 0) {
          d = xd;
          i = -i;
          len = yd.length;
        } else {
          d = yd;
          e = k;
          len = xd.length;
        }
        k = Math.ceil(pr / LOG_BASE);
        len = k > len ? k + 1 : len + 1;
        if (i > len) {
          i = len;
          d.length = 1;
        }
        d.reverse();
        for (; i--; )
          d.push(0);
        d.reverse();
      }
      len = xd.length;
      i = yd.length;
      if (len - i < 0) {
        i = len;
        d = yd;
        yd = xd;
        xd = d;
      }
      for (carry = 0; i; ) {
        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
        xd[i] %= BASE;
      }
      if (carry) {
        xd.unshift(carry);
        ++e;
      }
      for (len = xd.length; xd[--len] == 0; )
        xd.pop();
      y.d = xd;
      y.e = getBase10Exponent(xd, e);
      return external ? finalise(y, pr, rm) : y;
    };
    P2.precision = P2.sd = function(z) {
      var k, x = this;
      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
        throw Error(invalidArgument + z);
      if (x.d) {
        k = getPrecision(x.d);
        if (z && x.e + 1 > k)
          k = x.e + 1;
      } else {
        k = NaN;
      }
      return k;
    };
    P2.round = function() {
      var x = this, Ctor = x.constructor;
      return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
    };
    P2.sine = P2.sin = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(NaN);
      if (x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;
      x = sine(Ctor, toLessThanHalfPi(Ctor, x));
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
    };
    P2.squareRoot = P2.sqrt = function() {
      var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
      if (s !== 1 || !d || !d[0]) {
        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
      }
      external = false;
      s = Math.sqrt(+x);
      if (s == 0 || s == 1 / 0) {
        n = digitsToString(d);
        if ((n.length + e) % 2 == 0)
          n += "0";
        s = Math.sqrt(n);
        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new Ctor(n);
      } else {
        r = new Ctor(s.toString());
      }
      sd = (e = Ctor.precision) + 3;
      for (; ; ) {
        t = r;
        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              finalise(t, e + 1, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            sd += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              finalise(r, e + 1, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
      external = true;
      return finalise(r, e, Ctor.rounding, m);
    };
    P2.tangent = P2.tan = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(NaN);
      if (x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 10;
      Ctor.rounding = 1;
      x = x.sin();
      x.s = 1;
      x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
    };
    P2.times = P2.mul = function(y) {
      var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
      y.s *= x.s;
      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
      }
      e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
      xdL = xd.length;
      ydL = yd.length;
      if (xdL < ydL) {
        r = xd;
        xd = yd;
        yd = r;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
      }
      r = [];
      rL = xdL + ydL;
      for (i = rL; i--; )
        r.push(0);
      for (i = ydL; --i >= 0; ) {
        carry = 0;
        for (k = xdL + i; k > i; ) {
          t = r[k] + yd[i] * xd[k - i - 1] + carry;
          r[k--] = t % BASE | 0;
          carry = t / BASE | 0;
        }
        r[k] = (r[k] + carry) % BASE | 0;
      }
      for (; !r[--rL]; )
        r.pop();
      if (carry)
        ++e;
      else
        r.shift();
      y.d = r;
      y.e = getBase10Exponent(r, e);
      return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
    };
    P2.toBinary = function(sd, rm) {
      return toStringBinary(this, 2, sd, rm);
    };
    P2.toDecimalPlaces = P2.toDP = function(dp, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (dp === void 0)
        return x;
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      return finalise(x, dp + x.e + 1, rm);
    };
    P2.toExponential = function(dp, rm) {
      var str, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = finiteToString(x, true);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        x = finalise(new Ctor(x), dp + 1, rm);
        str = finiteToString(x, true, dp + 1);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P2.toFixed = function(dp, rm) {
      var str, y, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = finiteToString(x);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        y = finalise(new Ctor(x), dp + x.e + 1, rm);
        str = finiteToString(y, false, dp + y.e + 1);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P2.toFraction = function(maxD) {
      var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
      if (!xd)
        return new Ctor(x);
      n1 = d0 = new Ctor(1);
      d1 = n0 = new Ctor(0);
      d = new Ctor(d1);
      e = d.e = getPrecision(xd) - x.e - 1;
      k = e % LOG_BASE;
      d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
      if (maxD == null) {
        maxD = e > 0 ? d : n1;
      } else {
        n = new Ctor(maxD);
        if (!n.isInt() || n.lt(n1))
          throw Error(invalidArgument + n);
        maxD = n.gt(d) ? e > 0 ? d : n1 : n;
      }
      external = false;
      n = new Ctor(digitsToString(xd));
      pr = Ctor.precision;
      Ctor.precision = e = xd.length * LOG_BASE * 2;
      for (; ; ) {
        q = divide(n, d, 0, 1, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.cmp(maxD) == 1)
          break;
        d0 = d1;
        d1 = d2;
        d2 = n1;
        n1 = n0.plus(q.times(d2));
        n0 = d2;
        d2 = d;
        d = n.minus(q.times(d2));
        n = d2;
      }
      d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
      Ctor.precision = pr;
      external = true;
      return r;
    };
    P2.toHexadecimal = P2.toHex = function(sd, rm) {
      return toStringBinary(this, 16, sd, rm);
    };
    P2.toNearest = function(y, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (y == null) {
        if (!x.d)
          return x;
        y = new Ctor(1);
        rm = Ctor.rounding;
      } else {
        y = new Ctor(y);
        if (rm === void 0) {
          rm = Ctor.rounding;
        } else {
          checkInt32(rm, 0, 8);
        }
        if (!x.d)
          return y.s ? x : y;
        if (!y.d) {
          if (y.s)
            y.s = x.s;
          return y;
        }
      }
      if (y.d[0]) {
        external = false;
        x = divide(x, y, 0, rm, 1).times(y);
        external = true;
        finalise(x);
      } else {
        y.s = x.s;
        x = y;
      }
      return x;
    };
    P2.toNumber = function() {
      return +this;
    };
    P2.toOctal = function(sd, rm) {
      return toStringBinary(this, 8, sd, rm);
    };
    P2.toPower = P2.pow = function(y) {
      var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
      if (!x.d || !y.d || !x.d[0] || !y.d[0])
        return new Ctor(mathpow(+x, yn));
      x = new Ctor(x);
      if (x.eq(1))
        return x;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (y.eq(1))
        return finalise(x, pr, rm);
      e = mathfloor(y.e / LOG_BASE);
      if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r = intPow(Ctor, x, k, pr);
        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
      }
      s = x.s;
      if (s < 0) {
        if (e < y.d.length - 1)
          return new Ctor(NaN);
        if ((y.d[e] & 1) == 0)
          s = 1;
        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
          x.s = s;
          return x;
        }
      }
      k = mathpow(+x, yn);
      e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
      if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
        return new Ctor(e > 0 ? s / 0 : 0);
      external = false;
      Ctor.rounding = x.s = 1;
      k = Math.min(12, (e + "").length);
      r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
      if (r.d) {
        r = finalise(r, pr + 5, 1);
        if (checkRoundingDigits(r.d, pr, rm)) {
          e = pr + 10;
          r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
          if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
        }
      }
      r.s = s;
      external = true;
      Ctor.rounding = rm;
      return finalise(r, pr, rm);
    };
    P2.toPrecision = function(sd, rm) {
      var str, x = this, Ctor = x.constructor;
      if (sd === void 0) {
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        x = finalise(new Ctor(x), sd, rm);
        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P2.toSignificantDigits = P2.toSD = function(sd, rm) {
      var x = this, Ctor = x.constructor;
      if (sd === void 0) {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
      }
      return finalise(new Ctor(x), sd, rm);
    };
    P2.toString = function() {
      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P2.truncated = P2.trunc = function() {
      return finalise(new this.constructor(this), this.e + 1, 1);
    };
    P2.valueOf = P2.toJSON = function() {
      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      return x.isNeg() ? "-" + str : str;
    };
    function digitsToString(d) {
      var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
      if (indexOfLastWord > 0) {
        str += w;
        for (i = 1; i < indexOfLastWord; i++) {
          ws = d[i] + "";
          k = LOG_BASE - ws.length;
          if (k)
            str += getZeroString(k);
          str += ws;
        }
        w = d[i];
        ws = w + "";
        k = LOG_BASE - ws.length;
        if (k)
          str += getZeroString(k);
      } else if (w === 0) {
        return "0";
      }
      for (; w % 10 === 0; )
        w /= 10;
      return str + w;
    }
    __name(digitsToString, "digitsToString");
    function checkInt32(i, min2, max2) {
      if (i !== ~~i || i < min2 || i > max2) {
        throw Error(invalidArgument + i);
      }
    }
    __name(checkInt32, "checkInt32");
    function checkRoundingDigits(d, i, rm, repeating) {
      var di, k, r, rd;
      for (k = d[0]; k >= 10; k /= 10)
        --i;
      if (--i < 0) {
        i += LOG_BASE;
        di = 0;
      } else {
        di = Math.ceil((i + 1) / LOG_BASE);
        i %= LOG_BASE;
      }
      k = mathpow(10, LOG_BASE - i);
      rd = d[di] % k | 0;
      if (repeating == null) {
        if (i < 3) {
          if (i == 0)
            rd = rd / 100 | 0;
          else if (i == 1)
            rd = rd / 10 | 0;
          r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
        } else {
          r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
        }
      } else {
        if (i < 4) {
          if (i == 0)
            rd = rd / 1e3 | 0;
          else if (i == 1)
            rd = rd / 100 | 0;
          else if (i == 2)
            rd = rd / 10 | 0;
          r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
        } else {
          r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
        }
      }
      return r;
    }
    __name(checkRoundingDigits, "checkRoundingDigits");
    function convertBase(str, baseIn, baseOut) {
      var j, arr = [0], arrL, i = 0, strL = str.length;
      for (; i < strL; ) {
        for (arrL = arr.length; arrL--; )
          arr[arrL] *= baseIn;
        arr[0] += NUMERALS.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] === void 0)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    __name(convertBase, "convertBase");
    function cosine(Ctor, x) {
      var k, len, y;
      if (x.isZero())
        return x;
      len = x.d.length;
      if (len < 32) {
        k = Math.ceil(len / 3);
        y = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        y = "2.3283064365386962890625e-10";
      }
      Ctor.precision += k;
      x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
      for (var i = k; i--; ) {
        var cos2x = x.times(x);
        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
      }
      Ctor.precision -= k;
      return x;
    }
    __name(cosine, "cosine");
    var divide = function() {
      function multiplyInteger(x, k, base) {
        var temp, carry = 0, i = x.length;
        for (x = x.slice(); i--; ) {
          temp = x[i] * k + carry;
          x[i] = temp % base | 0;
          carry = temp / base | 0;
        }
        if (carry)
          x.unshift(carry);
        return x;
      }
      __name(multiplyInteger, "multiplyInteger");
      function compare(a, b, aL, bL) {
        var i, r;
        if (aL != bL) {
          r = aL > bL ? 1 : -1;
        } else {
          for (i = r = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              r = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return r;
      }
      __name(compare, "compare");
      function subtract(a, b, aL, base) {
        var i = 0;
        for (; aL--; ) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }
        for (; !a[0] && a.length > 1; )
          a.shift();
      }
      __name(subtract, "subtract");
      return function(x, y, pr, rm, dp, base) {
        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(
            !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
          );
        }
        if (base) {
          logBase = 1;
          e = x.e - y.e;
        } else {
          base = BASE;
          logBase = LOG_BASE;
          e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
        }
        yL = yd.length;
        xL = xd.length;
        q = new Ctor(sign2);
        qd = q.d = [];
        for (i = 0; yd[i] == (xd[i] || 0); i++)
          ;
        if (yd[i] > (xd[i] || 0))
          e--;
        if (pr == null) {
          sd = pr = Ctor.precision;
          rm = Ctor.rounding;
        } else if (dp) {
          sd = pr + (x.e - y.e) + 1;
        } else {
          sd = pr;
        }
        if (sd < 0) {
          qd.push(1);
          more = true;
        } else {
          sd = sd / logBase + 2 | 0;
          i = 0;
          if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;
            for (; (i < xL || k) && sd--; i++) {
              t = k * base + (xd[i] || 0);
              qd[i] = t / yd | 0;
              k = t % yd | 0;
            }
            more = k || i < xL;
          } else {
            k = base / (yd[0] + 1) | 0;
            if (k > 1) {
              yd = multiplyInteger(yd, k, base);
              xd = multiplyInteger(xd, k, base);
              yL = yd.length;
              xL = xd.length;
            }
            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; )
              rem[remL++] = 0;
            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];
            if (yd[1] >= base / 2)
              ++yd0;
            do {
              k = 0;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                k = rem0 / yd0 | 0;
                if (k > 1) {
                  if (k >= base)
                    k = base - 1;
                  prod = multiplyInteger(yd, k, base);
                  prodL = prod.length;
                  remL = rem.length;
                  cmp = compare(prod, rem, prodL, remL);
                  if (cmp == 1) {
                    k--;
                    subtract(prod, yL < prodL ? yz : yd, prodL, base);
                  }
                } else {
                  if (k == 0)
                    cmp = k = 1;
                  prod = yd.slice();
                }
                prodL = prod.length;
                if (prodL < remL)
                  prod.unshift(0);
                subtract(rem, prod, remL, base);
                if (cmp == -1) {
                  remL = rem.length;
                  cmp = compare(yd, rem, yL, remL);
                  if (cmp < 1) {
                    k++;
                    subtract(rem, yL < remL ? yz : yd, remL, base);
                  }
                }
                remL = rem.length;
              } else if (cmp === 0) {
                k++;
                rem = [0];
              }
              qd[i++] = k;
              if (cmp && rem[0]) {
                rem[remL++] = xd[xi] || 0;
              } else {
                rem = [xd[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] !== void 0) && sd--);
            more = rem[0] !== void 0;
          }
          if (!qd[0])
            qd.shift();
        }
        if (logBase == 1) {
          q.e = e;
          inexact = more;
        } else {
          for (i = 1, k = qd[0]; k >= 10; k /= 10)
            i++;
          q.e = i + e * logBase - 1;
          finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
        }
        return q;
      };
    }();
    function finalise(x, sd, rm, isTruncated) {
      var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
      out:
        if (sd != null) {
          xd = x.d;
          if (!xd)
            return x;
          for (digits = 1, k = xd[0]; k >= 10; k /= 10)
            digits++;
          i = sd - digits;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            w = xd[xdi = 0];
            rd = w / mathpow(10, digits - j - 1) % 10 | 0;
          } else {
            xdi = Math.ceil((i + 1) / LOG_BASE);
            k = xd.length;
            if (xdi >= k) {
              if (isTruncated) {
                for (; k++ <= xdi; )
                  xd.push(0);
                w = rd = 0;
                digits = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              w = k = xd[xdi];
              for (digits = 1; k >= 10; k /= 10)
                digits++;
              i %= LOG_BASE;
              j = i - LOG_BASE + digits;
              rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
            }
          }
          isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
          roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xd[0]) {
            xd.length = 0;
            if (roundUp) {
              sd -= x.e + 1;
              xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
              x.e = -sd || 0;
            } else {
              xd[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xd.length = xdi;
            k = 1;
            xdi--;
          } else {
            xd.length = xdi + 1;
            k = mathpow(10, LOG_BASE - i);
            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
          }
          if (roundUp) {
            for (; ; ) {
              if (xdi == 0) {
                for (i = 1, j = xd[0]; j >= 10; j /= 10)
                  i++;
                j = xd[0] += k;
                for (k = 1; j >= 10; j /= 10)
                  k++;
                if (i != k) {
                  x.e++;
                  if (xd[0] == BASE)
                    xd[0] = 1;
                }
                break;
              } else {
                xd[xdi] += k;
                if (xd[xdi] != BASE)
                  break;
                xd[xdi--] = 0;
                k = 1;
              }
            }
          }
          for (i = xd.length; xd[--i] === 0; )
            xd.pop();
        }
      if (external) {
        if (x.e > Ctor.maxE) {
          x.d = null;
          x.e = NaN;
        } else if (x.e < Ctor.minE) {
          x.e = 0;
          x.d = [0];
        }
      }
      return x;
    }
    __name(finalise, "finalise");
    function finiteToString(x, isExp, sd) {
      if (!x.isFinite())
        return nonFiniteToString(x);
      var k, e = x.e, str = digitsToString(x.d), len = str.length;
      if (isExp) {
        if (sd && (k = sd - len) > 0) {
          str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
        } else if (len > 1) {
          str = str.charAt(0) + "." + str.slice(1);
        }
        str = str + (x.e < 0 ? "e" : "e+") + x.e;
      } else if (e < 0) {
        str = "0." + getZeroString(-e - 1) + str;
        if (sd && (k = sd - len) > 0)
          str += getZeroString(k);
      } else if (e >= len) {
        str += getZeroString(e + 1 - len);
        if (sd && (k = sd - e - 1) > 0)
          str = str + "." + getZeroString(k);
      } else {
        if ((k = e + 1) < len)
          str = str.slice(0, k) + "." + str.slice(k);
        if (sd && (k = sd - len) > 0) {
          if (e + 1 === len)
            str += ".";
          str += getZeroString(k);
        }
      }
      return str;
    }
    __name(finiteToString, "finiteToString");
    function getBase10Exponent(digits, e) {
      var w = digits[0];
      for (e *= LOG_BASE; w >= 10; w /= 10)
        e++;
      return e;
    }
    __name(getBase10Exponent, "getBase10Exponent");
    function getLn10(Ctor, sd, pr) {
      if (sd > LN10_PRECISION) {
        external = true;
        if (pr)
          Ctor.precision = pr;
        throw Error(precisionLimitExceeded);
      }
      return finalise(new Ctor(LN10), sd, 1, true);
    }
    __name(getLn10, "getLn10");
    function getPi(Ctor, sd, rm) {
      if (sd > PI_PRECISION)
        throw Error(precisionLimitExceeded);
      return finalise(new Ctor(PI), sd, rm, true);
    }
    __name(getPi, "getPi");
    function getPrecision(digits) {
      var w = digits.length - 1, len = w * LOG_BASE + 1;
      w = digits[w];
      if (w) {
        for (; w % 10 == 0; w /= 10)
          len--;
        for (w = digits[0]; w >= 10; w /= 10)
          len++;
      }
      return len;
    }
    __name(getPrecision, "getPrecision");
    function getZeroString(k) {
      var zs = "";
      for (; k--; )
        zs += "0";
      return zs;
    }
    __name(getZeroString, "getZeroString");
    function intPow(Ctor, x, n, pr) {
      var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
      external = false;
      for (; ; ) {
        if (n % 2) {
          r = r.times(x);
          if (truncate(r.d, k))
            isTruncated = true;
        }
        n = mathfloor(n / 2);
        if (n === 0) {
          n = r.d.length - 1;
          if (isTruncated && r.d[n] === 0)
            ++r.d[n];
          break;
        }
        x = x.times(x);
        truncate(x.d, k);
      }
      external = true;
      return r;
    }
    __name(intPow, "intPow");
    function isOdd(n) {
      return n.d[n.d.length - 1] & 1;
    }
    __name(isOdd, "isOdd");
    function maxOrMin(Ctor, args, ltgt) {
      var y, x = new Ctor(args[0]), i = 0;
      for (; ++i < args.length; ) {
        y = new Ctor(args[i]);
        if (!y.s) {
          x = y;
          break;
        } else if (x[ltgt](y)) {
          x = y;
        }
      }
      return x;
    }
    __name(maxOrMin, "maxOrMin");
    function naturalExponential(x, sd) {
      var denominator, guard, j, pow2, sum3, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
      if (!x.d || !x.d[0] || x.e > 17) {
        return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
      }
      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }
      t = new Ctor(0.03125);
      while (x.e > -2) {
        x = x.times(t);
        k += 5;
      }
      guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
      wpr += guard;
      denominator = pow2 = sum3 = new Ctor(1);
      Ctor.precision = wpr;
      for (; ; ) {
        pow2 = finalise(pow2.times(x), wpr, 1);
        denominator = denominator.times(++i);
        t = sum3.plus(divide(pow2, denominator, wpr, 1));
        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
          j = k;
          while (j--)
            sum3 = finalise(sum3.times(sum3), wpr, 1);
          if (sd == null) {
            if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += 10;
              denominator = pow2 = t = new Ctor(1);
              i = 0;
              rep++;
            } else {
              return finalise(sum3, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum3;
          }
        }
        sum3 = t;
      }
    }
    __name(naturalExponential, "naturalExponential");
    function naturalLogarithm(y, sd) {
      var c, c0, denominator, e, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
      if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
      }
      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }
      Ctor.precision = wpr += guard;
      c = digitsToString(xd);
      c0 = c.charAt(0);
      if (Math.abs(e = x.e) < 15e14) {
        while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
          x = x.times(y);
          c = digitsToString(x.d);
          c0 = c.charAt(0);
          n++;
        }
        e = x.e;
        if (c0 > 1) {
          x = new Ctor("0." + c);
          e++;
        } else {
          x = new Ctor(c0 + "." + c.slice(1));
        }
      } else {
        t = getLn10(Ctor, wpr + 2, pr).times(e + "");
        x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
        Ctor.precision = pr;
        return sd == null ? finalise(x, pr, rm, external = true) : x;
      }
      x1 = x;
      sum3 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
      x2 = finalise(x.times(x), wpr, 1);
      denominator = 3;
      for (; ; ) {
        numerator = finalise(numerator.times(x2), wpr, 1);
        t = sum3.plus(divide(numerator, new Ctor(denominator), wpr, 1));
        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
          sum3 = sum3.times(2);
          if (e !== 0)
            sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
          sum3 = divide(sum3, new Ctor(n), wpr, 1);
          if (sd == null) {
            if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += guard;
              t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
              x2 = finalise(x.times(x), wpr, 1);
              denominator = rep = 1;
            } else {
              return finalise(sum3, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum3;
          }
        }
        sum3 = t;
        denominator += 2;
      }
    }
    __name(naturalLogarithm, "naturalLogarithm");
    function nonFiniteToString(x) {
      return String(x.s * x.s / 0);
    }
    __name(nonFiniteToString, "nonFiniteToString");
    function parseDecimal(x, str) {
      var e, i, len;
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
      for (i = 0; str.charCodeAt(i) === 48; i++)
        ;
      for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
        ;
      str = str.slice(i, len);
      if (str) {
        len -= i;
        x.e = e = e - i - 1;
        x.d = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.d.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; )
            x.d.push(+str.slice(i, i += LOG_BASE));
          str = str.slice(i);
          i = LOG_BASE - str.length;
        } else {
          i -= len;
        }
        for (; i--; )
          str += "0";
        x.d.push(+str);
        if (external) {
          if (x.e > x.constructor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < x.constructor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
      } else {
        x.e = 0;
        x.d = [0];
      }
      return x;
    }
    __name(parseDecimal, "parseDecimal");
    function parseOther(x, str) {
      var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
      if (str.indexOf("_") > -1) {
        str = str.replace(/(\d)_(?=\d)/g, "$1");
        if (isDecimal.test(str))
          return parseDecimal(x, str);
      } else if (str === "Infinity" || str === "NaN") {
        if (!+str)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return x;
      }
      if (isHex.test(str)) {
        base = 16;
        str = str.toLowerCase();
      } else if (isBinary.test(str)) {
        base = 2;
      } else if (isOctal.test(str)) {
        base = 8;
      } else {
        throw Error(invalidArgument + str);
      }
      i = str.search(/p/i);
      if (i > 0) {
        p = +str.slice(i + 1);
        str = str.substring(2, i);
      } else {
        str = str.slice(2);
      }
      i = str.indexOf(".");
      isFloat = i >= 0;
      Ctor = x.constructor;
      if (isFloat) {
        str = str.replace(".", "");
        len = str.length;
        i = len - i;
        divisor = intPow(Ctor, new Ctor(base), i, i * 2);
      }
      xd = convertBase(str, base, BASE);
      xe = xd.length - 1;
      for (i = xe; xd[i] === 0; --i)
        xd.pop();
      if (i < 0)
        return new Ctor(x.s * 0);
      x.e = getBase10Exponent(xd, xe);
      x.d = xd;
      external = false;
      if (isFloat)
        x = divide(x, divisor, len * 4);
      if (p)
        x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
      external = true;
      return x;
    }
    __name(parseOther, "parseOther");
    function sine(Ctor, x) {
      var k, len = x.d.length;
      if (len < 3) {
        return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
      }
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;
      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x);
      var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
      for (; k--; ) {
        sin2_x = x.times(x);
        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
      }
      return x;
    }
    __name(sine, "sine");
    function taylorSeries(Ctor, n, x, y, isHyperbolic) {
      var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
      external = false;
      x2 = x.times(x);
      u = new Ctor(y);
      for (; ; ) {
        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
        u = isHyperbolic ? y.plus(t) : y.minus(t);
        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
        t = u.plus(y);
        if (t.d[k] !== void 0) {
          for (j = k; t.d[j] === u.d[j] && j--; )
            ;
          if (j == -1)
            break;
        }
        j = u;
        u = y;
        y = t;
        t = j;
        i++;
      }
      external = true;
      t.d.length = k + 1;
      return t;
    }
    __name(taylorSeries, "taylorSeries");
    function tinyPow(b, e) {
      var n = b;
      while (--e)
        n *= b;
      return n;
    }
    __name(tinyPow, "tinyPow");
    function toLessThanHalfPi(Ctor, x) {
      var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
      x = x.abs();
      if (x.lte(halfPi)) {
        quadrant = isNeg ? 4 : 1;
        return x;
      }
      t = x.divToInt(pi);
      if (t.isZero()) {
        quadrant = isNeg ? 3 : 2;
      } else {
        x = x.minus(t.times(pi));
        if (x.lte(halfPi)) {
          quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
          return x;
        }
        quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
      }
      return x.minus(pi).abs();
    }
    __name(toLessThanHalfPi, "toLessThanHalfPi");
    function toStringBinary(x, baseOut, sd, rm) {
      var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
      if (isExp) {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
      } else {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      }
      if (!x.isFinite()) {
        str = nonFiniteToString(x);
      } else {
        str = finiteToString(x);
        i = str.indexOf(".");
        if (isExp) {
          base = 2;
          if (baseOut == 16) {
            sd = sd * 4 - 3;
          } else if (baseOut == 8) {
            sd = sd * 3 - 2;
          }
        } else {
          base = baseOut;
        }
        if (i >= 0) {
          str = str.replace(".", "");
          y = new Ctor(1);
          y.e = str.length - i;
          y.d = convertBase(finiteToString(y), 10, base);
          y.e = y.d.length;
        }
        xd = convertBase(str, 10, base);
        e = len = xd.length;
        for (; xd[--len] == 0; )
          xd.pop();
        if (!xd[0]) {
          str = isExp ? "0p+0" : "0";
        } else {
          if (i < 0) {
            e--;
          } else {
            x = new Ctor(x);
            x.d = xd;
            x.e = e;
            x = divide(x, y, sd, rm, 0, base);
            xd = x.d;
            e = x.e;
            roundUp = inexact;
          }
          i = xd[sd];
          k = base / 2;
          roundUp = roundUp || xd[sd + 1] !== void 0;
          roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
          xd.length = sd;
          if (roundUp) {
            for (; ++xd[--sd] > base - 1; ) {
              xd[sd] = 0;
              if (!sd) {
                ++e;
                xd.unshift(1);
              }
            }
          }
          for (len = xd.length; !xd[len - 1]; --len)
            ;
          for (i = 0, str = ""; i < len; i++)
            str += NUMERALS.charAt(xd[i]);
          if (isExp) {
            if (len > 1) {
              if (baseOut == 16 || baseOut == 8) {
                i = baseOut == 16 ? 4 : 3;
                for (--len; len % i; len++)
                  str += "0";
                xd = convertBase(str, base, baseOut);
                for (len = xd.length; !xd[len - 1]; --len)
                  ;
                for (i = 1, str = "1."; i < len; i++)
                  str += NUMERALS.charAt(xd[i]);
              } else {
                str = str.charAt(0) + "." + str.slice(1);
              }
            }
            str = str + (e < 0 ? "p" : "p+") + e;
          } else if (e < 0) {
            for (; ++e; )
              str = "0" + str;
            str = "0." + str;
          } else {
            if (++e > len)
              for (e -= len; e--; )
                str += "0";
            else if (e < len)
              str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
      }
      return x.s < 0 ? "-" + str : str;
    }
    __name(toStringBinary, "toStringBinary");
    function truncate(arr, len) {
      if (arr.length > len) {
        arr.length = len;
        return true;
      }
    }
    __name(truncate, "truncate");
    function abs(x) {
      return new this(x).abs();
    }
    __name(abs, "abs");
    function acos(x) {
      return new this(x).acos();
    }
    __name(acos, "acos");
    function acosh(x) {
      return new this(x).acosh();
    }
    __name(acosh, "acosh");
    function add(x, y) {
      return new this(x).plus(y);
    }
    __name(add, "add");
    function asin(x) {
      return new this(x).asin();
    }
    __name(asin, "asin");
    function asinh(x) {
      return new this(x).asinh();
    }
    __name(asinh, "asinh");
    function atan(x) {
      return new this(x).atan();
    }
    __name(atan, "atan");
    function atanh(x) {
      return new this(x).atanh();
    }
    __name(atanh, "atanh");
    function atan2(y, x) {
      y = new this(y);
      x = new this(x);
      var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
      if (!y.s || !x.s) {
        r = new this(NaN);
      } else if (!y.d && !x.d) {
        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
        r.s = y.s;
      } else if (!x.d || y.isZero()) {
        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
        r.s = y.s;
      } else if (!y.d || x.isZero()) {
        r = getPi(this, wpr, 1).times(0.5);
        r.s = y.s;
      } else if (x.s < 0) {
        this.precision = wpr;
        this.rounding = 1;
        r = this.atan(divide(y, x, wpr, 1));
        x = getPi(this, wpr, 1);
        this.precision = pr;
        this.rounding = rm;
        r = y.s < 0 ? r.minus(x) : r.plus(x);
      } else {
        r = this.atan(divide(y, x, wpr, 1));
      }
      return r;
    }
    __name(atan2, "atan2");
    function cbrt(x) {
      return new this(x).cbrt();
    }
    __name(cbrt, "cbrt");
    function ceil(x) {
      return finalise(x = new this(x), x.e + 1, 2);
    }
    __name(ceil, "ceil");
    function clamp(x, min2, max2) {
      return new this(x).clamp(min2, max2);
    }
    __name(clamp, "clamp");
    function config(obj) {
      if (!obj || typeof obj !== "object")
        throw Error(decimalError + "Object expected");
      var i, p, v, useDefaults = obj.defaults === true, ps = [
        "precision",
        1,
        MAX_DIGITS,
        "rounding",
        0,
        8,
        "toExpNeg",
        -EXP_LIMIT,
        0,
        "toExpPos",
        0,
        EXP_LIMIT,
        "maxE",
        0,
        EXP_LIMIT,
        "minE",
        -EXP_LIMIT,
        0,
        "modulo",
        0,
        9
      ];
      for (i = 0; i < ps.length; i += 3) {
        if (p = ps[i], useDefaults)
          this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
            this[p] = v;
          else
            throw Error(invalidArgument + p + ": " + v);
        }
      }
      if (p = "crypto", useDefaults)
        this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (v === true || v === false || v === 0 || v === 1) {
          if (v) {
            if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
              this[p] = true;
            } else {
              throw Error(cryptoUnavailable);
            }
          } else {
            this[p] = false;
          }
        } else {
          throw Error(invalidArgument + p + ": " + v);
        }
      }
      return this;
    }
    __name(config, "config");
    function cos(x) {
      return new this(x).cos();
    }
    __name(cos, "cos");
    function cosh(x) {
      return new this(x).cosh();
    }
    __name(cosh, "cosh");
    function clone(obj) {
      var i, p, ps;
      function Decimal2(v) {
        var e, i2, t, x = this;
        if (!(x instanceof Decimal2))
          return new Decimal2(v);
        x.constructor = Decimal2;
        if (isDecimalInstance(v)) {
          x.s = v.s;
          if (external) {
            if (!v.d || v.e > Decimal2.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (v.e < Decimal2.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = v.e;
              x.d = v.d.slice();
            }
          } else {
            x.e = v.e;
            x.d = v.d ? v.d.slice() : v.d;
          }
          return;
        }
        t = typeof v;
        if (t === "number") {
          if (v === 0) {
            x.s = 1 / v < 0 ? -1 : 1;
            x.e = 0;
            x.d = [0];
            return;
          }
          if (v < 0) {
            v = -v;
            x.s = -1;
          } else {
            x.s = 1;
          }
          if (v === ~~v && v < 1e7) {
            for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
              e++;
            if (external) {
              if (e > Decimal2.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (e < Decimal2.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = e;
                x.d = [v];
              }
            } else {
              x.e = e;
              x.d = [v];
            }
            return;
          } else if (v * 0 !== 0) {
            if (!v)
              x.s = NaN;
            x.e = NaN;
            x.d = null;
            return;
          }
          return parseDecimal(x, v.toString());
        } else if (t !== "string") {
          throw Error(invalidArgument + v);
        }
        if ((i2 = v.charCodeAt(0)) === 45) {
          v = v.slice(1);
          x.s = -1;
        } else {
          if (i2 === 43)
            v = v.slice(1);
          x.s = 1;
        }
        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
      }
      __name(Decimal2, "Decimal");
      Decimal2.prototype = P2;
      Decimal2.ROUND_UP = 0;
      Decimal2.ROUND_DOWN = 1;
      Decimal2.ROUND_CEIL = 2;
      Decimal2.ROUND_FLOOR = 3;
      Decimal2.ROUND_HALF_UP = 4;
      Decimal2.ROUND_HALF_DOWN = 5;
      Decimal2.ROUND_HALF_EVEN = 6;
      Decimal2.ROUND_HALF_CEIL = 7;
      Decimal2.ROUND_HALF_FLOOR = 8;
      Decimal2.EUCLID = 9;
      Decimal2.config = Decimal2.set = config;
      Decimal2.clone = clone;
      Decimal2.isDecimal = isDecimalInstance;
      Decimal2.abs = abs;
      Decimal2.acos = acos;
      Decimal2.acosh = acosh;
      Decimal2.add = add;
      Decimal2.asin = asin;
      Decimal2.asinh = asinh;
      Decimal2.atan = atan;
      Decimal2.atanh = atanh;
      Decimal2.atan2 = atan2;
      Decimal2.cbrt = cbrt;
      Decimal2.ceil = ceil;
      Decimal2.clamp = clamp;
      Decimal2.cos = cos;
      Decimal2.cosh = cosh;
      Decimal2.div = div;
      Decimal2.exp = exp;
      Decimal2.floor = floor;
      Decimal2.hypot = hypot;
      Decimal2.ln = ln;
      Decimal2.log = log2;
      Decimal2.log10 = log10;
      Decimal2.log2 = log22;
      Decimal2.max = max;
      Decimal2.min = min;
      Decimal2.mod = mod;
      Decimal2.mul = mul;
      Decimal2.pow = pow;
      Decimal2.random = random;
      Decimal2.round = round;
      Decimal2.sign = sign;
      Decimal2.sin = sin;
      Decimal2.sinh = sinh;
      Decimal2.sqrt = sqrt;
      Decimal2.sub = sub;
      Decimal2.sum = sum;
      Decimal2.tan = tan;
      Decimal2.tanh = tanh;
      Decimal2.trunc = trunc;
      if (obj === void 0)
        obj = {};
      if (obj) {
        if (obj.defaults !== true) {
          ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
          for (i = 0; i < ps.length; )
            if (!obj.hasOwnProperty(p = ps[i++]))
              obj[p] = this[p];
        }
      }
      Decimal2.config(obj);
      return Decimal2;
    }
    __name(clone, "clone");
    function div(x, y) {
      return new this(x).div(y);
    }
    __name(div, "div");
    function exp(x) {
      return new this(x).exp();
    }
    __name(exp, "exp");
    function floor(x) {
      return finalise(x = new this(x), x.e + 1, 3);
    }
    __name(floor, "floor");
    function hypot() {
      var i, n, t = new this(0);
      external = false;
      for (i = 0; i < arguments.length; ) {
        n = new this(arguments[i++]);
        if (!n.d) {
          if (n.s) {
            external = true;
            return new this(1 / 0);
          }
          t = n;
        } else if (t.d) {
          t = t.plus(n.times(n));
        }
      }
      external = true;
      return t.sqrt();
    }
    __name(hypot, "hypot");
    function isDecimalInstance(obj) {
      return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
    }
    __name(isDecimalInstance, "isDecimalInstance");
    function ln(x) {
      return new this(x).ln();
    }
    __name(ln, "ln");
    function log2(x, y) {
      return new this(x).log(y);
    }
    __name(log2, "log");
    function log22(x) {
      return new this(x).log(2);
    }
    __name(log22, "log2");
    function log10(x) {
      return new this(x).log(10);
    }
    __name(log10, "log10");
    function max() {
      return maxOrMin(this, arguments, "lt");
    }
    __name(max, "max");
    function min() {
      return maxOrMin(this, arguments, "gt");
    }
    __name(min, "min");
    function mod(x, y) {
      return new this(x).mod(y);
    }
    __name(mod, "mod");
    function mul(x, y) {
      return new this(x).mul(y);
    }
    __name(mul, "mul");
    function pow(x, y) {
      return new this(x).pow(y);
    }
    __name(pow, "pow");
    function random(sd) {
      var d, e, k, n, i = 0, r = new this(1), rd = [];
      if (sd === void 0)
        sd = this.precision;
      else
        checkInt32(sd, 1, MAX_DIGITS);
      k = Math.ceil(sd / LOG_BASE);
      if (!this.crypto) {
        for (; i < k; )
          rd[i++] = Math.random() * 1e7 | 0;
      } else if (crypto.getRandomValues) {
        d = crypto.getRandomValues(new Uint32Array(k));
        for (; i < k; ) {
          n = d[i];
          if (n >= 429e7) {
            d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
          } else {
            rd[i++] = n % 1e7;
          }
        }
      } else if (crypto.randomBytes) {
        d = crypto.randomBytes(k *= 4);
        for (; i < k; ) {
          n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
          if (n >= 214e7) {
            crypto.randomBytes(4).copy(d, i);
          } else {
            rd.push(n % 1e7);
            i += 4;
          }
        }
        i = k / 4;
      } else {
        throw Error(cryptoUnavailable);
      }
      k = rd[--i];
      sd %= LOG_BASE;
      if (k && sd) {
        n = mathpow(10, LOG_BASE - sd);
        rd[i] = (k / n | 0) * n;
      }
      for (; rd[i] === 0; i--)
        rd.pop();
      if (i < 0) {
        e = 0;
        rd = [0];
      } else {
        e = -1;
        for (; rd[0] === 0; e -= LOG_BASE)
          rd.shift();
        for (k = 1, n = rd[0]; n >= 10; n /= 10)
          k++;
        if (k < LOG_BASE)
          e -= LOG_BASE - k;
      }
      r.e = e;
      r.d = rd;
      return r;
    }
    __name(random, "random");
    function round(x) {
      return finalise(x = new this(x), x.e + 1, this.rounding);
    }
    __name(round, "round");
    function sign(x) {
      x = new this(x);
      return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
    }
    __name(sign, "sign");
    function sin(x) {
      return new this(x).sin();
    }
    __name(sin, "sin");
    function sinh(x) {
      return new this(x).sinh();
    }
    __name(sinh, "sinh");
    function sqrt(x) {
      return new this(x).sqrt();
    }
    __name(sqrt, "sqrt");
    function sub(x, y) {
      return new this(x).sub(y);
    }
    __name(sub, "sub");
    function sum() {
      var i = 0, args = arguments, x = new this(args[i]);
      external = false;
      for (; x.s && ++i < args.length; )
        x = x.plus(args[i]);
      external = true;
      return finalise(x, this.precision, this.rounding);
    }
    __name(sum, "sum");
    function tan(x) {
      return new this(x).tan();
    }
    __name(tan, "tan");
    function tanh(x) {
      return new this(x).tanh();
    }
    __name(tanh, "tanh");
    function trunc(x) {
      return finalise(x = new this(x), x.e + 1, 1);
    }
    __name(trunc, "trunc");
    P2[Symbol.for("nodejs.util.inspect.custom")] = P2.toString;
    P2[Symbol.toStringTag] = "Decimal";
    var Decimal = P2.constructor = clone(DEFAULTS);
    LN10 = new Decimal(LN10);
    PI = new Decimal(PI);
    var decimal_default = Decimal;
    var import_indent_string2 = __toESM(require_indent_string());
    var import_js_levenshtein = __toESM(require_js_levenshtein());
    var FieldRefImpl = class {
      constructor(modelName, name, fieldType, isList) {
        this.modelName = modelName;
        this.name = name;
        this.typeName = fieldType;
        this.isList = isList;
      }
      _toGraphQLInputType() {
        const prefix = this.isList ? `List${this.typeName}` : this.typeName;
        return `${prefix}FieldRefInput<${this.modelName}>`;
      }
    };
    __name(FieldRefImpl, "FieldRefImpl");
    var objectEnumNames = ["JsonNullValueInput", "NullableJsonNullValueInput", "JsonNullValueFilter"];
    var secret = Symbol();
    var representations = /* @__PURE__ */ new WeakMap();
    var ObjectEnumValue = class {
      constructor(arg2) {
        if (arg2 === secret) {
          representations.set(this, `Prisma.${this._getName()}`);
        } else {
          representations.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
        }
      }
      _getName() {
        return this.constructor.name;
      }
      toString() {
        return representations.get(this);
      }
    };
    __name(ObjectEnumValue, "ObjectEnumValue");
    var NullTypesEnumValue = class extends ObjectEnumValue {
      _getNamespace() {
        return "NullTypes";
      }
    };
    __name(NullTypesEnumValue, "NullTypesEnumValue");
    var DbNull = class extends NullTypesEnumValue {
    };
    __name(DbNull, "DbNull");
    var JsonNull = class extends NullTypesEnumValue {
    };
    __name(JsonNull, "JsonNull");
    var AnyNull = class extends NullTypesEnumValue {
    };
    __name(AnyNull, "AnyNull");
    var objectEnumValues = {
      classes: {
        DbNull,
        JsonNull,
        AnyNull
      },
      instances: {
        DbNull: new DbNull(secret),
        JsonNull: new JsonNull(secret),
        AnyNull: new AnyNull(secret)
      }
    };
    function isDecimalJsLike(value) {
      if (Decimal.isDecimal(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.s === "number" && typeof value.e === "number" && Array.isArray(value.d);
    }
    __name(isDecimalJsLike, "isDecimalJsLike");
    function stringifyDecimalJsLike(value) {
      if (Decimal.isDecimal(value)) {
        return JSON.stringify(String(value));
      }
      const tmpDecimal = new Decimal(0);
      tmpDecimal.d = value.d;
      tmpDecimal.e = value.e;
      tmpDecimal.s = value.s;
      return JSON.stringify(String(tmpDecimal));
    }
    __name(stringifyDecimalJsLike, "stringifyDecimalJsLike");
    var keyBy2 = /* @__PURE__ */ __name((collection, prop) => {
      const acc = {};
      for (const obj of collection) {
        const key = obj[prop];
        acc[key] = obj;
      }
      return acc;
    }, "keyBy");
    var ScalarTypeTable = {
      String: true,
      Int: true,
      Float: true,
      Boolean: true,
      Long: true,
      DateTime: true,
      ID: true,
      UUID: true,
      Json: true,
      Bytes: true,
      Decimal: true,
      BigInt: true
    };
    var JSTypeToGraphQLType = {
      string: "String",
      boolean: "Boolean",
      object: "Json",
      symbol: "Symbol"
    };
    function stringifyGraphQLType(type) {
      if (typeof type === "string") {
        return type;
      }
      return type.name;
    }
    __name(stringifyGraphQLType, "stringifyGraphQLType");
    function wrapWithList(str, isList) {
      if (isList) {
        return `List<${str}>`;
      }
      return str;
    }
    __name(wrapWithList, "wrapWithList");
    var RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
    var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    function getGraphQLType(value, inputType) {
      const potentialType = inputType == null ? void 0 : inputType.type;
      if (value === null) {
        return "null";
      }
      if (Object.prototype.toString.call(value) === "[object BigInt]") {
        return "BigInt";
      }
      if (decimal_default.isDecimal(value)) {
        return "Decimal";
      }
      if (potentialType === "Decimal" && isDecimalJsLike(value)) {
        return "Decimal";
      }
      if (Buffer.isBuffer(value)) {
        return "Bytes";
      }
      if (isValidEnumValue(value, inputType)) {
        return potentialType.name;
      }
      if (value instanceof ObjectEnumValue) {
        return value._getName();
      }
      if (value instanceof FieldRefImpl) {
        return value._toGraphQLInputType();
      }
      if (Array.isArray(value)) {
        let scalarTypes = value.reduce((acc, val) => {
          const type = getGraphQLType(val, inputType);
          if (!acc.includes(type)) {
            acc.push(type);
          }
          return acc;
        }, []);
        if (scalarTypes.includes("Float") && scalarTypes.includes("Int")) {
          scalarTypes = ["Float"];
        }
        return `List<${scalarTypes.join(" | ")}>`;
      }
      const jsType = typeof value;
      if (jsType === "number") {
        if (Math.trunc(value) === value) {
          return "Int";
        } else {
          return "Float";
        }
      }
      if (Object.prototype.toString.call(value) === "[object Date]") {
        return "DateTime";
      }
      if (jsType === "string") {
        if (UUID_REGEX.test(value)) {
          return "UUID";
        }
        const date = new Date(value);
        if (date.toString() === "Invalid Date") {
          return "String";
        }
        if (RFC_3339_REGEX.test(value)) {
          return "DateTime";
        }
      }
      return JSTypeToGraphQLType[jsType];
    }
    __name(getGraphQLType, "getGraphQLType");
    function isValidEnumValue(value, inputType) {
      var _a32;
      const enumType = inputType == null ? void 0 : inputType.type;
      if (!isSchemaEnum(enumType)) {
        return false;
      }
      if ((inputType == null ? void 0 : inputType.namespace) === "prisma" && objectEnumNames.includes(enumType.name)) {
        const name = (_a32 = value == null ? void 0 : value.constructor) == null ? void 0 : _a32.name;
        return typeof name === "string" && objectEnumValues.instances[name] === value && enumType.values.includes(name);
      }
      return typeof value === "string" && enumType.values.includes(value);
    }
    __name(isValidEnumValue, "isValidEnumValue");
    function getSuggestion(str, possibilities) {
      const bestMatch = possibilities.reduce(
        (acc, curr) => {
          const distance = (0, import_js_levenshtein.default)(str, curr);
          if (distance < acc.distance) {
            return {
              distance,
              str: curr
            };
          }
          return acc;
        },
        {
          distance: Math.min(Math.floor(str.length) * 1.1, ...possibilities.map((p) => p.length * 3)),
          str: null
        }
      );
      return bestMatch.str;
    }
    __name(getSuggestion, "getSuggestion");
    function stringifyInputType(input, greenKeys = false) {
      if (typeof input === "string") {
        return input;
      }
      if (input.values) {
        return `enum ${input.name} {
${(0, import_indent_string2.default)(input.values.join(", "), 2)}
}`;
      } else {
        const body = (0, import_indent_string2.default)(
          input.fields.map((arg2) => {
            const key = `${arg2.name}`;
            const str = `${greenKeys ? import_chalk7.default.green(key) : key}${arg2.isRequired ? "" : "?"}: ${import_chalk7.default.white(
              arg2.inputTypes.map((argType) => {
                return wrapWithList(
                  argIsInputType(argType.type) ? argType.type.name : stringifyGraphQLType(argType.type),
                  argType.isList
                );
              }).join(" | ")
            )}`;
            if (!arg2.isRequired) {
              return import_chalk7.default.dim(str);
            }
            return str;
          }).join("\n"),
          2
        );
        return `${import_chalk7.default.dim("type")} ${import_chalk7.default.bold.dim(input.name)} ${import_chalk7.default.dim("{")}
${body}
${import_chalk7.default.dim("}")}`;
      }
    }
    __name(stringifyInputType, "stringifyInputType");
    function argIsInputType(arg2) {
      if (typeof arg2 === "string") {
        return false;
      }
      return true;
    }
    __name(argIsInputType, "argIsInputType");
    function getInputTypeName(input) {
      if (typeof input === "string") {
        if (input === "Null") {
          return "null";
        }
        return input;
      }
      return input.name;
    }
    __name(getInputTypeName, "getInputTypeName");
    function getOutputTypeName(input) {
      if (typeof input === "string") {
        return input;
      }
      return input.name;
    }
    __name(getOutputTypeName, "getOutputTypeName");
    function inputTypeToJson(input, isRequired, nameOnly = false) {
      if (typeof input === "string") {
        if (input === "Null") {
          return "null";
        }
        return input;
      }
      if (input.values) {
        return input.values.join(" | ");
      }
      const inputType = input;
      const showDeepType = isRequired && inputType.fields.every(
        (arg2) => {
          var _a32;
          return arg2.inputTypes[0].location === "inputObjectTypes" || ((_a32 = arg2.inputTypes[1]) == null ? void 0 : _a32.location) === "inputObjectTypes";
        }
      );
      if (nameOnly) {
        return getInputTypeName(input);
      }
      return inputType.fields.reduce((acc, curr) => {
        let str = "";
        if (!showDeepType && !curr.isRequired) {
          str = curr.inputTypes.map((argType) => getInputTypeName(argType.type)).join(" | ");
        } else {
          str = curr.inputTypes.map((argInputType) => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(" | ");
        }
        acc[curr.name + (curr.isRequired ? "" : "?")] = str;
        return acc;
      }, {});
    }
    __name(inputTypeToJson, "inputTypeToJson");
    function unionBy(arr1, arr2, iteratee) {
      const map = {};
      for (const element of arr1) {
        map[iteratee(element)] = element;
      }
      for (const element of arr2) {
        const key = iteratee(element);
        if (!map[key]) {
          map[key] = element;
        }
      }
      return Object.values(map);
    }
    __name(unionBy, "unionBy");
    function lowerCase(name) {
      return name.substring(0, 1).toLowerCase() + name.substring(1);
    }
    __name(lowerCase, "lowerCase");
    function isGroupByOutputName(type) {
      return type.endsWith("GroupByOutputType");
    }
    __name(isGroupByOutputName, "isGroupByOutputName");
    function isSchemaEnum(type) {
      return typeof type === "object" && type !== null && typeof type.name === "string" && Array.isArray(type.values);
    }
    __name(isSchemaEnum, "isSchemaEnum");
    var DMMFDatamodelHelper = class {
      constructor({ datamodel }) {
        this.datamodel = datamodel;
        this.datamodelEnumMap = this.getDatamodelEnumMap();
        this.modelMap = this.getModelMap();
        this.typeMap = this.getTypeMap();
        this.typeAndModelMap = this.getTypeModelMap();
      }
      getDatamodelEnumMap() {
        return keyBy2(this.datamodel.enums, "name");
      }
      getModelMap() {
        return { ...keyBy2(this.datamodel.models, "name") };
      }
      getTypeMap() {
        return { ...keyBy2(this.datamodel.types, "name") };
      }
      getTypeModelMap() {
        return { ...this.getTypeMap(), ...this.getModelMap() };
      }
    };
    __name(DMMFDatamodelHelper, "DMMFDatamodelHelper");
    var DMMFMappingsHelper = class {
      constructor({ mappings }) {
        this.mappings = mappings;
        this.mappingsMap = this.getMappingsMap();
      }
      getMappingsMap() {
        return keyBy2(this.mappings.modelOperations, "model");
      }
    };
    __name(DMMFMappingsHelper, "DMMFMappingsHelper");
    var DMMFSchemaHelper = class {
      constructor({ schema }) {
        this.outputTypeToMergedOutputType = /* @__PURE__ */ __name((outputType) => {
          return {
            ...outputType,
            fields: outputType.fields
          };
        }, "outputTypeToMergedOutputType");
        this.schema = schema;
        this.enumMap = this.getEnumMap();
        this.queryType = this.getQueryType();
        this.mutationType = this.getMutationType();
        this.outputTypes = this.getOutputTypes();
        this.outputTypeMap = this.getMergedOutputTypeMap();
        this.resolveOutputTypes();
        this.inputObjectTypes = this.schema.inputObjectTypes;
        this.inputTypeMap = this.getInputTypeMap();
        this.resolveInputTypes();
        this.resolveFieldArgumentTypes();
        this.queryType = this.outputTypeMap.Query;
        this.mutationType = this.outputTypeMap.Mutation;
        this.rootFieldMap = this.getRootFieldMap();
      }
      get [Symbol.toStringTag]() {
        return "DMMFClass";
      }
      resolveOutputTypes() {
        for (const type of this.outputTypes.model) {
          for (const field of type.fields) {
            if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
              field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
            }
          }
          type.fieldMap = keyBy2(type.fields, "name");
        }
        for (const type of this.outputTypes.prisma) {
          for (const field of type.fields) {
            if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
              field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
            }
          }
          type.fieldMap = keyBy2(type.fields, "name");
        }
      }
      resolveInputTypes() {
        const inputTypes = this.inputObjectTypes.prisma;
        if (this.inputObjectTypes.model) {
          inputTypes.push(...this.inputObjectTypes.model);
        }
        for (const type of inputTypes) {
          for (const field of type.fields) {
            for (const fieldInputType of field.inputTypes) {
              const fieldType = fieldInputType.type;
              if (typeof fieldType === "string" && !ScalarTypeTable[fieldType] && (this.inputTypeMap[fieldType] || this.enumMap[fieldType])) {
                fieldInputType.type = this.inputTypeMap[fieldType] || this.enumMap[fieldType] || fieldType;
              }
            }
          }
          type.fieldMap = keyBy2(type.fields, "name");
        }
      }
      resolveFieldArgumentTypes() {
        for (const type of this.outputTypes.prisma) {
          for (const field of type.fields) {
            for (const arg2 of field.args) {
              for (const argInputType of arg2.inputTypes) {
                const argType = argInputType.type;
                if (typeof argType === "string" && !ScalarTypeTable[argType]) {
                  argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argType;
                }
              }
            }
          }
        }
        for (const type of this.outputTypes.model) {
          for (const field of type.fields) {
            for (const arg2 of field.args) {
              for (const argInputType of arg2.inputTypes) {
                const argType = argInputType.type;
                if (typeof argType === "string" && !ScalarTypeTable[argType]) {
                  argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argInputType.type;
                }
              }
            }
          }
        }
      }
      getQueryType() {
        return this.schema.outputObjectTypes.prisma.find((t) => t.name === "Query");
      }
      getMutationType() {
        return this.schema.outputObjectTypes.prisma.find((t) => t.name === "Mutation");
      }
      getOutputTypes() {
        return {
          model: this.schema.outputObjectTypes.model.map(this.outputTypeToMergedOutputType),
          prisma: this.schema.outputObjectTypes.prisma.map(this.outputTypeToMergedOutputType)
        };
      }
      getEnumMap() {
        return {
          ...keyBy2(this.schema.enumTypes.prisma, "name"),
          ...this.schema.enumTypes.model ? keyBy2(this.schema.enumTypes.model, "name") : void 0
        };
      }
      hasEnumInNamespace(enumName, namespace) {
        var _a32;
        return ((_a32 = this.schema.enumTypes[namespace]) == null ? void 0 : _a32.find((schemaEnum) => schemaEnum.name === enumName)) !== void 0;
      }
      getMergedOutputTypeMap() {
        return {
          ...keyBy2(this.outputTypes.model, "name"),
          ...keyBy2(this.outputTypes.prisma, "name")
        };
      }
      getInputTypeMap() {
        return {
          ...this.schema.inputObjectTypes.model ? keyBy2(this.schema.inputObjectTypes.model, "name") : void 0,
          ...keyBy2(this.schema.inputObjectTypes.prisma, "name")
        };
      }
      getRootFieldMap() {
        return { ...keyBy2(this.queryType.fields, "name"), ...keyBy2(this.mutationType.fields, "name") };
      }
    };
    __name(DMMFSchemaHelper, "DMMFSchemaHelper");
    var BaseDMMFHelper = class {
      constructor(dmmf) {
        return Object.assign(this, new DMMFDatamodelHelper(dmmf), new DMMFMappingsHelper(dmmf));
      }
    };
    __name(BaseDMMFHelper, "BaseDMMFHelper");
    applyMixins(BaseDMMFHelper, [DMMFDatamodelHelper, DMMFMappingsHelper]);
    var DMMFHelper = class {
      constructor(dmmf) {
        return Object.assign(this, new BaseDMMFHelper(dmmf), new DMMFSchemaHelper(dmmf));
      }
    };
    __name(DMMFHelper, "DMMFHelper");
    applyMixins(DMMFHelper, [BaseDMMFHelper, DMMFSchemaHelper]);
    var import_async_hooks = require("async_hooks");
    var import_events = require("events");
    var import_fs9 = __toESM(require("fs"));
    var import_path5 = __toESM(require("path"));
    var Sql = class {
      constructor(rawStrings, rawValues) {
        if (rawStrings.length - 1 !== rawValues.length) {
          if (rawStrings.length === 0) {
            throw new TypeError("Expected at least 1 string");
          }
          throw new TypeError(`Expected ${rawStrings.length} strings to have ${rawStrings.length - 1} values`);
        }
        const valuesLength = rawValues.reduce((len, value) => len + (value instanceof Sql ? value.values.length : 1), 0);
        this.values = new Array(valuesLength);
        this.strings = new Array(valuesLength + 1);
        this.strings[0] = rawStrings[0];
        let i = 0, pos = 0;
        while (i < rawValues.length) {
          const child = rawValues[i++];
          const rawString = rawStrings[i];
          if (child instanceof Sql) {
            this.strings[pos] += child.strings[0];
            let childIndex = 0;
            while (childIndex < child.values.length) {
              this.values[pos++] = child.values[childIndex++];
              this.strings[pos] = child.strings[childIndex];
            }
            this.strings[pos] += rawString;
          } else {
            this.values[pos++] = child;
            this.strings[pos] = rawString;
          }
        }
      }
      get text() {
        let i = 1, value = this.strings[0];
        while (i < this.strings.length)
          value += `$${i}${this.strings[i++]}`;
        return value;
      }
      get sql() {
        let i = 1, value = this.strings[0];
        while (i < this.strings.length)
          value += `?${this.strings[i++]}`;
        return value;
      }
      inspect() {
        return {
          text: this.text,
          sql: this.sql,
          values: this.values
        };
      }
    };
    __name(Sql, "Sql");
    function join(values, separator = ",", prefix = "", suffix = "") {
      if (values.length === 0) {
        throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
      }
      return new Sql([prefix, ...Array(values.length - 1).fill(separator), suffix], values);
    }
    __name(join, "join");
    function raw(value) {
      return new Sql([value], []);
    }
    __name(raw, "raw");
    var empty = raw("");
    function sql(strings, ...values) {
      return new Sql(strings, values);
    }
    __name(sql, "sql");
    var import_pluralize = __toESM(require_pluralize());
    function externalToInternalDmmf(document2) {
      return {
        ...document2,
        mappings: getMappings(document2.mappings, document2.datamodel)
      };
    }
    __name(externalToInternalDmmf, "externalToInternalDmmf");
    function getMappings(mappings, datamodel) {
      const modelOperations = mappings.modelOperations.filter((mapping) => {
        const model = datamodel.models.find((m) => m.name === mapping.model);
        if (!model) {
          throw new Error(`Mapping without model ${mapping.model}`);
        }
        return model.fields.some((f) => f.kind !== "object");
      }).map((mapping) => ({
        model: mapping.model,
        plural: (0, import_pluralize.default)(lowerCase(mapping.model)),
        findUnique: mapping.findUnique || mapping.findSingle,
        findUniqueOrThrow: mapping.findUniqueOrThrow,
        findFirst: mapping.findFirst,
        findFirstOrThrow: mapping.findFirstOrThrow,
        findMany: mapping.findMany,
        create: mapping.createOne || mapping.createSingle || mapping.create,
        createMany: mapping.createMany,
        delete: mapping.deleteOne || mapping.deleteSingle || mapping.delete,
        update: mapping.updateOne || mapping.updateSingle || mapping.update,
        deleteMany: mapping.deleteMany,
        updateMany: mapping.updateMany,
        upsert: mapping.upsertOne || mapping.upsertSingle || mapping.upsert,
        aggregate: mapping.aggregate,
        groupBy: mapping.groupBy,
        findRaw: mapping.findRaw,
        aggregateRaw: mapping.aggregateRaw
      }));
      return {
        modelOperations,
        otherOperations: mappings.otherOperations
      };
    }
    __name(getMappings, "getMappings");
    function getPrismaClientDMMF(dmmf) {
      return externalToInternalDmmf(dmmf);
    }
    __name(getPrismaClientDMMF, "getPrismaClientDMMF");
    var import_chalk11 = __toESM(require_source());
    var import_indent_string4 = __toESM(require_indent_string());
    var import_strip_ansi3 = __toESM(require_strip_ansi());
    var Cache = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      get(key) {
        var _a32;
        return (_a32 = this._map.get(key)) == null ? void 0 : _a32.value;
      }
      set(key, value) {
        this._map.set(key, { value });
      }
      getOrCreate(key, create2) {
        const cached = this._map.get(key);
        if (cached) {
          return cached.value;
        }
        const value = create2();
        this.set(key, value);
        return value;
      }
    };
    __name(Cache, "Cache");
    function dmmfToJSModelName(name) {
      return name.replace(/^./, (str) => str.toLowerCase());
    }
    __name(dmmfToJSModelName, "dmmfToJSModelName");
    function getComputedFields(previousComputedFields, extension, dmmfModelName) {
      const jsName = dmmfToJSModelName(dmmfModelName);
      if (!extension.result || !(extension.result.$allModels || extension.result[jsName])) {
        return previousComputedFields;
      }
      return resolveDependencies({
        ...previousComputedFields,
        ...getComputedFieldsFromModel(extension.name, extension.result.$allModels),
        ...getComputedFieldsFromModel(extension.name, extension.result[jsName])
      });
    }
    __name(getComputedFields, "getComputedFields");
    function resolveDependencies(computedFields) {
      const cache = new Cache();
      const resolveNeeds = /* @__PURE__ */ __name((fieldName) => {
        return cache.getOrCreate(fieldName, () => {
          if (computedFields[fieldName]) {
            return computedFields[fieldName].needs.flatMap(resolveNeeds);
          }
          return [fieldName];
        });
      }, "resolveNeeds");
      return mapObjectValues(computedFields, (field) => {
        return {
          ...field,
          needs: resolveNeeds(field.name)
        };
      });
    }
    __name(resolveDependencies, "resolveDependencies");
    function getComputedFieldsFromModel(name, modelResult) {
      if (!modelResult) {
        return {};
      }
      return mapObjectValues(modelResult, ({ needs, compute }, fieldName) => ({
        name: fieldName,
        needs: needs ? Object.keys(needs).filter((key) => needs[key]) : [],
        compute: wrapExtensionCallback(name, compute)
      }));
    }
    __name(getComputedFieldsFromModel, "getComputedFieldsFromModel");
    function applyComputedFieldsToSelection(selection, computedFields) {
      if (!computedFields) {
        return selection;
      }
      const result = { ...selection };
      for (const field of Object.values(computedFields)) {
        if (!selection[field.name]) {
          continue;
        }
        for (const dependency of field.needs) {
          result[dependency] = true;
        }
      }
      return result;
    }
    __name(applyComputedFieldsToSelection, "applyComputedFieldsToSelection");
    var import_chalk9 = __toESM(require_source());
    var import_indent_string3 = __toESM(require_indent_string());
    var import_fs8 = __toESM(require("fs"));
    var import_chalk8 = __toESM(require_source());
    var orange = import_chalk8.default.rgb(246, 145, 95);
    var darkBrightBlue = import_chalk8.default.rgb(107, 139, 140);
    var blue = import_chalk8.default.cyan;
    var brightBlue = import_chalk8.default.rgb(127, 155, 155);
    var identity = /* @__PURE__ */ __name((str) => str, "identity");
    var theme = {
      keyword: blue,
      entity: blue,
      value: brightBlue,
      punctuation: darkBrightBlue,
      directive: blue,
      function: blue,
      variable: brightBlue,
      string: import_chalk8.default.greenBright,
      boolean: orange,
      number: import_chalk8.default.cyan,
      comment: import_chalk8.default.grey
    };
    var _self = {};
    var uniqueId = 0;
    var Prism = {
      manual: _self.Prism && _self.Prism.manual,
      disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
      util: {
        encode: function(tokens) {
          if (tokens instanceof Token) {
            const anyTokens = tokens;
            return new Token(anyTokens.type, Prism.util.encode(anyTokens.content), anyTokens.alias);
          } else if (Array.isArray(tokens)) {
            return tokens.map(Prism.util.encode);
          } else {
            return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          }
        },
        type: function(o) {
          return Object.prototype.toString.call(o).slice(8, -1);
        },
        objId: function(obj) {
          if (!obj["__id"]) {
            Object.defineProperty(obj, "__id", { value: ++uniqueId });
          }
          return obj["__id"];
        },
        clone: /* @__PURE__ */ __name(function deepClone(o, visited) {
          let clone2, id, type = Prism.util.type(o);
          visited = visited || {};
          switch (type) {
            case "Object":
              id = Prism.util.objId(o);
              if (visited[id]) {
                return visited[id];
              }
              clone2 = {};
              visited[id] = clone2;
              for (const key in o) {
                if (o.hasOwnProperty(key)) {
                  clone2[key] = deepClone(o[key], visited);
                }
              }
              return clone2;
            case "Array":
              id = Prism.util.objId(o);
              if (visited[id]) {
                return visited[id];
              }
              clone2 = [];
              visited[id] = clone2;
              o.forEach(function(v, i) {
                clone2[i] = deepClone(v, visited);
              });
              return clone2;
            default:
              return o;
          }
        }, "deepClone")
      },
      languages: {
        extend: function(id, redef) {
          const lang = Prism.util.clone(Prism.languages[id]);
          for (const key in redef) {
            lang[key] = redef[key];
          }
          return lang;
        },
        insertBefore: function(inside, before, insert, root) {
          root = root || Prism.languages;
          const grammar = root[inside];
          const ret = {};
          for (const token in grammar) {
            if (grammar.hasOwnProperty(token)) {
              if (token == before) {
                for (const newToken in insert) {
                  if (insert.hasOwnProperty(newToken)) {
                    ret[newToken] = insert[newToken];
                  }
                }
              }
              if (!insert.hasOwnProperty(token)) {
                ret[token] = grammar[token];
              }
            }
          }
          const old = root[inside];
          root[inside] = ret;
          Prism.languages.DFS(Prism.languages, function(key, value) {
            if (value === old && key != inside) {
              this[key] = ret;
            }
          });
          return ret;
        },
        DFS: /* @__PURE__ */ __name(function DFS(o, callback, type, visited) {
          visited = visited || {};
          const objId = Prism.util.objId;
          for (const i in o) {
            if (o.hasOwnProperty(i)) {
              callback.call(o, i, o[i], type || i);
              const property = o[i], propertyType = Prism.util.type(property);
              if (propertyType === "Object" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, null, visited);
              } else if (propertyType === "Array" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, i, visited);
              }
            }
          }
        }, "DFS")
      },
      plugins: {},
      highlight: function(text, grammar, language) {
        const env2 = {
          code: text,
          grammar,
          language
        };
        Prism.hooks.run("before-tokenize", env2);
        env2.tokens = Prism.tokenize(env2.code, env2.grammar);
        Prism.hooks.run("after-tokenize", env2);
        return Token.stringify(Prism.util.encode(env2.tokens), env2.language);
      },
      matchGrammar: function(text, strarr, grammar, index, startPos, oneshot, target) {
        for (const token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          if (token == target) {
            return;
          }
          let patterns = grammar[token];
          patterns = Prism.util.type(patterns) === "Array" ? patterns : [patterns];
          for (let j = 0; j < patterns.length; ++j) {
            let pattern = patterns[j], inside = pattern.inside, lookbehind = !!pattern.lookbehind, greedy = !!pattern.greedy, lookbehindLength = 0, alias = pattern.alias;
            if (greedy && !pattern.pattern.global) {
              const flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
              pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
            }
            pattern = pattern.pattern || pattern;
            for (let i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {
              let str = strarr[i];
              if (strarr.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              if (greedy && i != strarr.length - 1) {
                pattern.lastIndex = pos;
                var match = pattern.exec(text);
                if (!match) {
                  break;
                }
                var from = match.index + (lookbehind ? match[1].length : 0), to = match.index + match[0].length, k = i, p = pos;
                for (let len = strarr.length; k < len && (p < to || !strarr[k].type && !strarr[k - 1].greedy); ++k) {
                  p += strarr[k].length;
                  if (from >= p) {
                    ++i;
                    pos = p;
                  }
                }
                if (strarr[i] instanceof Token) {
                  continue;
                }
                delNum = k - i;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                pattern.lastIndex = 0;
                var match = pattern.exec(str), delNum = 1;
              }
              if (!match) {
                if (oneshot) {
                  break;
                }
                continue;
              }
              if (lookbehind) {
                lookbehindLength = match[1] ? match[1].length : 0;
              }
              var from = match.index + lookbehindLength, match = match[0].slice(lookbehindLength), to = from + match.length, before = str.slice(0, from), after = str.slice(to);
              const args = [i, delNum];
              if (before) {
                ++i;
                pos += before.length;
                args.push(before);
              }
              const wrapped = new Token(token, inside ? Prism.tokenize(match, inside) : match, alias, match, greedy);
              args.push(wrapped);
              if (after) {
                args.push(after);
              }
              Array.prototype.splice.apply(strarr, args);
              if (delNum != 1)
                Prism.matchGrammar(text, strarr, grammar, i, pos, true, token);
              if (oneshot)
                break;
            }
          }
        }
      },
      tokenize: function(text, grammar) {
        const strarr = [text];
        const rest = grammar.rest;
        if (rest) {
          for (const token in rest) {
            grammar[token] = rest[token];
          }
          delete grammar.rest;
        }
        Prism.matchGrammar(text, strarr, grammar, 0, 0, false);
        return strarr;
      },
      hooks: {
        all: {},
        add: function(name, callback) {
          const hooks = Prism.hooks.all;
          hooks[name] = hooks[name] || [];
          hooks[name].push(callback);
        },
        run: function(name, env2) {
          const callbacks = Prism.hooks.all[name];
          if (!callbacks || !callbacks.length) {
            return;
          }
          for (var i = 0, callback; callback = callbacks[i++]; ) {
            callback(env2);
          }
        }
      },
      Token
    };
    Prism.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
        lookbehind: true,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
      boolean: /\b(?:true|false)\b/,
      function: /\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
      punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.javascript = Prism.languages.extend("clike", {
      "class-name": [
        Prism.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
          lookbehind: true
        }
      ],
      keyword: [
        {
          pattern: /((?:^|})\s*)(?:catch|finally)\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
      function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
    });
    Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    Prism.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,
        lookbehind: true,
        greedy: true
      },
      "function-variable": {
        pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
          inside: Prism.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    if (Prism.languages.markup) {
      Prism.languages.markup.tag.addInlined("script", "javascript");
    }
    Prism.languages.js = Prism.languages.javascript;
    Prism.languages.typescript = Prism.languages.extend("javascript", {
      keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,
      builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/
    });
    Prism.languages.ts = Prism.languages.typescript;
    function Token(type, content, alias, matchedStr, greedy) {
      this.type = type;
      this.content = content;
      this.alias = alias;
      this.length = (matchedStr || "").length | 0;
      this.greedy = !!greedy;
    }
    __name(Token, "Token");
    Token.stringify = function(o, language) {
      if (typeof o == "string") {
        return o;
      }
      if (Array.isArray(o)) {
        return o.map(function(element) {
          return Token.stringify(element, language);
        }).join("");
      }
      return getColorForSyntaxKind(o.type)(o.content);
    };
    function getColorForSyntaxKind(syntaxKind) {
      return theme[syntaxKind] || identity;
    }
    __name(getColorForSyntaxKind, "getColorForSyntaxKind");
    function highlightTS(str) {
      return highlight(str, Prism.languages.javascript);
    }
    __name(highlightTS, "highlightTS");
    function highlight(str, grammar) {
      const tokens = Prism.tokenize(str, grammar);
      return tokens.map((t) => Token.stringify(t)).join("");
    }
    __name(highlight, "highlight");
    var import_strip_indent2 = __toESM(require_strip_indent());
    function dedent2(str) {
      return (0, import_strip_indent2.default)(str);
    }
    __name(dedent2, "dedent");
    var SourceFileSlice = class {
      static read(filePath) {
        let content;
        try {
          content = import_fs8.default.readFileSync(filePath, "utf-8");
        } catch (e) {
          return null;
        }
        return SourceFileSlice.fromContent(content);
      }
      static fromContent(content) {
        const lines = content.split(/\r?\n/);
        return new SourceFileSlice(1, lines);
      }
      constructor(firstLine, lines) {
        this.firstLineNumber = firstLine;
        this.lines = lines;
      }
      get lastLineNumber() {
        return this.firstLineNumber + this.lines.length - 1;
      }
      mapLineAt(lineNumber, mapFn) {
        if (lineNumber < this.firstLineNumber || lineNumber > this.lines.length + this.firstLineNumber) {
          return this;
        }
        const idx = lineNumber - this.firstLineNumber;
        const newLines = [...this.lines];
        newLines[idx] = mapFn(newLines[idx]);
        return new SourceFileSlice(this.firstLineNumber, newLines);
      }
      mapLines(mapFn) {
        return new SourceFileSlice(
          this.firstLineNumber,
          this.lines.map((line, i) => mapFn(line, this.firstLineNumber + i))
        );
      }
      lineAt(lineNumber) {
        return this.lines[lineNumber - this.firstLineNumber];
      }
      prependSymbolAt(atLine, str) {
        return this.mapLines((line, lineNumber) => {
          if (lineNumber === atLine) {
            return `${str} ${line}`;
          }
          return `  ${line}`;
        });
      }
      slice(fromLine, toLine) {
        const slicedLines = this.lines.slice(fromLine - 1, toLine).join("\n");
        return new SourceFileSlice(fromLine, dedent2(slicedLines).split("\n"));
      }
      highlight() {
        const highlighted = highlightTS(this.toString());
        return new SourceFileSlice(this.firstLineNumber, highlighted.split("\n"));
      }
      toString() {
        return this.lines.join("\n");
      }
    };
    __name(SourceFileSlice, "SourceFileSlice");
    var colorsEnabled = {
      red: (str) => import_chalk9.default.red(str),
      gray: (str) => import_chalk9.default.gray(str),
      dim: (str) => import_chalk9.default.dim(str),
      bold: (str) => import_chalk9.default.bold(str),
      underline: (str) => import_chalk9.default.underline(str),
      highlightSource: (source) => source.highlight()
    };
    var colorsDisabled = {
      red: (str) => str,
      gray: (str) => str,
      dim: (str) => str,
      bold: (str) => str,
      underline: (str) => str,
      highlightSource: (source) => source
    };
    function getTemplateParameters({ callsite, message, originalMethod, isPanic: isPanic2, callArguments }, colors) {
      var _a32;
      const templateParameters = {
        functionName: `prisma.${originalMethod}()`,
        message,
        isPanic: isPanic2 != null ? isPanic2 : false,
        callArguments
      };
      if (!callsite || typeof window !== "undefined") {
        return templateParameters;
      }
      if (process.env.NODE_ENV === "production") {
        return templateParameters;
      }
      const callLocation = callsite.getLocation();
      if (!callLocation || !callLocation.lineNumber || !callLocation.columnNumber) {
        return templateParameters;
      }
      const contextFirstLine = Math.max(1, callLocation.lineNumber - 3);
      let source = (_a32 = SourceFileSlice.read(callLocation.fileName)) == null ? void 0 : _a32.slice(contextFirstLine, callLocation.lineNumber);
      const invocationLine = source == null ? void 0 : source.lineAt(callLocation.lineNumber);
      if (source && invocationLine) {
        const invocationLineIndent = getIndent(invocationLine);
        const invocationCallCode = findPrismaActionCall(invocationLine);
        if (!invocationCallCode) {
          return templateParameters;
        }
        templateParameters.functionName = `${invocationCallCode.code})`;
        templateParameters.location = callLocation;
        if (!isPanic2) {
          source = source.mapLineAt(callLocation.lineNumber, (line) => line.slice(0, invocationCallCode.openingBraceIndex));
        }
        source = colors.highlightSource(source);
        const numberColumnWidth = String(source.lastLineNumber).length;
        templateParameters.contextLines = source.mapLines((line, lineNumber) => colors.gray(String(lineNumber).padStart(numberColumnWidth)) + " " + line).mapLines((line) => colors.dim(line)).prependSymbolAt(callLocation.lineNumber, colors.bold(colors.red("\u2192")));
        if (callArguments) {
          let indentValue = invocationLineIndent + numberColumnWidth + 1;
          indentValue += 2;
          templateParameters.callArguments = (0, import_indent_string3.default)(callArguments, indentValue).slice(indentValue);
        }
      }
      return templateParameters;
    }
    __name(getTemplateParameters, "getTemplateParameters");
    function findPrismaActionCall(str) {
      const allActions = Object.keys(DMMF.ModelAction).join("|");
      const regexp = new RegExp(String.raw`\S+(${allActions})\(`);
      const match = regexp.exec(str);
      if (match) {
        return {
          code: match[0],
          openingBraceIndex: match.index + match[0].length
        };
      }
      return null;
    }
    __name(findPrismaActionCall, "findPrismaActionCall");
    function getIndent(line) {
      let spaceCount = 0;
      for (let i = 0; i < line.length; i++) {
        if (line.charAt(i) !== " ") {
          return spaceCount;
        }
        spaceCount++;
      }
      return spaceCount;
    }
    __name(getIndent, "getIndent");
    function stringifyErrorMessage({ functionName, location, message, isPanic: isPanic2, contextLines, callArguments }, colors) {
      const lines = [""];
      const introSuffix = location ? " in" : ":";
      if (isPanic2) {
        lines.push(colors.red(`Oops, an unknown error occurred! This is ${colors.bold("on us")}, you did nothing wrong.`));
        lines.push(colors.red(`It occurred in the ${colors.bold(`\`${functionName}\``)} invocation${introSuffix}`));
      } else {
        lines.push(colors.red(`Invalid ${colors.bold(`\`${functionName}\``)} invocation${introSuffix}`));
      }
      if (location) {
        lines.push(colors.underline(stringifyLocationInFile(location)));
      }
      if (contextLines) {
        lines.push("");
        const contextLineParts = [contextLines.toString()];
        if (callArguments) {
          contextLineParts.push(callArguments);
          contextLineParts.push(colors.dim(")"));
        }
        lines.push(contextLineParts.join(""));
        if (callArguments) {
          lines.push("");
        }
      } else {
        lines.push("");
        if (callArguments) {
          lines.push(callArguments);
        }
        lines.push("");
      }
      lines.push(message);
      return lines.join("\n");
    }
    __name(stringifyErrorMessage, "stringifyErrorMessage");
    function stringifyLocationInFile(location) {
      const parts = [location.fileName];
      if (location.lineNumber) {
        parts.push(String(location.lineNumber));
      }
      if (location.columnNumber) {
        parts.push(String(location.columnNumber));
      }
      return parts.join(":");
    }
    __name(stringifyLocationInFile, "stringifyLocationInFile");
    function createErrorMessageWithContext(args) {
      const colors = args.showColors ? colorsEnabled : colorsDisabled;
      const templateParameters = getTemplateParameters(args, colors);
      return stringifyErrorMessage(templateParameters, colors);
    }
    __name(createErrorMessageWithContext, "createErrorMessageWithContext");
    function isSpecificValue(val) {
      return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
    }
    __name(isSpecificValue, "isSpecificValue");
    function cloneSpecificValue(val) {
      if (val instanceof Buffer) {
        const x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        val.copy(x);
        return x;
      } else if (val instanceof Date) {
        return new Date(val.getTime());
      } else if (val instanceof RegExp) {
        return new RegExp(val);
      } else {
        throw new Error("Unexpected situation");
      }
    }
    __name(cloneSpecificValue, "cloneSpecificValue");
    function deepCloneArray(arr) {
      const clone2 = [];
      arr.forEach(function(item, index) {
        if (typeof item === "object" && item !== null) {
          if (Array.isArray(item)) {
            clone2[index] = deepCloneArray(item);
          } else if (isSpecificValue(item)) {
            clone2[index] = cloneSpecificValue(item);
          } else {
            clone2[index] = deepExtend({}, item);
          }
        } else {
          clone2[index] = item;
        }
      });
      return clone2;
    }
    __name(deepCloneArray, "deepCloneArray");
    function safeGetProperty(object, property) {
      return property === "__proto__" ? void 0 : object[property];
    }
    __name(safeGetProperty, "safeGetProperty");
    var deepExtend = /* @__PURE__ */ __name(function(target, ...args) {
      if (!target || typeof target !== "object") {
        return false;
      }
      if (args.length === 0) {
        return target;
      }
      let val, src;
      for (const obj of args) {
        if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
          continue;
        }
        for (const key of Object.keys(obj)) {
          src = safeGetProperty(target, key);
          val = safeGetProperty(obj, key);
          if (val === target) {
            continue;
          } else if (typeof val !== "object" || val === null) {
            target[key] = val;
            continue;
          } else if (Array.isArray(val)) {
            target[key] = deepCloneArray(val);
            continue;
          } else if (isSpecificValue(val)) {
            target[key] = cloneSpecificValue(val);
            continue;
          } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
            target[key] = deepExtend({}, val);
            continue;
          } else {
            target[key] = deepExtend(src, val);
            continue;
          }
        }
      }
      return target;
    }, "deepExtend");
    var keys = /* @__PURE__ */ __name((ks) => Array.isArray(ks) ? ks : ks.split("."), "keys");
    var deepGet = /* @__PURE__ */ __name((o, kp) => keys(kp).reduce((o2, k) => o2 && o2[k], o), "deepGet");
    var deepSet = /* @__PURE__ */ __name((o, kp, v) => keys(kp).reduceRight((v2, k, i, ks) => Object.assign({}, deepGet(o, ks.slice(0, i)), { [k]: v2 }), v), "deepSet");
    function filterObject(obj, cb) {
      if (!obj || typeof obj !== "object" || typeof obj.hasOwnProperty !== "function") {
        return obj;
      }
      const newObj = {};
      for (const key in obj) {
        const value = obj[key];
        if (Object.hasOwnProperty.call(obj, key) && cb(key, value)) {
          newObj[key] = value;
        }
      }
      return newObj;
    }
    __name(filterObject, "filterObject");
    var notReallyObjects = {
      "[object Date]": true,
      "[object Uint8Array]": true,
      "[object Decimal]": true
    };
    function isObject2(value) {
      if (!value) {
        return false;
      }
      return typeof value === "object" && !notReallyObjects[Object.prototype.toString.call(value)];
    }
    __name(isObject2, "isObject");
    function omit2(object, path7) {
      const result = {};
      const paths = Array.isArray(path7) ? path7 : [path7];
      for (const key in object) {
        if (Object.hasOwnProperty.call(object, key) && !paths.includes(key)) {
          result[key] = object[key];
        }
      }
      return result;
    }
    __name(omit2, "omit");
    var import_chalk10 = __toESM(require_source());
    var import_strip_ansi2 = __toESM(require_strip_ansi());
    var isRegexp = require_is_regexp();
    var isObj = require_is_obj();
    var getOwnEnumPropSymbols = require_lib2().default;
    var stringifyObject = /* @__PURE__ */ __name((input, options, pad) => {
      const seen = [];
      return (/* @__PURE__ */ __name(function stringifyObject2(input2, options2 = {}, pad2 = "", path7 = []) {
        options2.indent = options2.indent || "	";
        let tokens;
        if (options2.inlineCharacterLimit === void 0) {
          tokens = {
            newLine: "\n",
            newLineOrSpace: "\n",
            pad: pad2,
            indent: pad2 + options2.indent
          };
        } else {
          tokens = {
            newLine: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
            newLineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
            pad: "@@__STRINGIFY_OBJECT_PAD__@@",
            indent: "@@__STRINGIFY_OBJECT_INDENT__@@"
          };
        }
        const expandWhiteSpace = /* @__PURE__ */ __name((string) => {
          if (options2.inlineCharacterLimit === void 0) {
            return string;
          }
          const oneLined = string.replace(new RegExp(tokens.newLine, "g"), "").replace(new RegExp(tokens.newLineOrSpace, "g"), " ").replace(new RegExp(tokens.pad + "|" + tokens.indent, "g"), "");
          if (oneLined.length <= options2.inlineCharacterLimit) {
            return oneLined;
          }
          return string.replace(new RegExp(tokens.newLine + "|" + tokens.newLineOrSpace, "g"), "\n").replace(new RegExp(tokens.pad, "g"), pad2).replace(new RegExp(tokens.indent, "g"), pad2 + options2.indent);
        }, "expandWhiteSpace");
        if (seen.indexOf(input2) !== -1) {
          return '"[Circular]"';
        }
        if (Buffer.isBuffer(input2)) {
          return `Buffer(${Buffer.length})`;
        }
        if (input2 === null || input2 === void 0 || typeof input2 === "number" || typeof input2 === "boolean" || typeof input2 === "function" || typeof input2 === "symbol" || input2 instanceof ObjectEnumValue || isRegexp(input2)) {
          return String(input2);
        }
        if (input2 instanceof Date) {
          return `new Date('${input2.toISOString()}')`;
        }
        if (input2 instanceof FieldRefImpl) {
          return `prisma.${lowerCase(input2.modelName)}.fields.${input2.name}`;
        }
        if (Array.isArray(input2)) {
          if (input2.length === 0) {
            return "[]";
          }
          seen.push(input2);
          const ret = "[" + tokens.newLine + input2.map((el, i) => {
            const eol = input2.length - 1 === i ? tokens.newLine : "," + tokens.newLineOrSpace;
            let value = stringifyObject2(el, options2, pad2 + options2.indent, [...path7, i]);
            if (options2.transformValue) {
              value = options2.transformValue(input2, i, value);
            }
            return tokens.indent + value + eol;
          }).join("") + tokens.pad + "]";
          seen.pop();
          return expandWhiteSpace(ret);
        }
        if (isObj(input2)) {
          let objKeys = Object.keys(input2).concat(getOwnEnumPropSymbols(input2));
          if (options2.filter) {
            objKeys = objKeys.filter((el) => options2.filter(input2, el));
          }
          if (objKeys.length === 0) {
            return "{}";
          }
          seen.push(input2);
          const ret = "{" + tokens.newLine + objKeys.map((el, i) => {
            const eol = objKeys.length - 1 === i ? tokens.newLine : "," + tokens.newLineOrSpace;
            const isSymbol = typeof el === "symbol";
            const isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el);
            const key = isSymbol || isClassic ? el : stringifyObject2(el, options2, void 0, [...path7, el]);
            let value = stringifyObject2(input2[el], options2, pad2 + options2.indent, [...path7, el]);
            if (options2.transformValue) {
              value = options2.transformValue(input2, el, value);
            }
            let line = tokens.indent + String(key) + ": " + value + eol;
            if (options2.transformLine) {
              line = options2.transformLine({
                obj: input2,
                indent: tokens.indent,
                key,
                stringifiedValue: value,
                value: input2[el],
                eol,
                originalLine: line,
                path: path7.concat(key)
              });
            }
            return line;
          }).join("") + tokens.pad + "}";
          seen.pop();
          return expandWhiteSpace(ret);
        }
        input2 = String(input2).replace(/[\r\n]/g, (x) => x === "\n" ? "\\n" : "\\r");
        if (options2.singleQuotes === false) {
          input2 = input2.replace(/"/g, '\\"');
          return `"${input2}"`;
        }
        input2 = input2.replace(/\\?'/g, "\\'");
        return `'${input2}'`;
      }, "stringifyObject"))(input, options, pad);
    }, "stringifyObject");
    var stringifyObject_default = stringifyObject;
    var DIM_TOKEN = "@@__DIM_POINTER__@@";
    function printJsonWithErrors({ ast, keyPaths, valuePaths, missingItems }) {
      let obj = ast;
      for (const { path: path7, type } of missingItems) {
        obj = deepSet(obj, path7, type);
      }
      return stringifyObject_default(obj, {
        indent: "  ",
        transformLine: ({ indent: indent4, key, value, stringifiedValue, eol, path: path7 }) => {
          const dottedPath = path7.join(".");
          const keyError = keyPaths.includes(dottedPath);
          const valueError = valuePaths.includes(dottedPath);
          const missingItem = missingItems.find((item) => item.path === dottedPath);
          let valueStr = stringifiedValue;
          if (missingItem) {
            if (typeof value === "string") {
              valueStr = valueStr.slice(1, valueStr.length - 1);
            }
            const isRequiredStr = missingItem.isRequired ? "" : "?";
            const prefix = missingItem.isRequired ? "+" : "?";
            const color = missingItem.isRequired ? import_chalk10.default.greenBright : import_chalk10.default.green;
            let output = color(prefixLines(key + isRequiredStr + ": " + valueStr + eol, indent4, prefix));
            if (!missingItem.isRequired) {
              output = import_chalk10.default.dim(output);
            }
            return output;
          } else {
            const isOnMissingItemPath = missingItems.some((item) => dottedPath.startsWith(item.path));
            const isOptional = key[key.length - 2] === "?";
            if (isOptional) {
              key = key.slice(1, key.length - 1);
            }
            if (isOptional && typeof value === "object" && value !== null) {
              valueStr = valueStr.split("\n").map((line, index, arr) => index === arr.length - 1 ? line + DIM_TOKEN : line).join("\n");
            }
            if (isOnMissingItemPath && typeof value === "string") {
              valueStr = valueStr.slice(1, valueStr.length - 1);
              if (!isOptional) {
                valueStr = import_chalk10.default.bold(valueStr);
              }
            }
            if ((typeof value !== "object" || value === null) && !valueError && !isOnMissingItemPath) {
              valueStr = import_chalk10.default.dim(valueStr);
            }
            const keyStr = keyError ? import_chalk10.default.redBright(key) : key;
            valueStr = valueError ? import_chalk10.default.redBright(valueStr) : valueStr;
            let output = indent4 + keyStr + ": " + valueStr + (isOnMissingItemPath ? eol : import_chalk10.default.dim(eol));
            if (keyError || valueError) {
              const lines = output.split("\n");
              const keyLength = String(key).length;
              const keyScribbles = keyError ? import_chalk10.default.redBright("~".repeat(keyLength)) : " ".repeat(keyLength);
              const valueLength = valueError ? getValueLength(indent4, key, value, stringifiedValue) : 0;
              const hideValueScribbles = valueError && isRenderedAsObject(value);
              const valueScribbles = valueError ? "  " + import_chalk10.default.redBright("~".repeat(valueLength)) : "";
              if (keyScribbles && keyScribbles.length > 0 && !hideValueScribbles) {
                lines.splice(1, 0, indent4 + keyScribbles + valueScribbles);
              }
              if (keyScribbles && keyScribbles.length > 0 && hideValueScribbles) {
                lines.splice(lines.length - 1, 0, indent4.slice(0, indent4.length - 2) + valueScribbles);
              }
              output = lines.join("\n");
            }
            return output;
          }
        }
      });
    }
    __name(printJsonWithErrors, "printJsonWithErrors");
    function getValueLength(indent4, key, value, stringifiedValue) {
      if (value === null) {
        return 4;
      }
      if (typeof value === "string") {
        return value.length + 2;
      }
      if (isRenderedAsObject(value)) {
        return Math.abs(getLongestLine(`${key}: ${(0, import_strip_ansi2.default)(stringifiedValue)}`) - indent4.length);
      }
      return String(value).length;
    }
    __name(getValueLength, "getValueLength");
    function isRenderedAsObject(value) {
      return typeof value === "object" && value !== null && !(value instanceof ObjectEnumValue);
    }
    __name(isRenderedAsObject, "isRenderedAsObject");
    function getLongestLine(str) {
      return str.split("\n").reduce((max2, curr) => curr.length > max2 ? curr.length : max2, 0);
    }
    __name(getLongestLine, "getLongestLine");
    function prefixLines(str, indent4, prefix) {
      return str.split("\n").map(
        (line, index, arr) => index === 0 ? prefix + indent4.slice(1) + line : index < arr.length - 1 ? prefix + line.slice(1) : line
      ).map((line) => {
        return (0, import_strip_ansi2.default)(line).includes(DIM_TOKEN) ? import_chalk10.default.dim(line.replace(DIM_TOKEN, "")) : line.includes("?") ? import_chalk10.default.dim(line) : line;
      }).join("\n");
    }
    __name(prefixLines, "prefixLines");
    var tab = 2;
    var Document = class {
      constructor(type, children) {
        this.type = type;
        this.children = children;
        this.printFieldError = /* @__PURE__ */ __name(({ error: error2 }, missingItems, minimal) => {
          if (error2.type === "emptySelect") {
            const additional = minimal ? "" : ` Available options are listed in ${import_chalk11.default.greenBright.dim("green")}.`;
            return `The ${import_chalk11.default.redBright("`select`")} statement for type ${import_chalk11.default.bold(
              getOutputTypeName(error2.field.outputType.type)
            )} must not be empty.${additional}`;
          }
          if (error2.type === "emptyInclude") {
            if (missingItems.length === 0) {
              return `${import_chalk11.default.bold(
                getOutputTypeName(error2.field.outputType.type)
              )} does not have any relation and therefore can't have an ${import_chalk11.default.redBright("`include`")} statement.`;
            }
            const additional = minimal ? "" : ` Available options are listed in ${import_chalk11.default.greenBright.dim("green")}.`;
            return `The ${import_chalk11.default.redBright("`include`")} statement for type ${import_chalk11.default.bold(
              getOutputTypeName(error2.field.outputType.type)
            )} must not be empty.${additional}`;
          }
          if (error2.type === "noTrueSelect") {
            return `The ${import_chalk11.default.redBright("`select`")} statement for type ${import_chalk11.default.bold(
              getOutputTypeName(error2.field.outputType.type)
            )} needs ${import_chalk11.default.bold("at least one truthy value")}.`;
          }
          if (error2.type === "includeAndSelect") {
            return `Please ${import_chalk11.default.bold("either")} use ${import_chalk11.default.greenBright("`include`")} or ${import_chalk11.default.greenBright(
              "`select`"
            )}, but ${import_chalk11.default.redBright("not both")} at the same time.`;
          }
          if (error2.type === "invalidFieldName") {
            const statement = error2.isInclude ? "include" : "select";
            const wording = error2.isIncludeScalar ? "Invalid scalar" : "Unknown";
            const additional = minimal ? "" : error2.isInclude && missingItems.length === 0 ? `
This model has no relations, so you can't use ${import_chalk11.default.redBright("include")} with it.` : ` Available options are listed in ${import_chalk11.default.greenBright.dim("green")}.`;
            let str = `${wording} field ${import_chalk11.default.redBright(`\`${error2.providedName}\``)} for ${import_chalk11.default.bold(
              statement
            )} statement on model ${import_chalk11.default.bold.white(error2.modelName)}.${additional}`;
            if (error2.didYouMean) {
              str += ` Did you mean ${import_chalk11.default.greenBright(`\`${error2.didYouMean}\``)}?`;
            }
            if (error2.isIncludeScalar) {
              str += `
Note, that ${import_chalk11.default.bold("include")} statements only accept relation fields.`;
            }
            return str;
          }
          if (error2.type === "invalidFieldType") {
            const str = `Invalid value ${import_chalk11.default.redBright(
              `${stringifyObject_default(error2.providedValue)}`
            )} of type ${import_chalk11.default.redBright(getGraphQLType(error2.providedValue, void 0))} for field ${import_chalk11.default.bold(
              `${error2.fieldName}`
            )} on model ${import_chalk11.default.bold.white(error2.modelName)}. Expected either ${import_chalk11.default.greenBright(
              "true"
            )} or ${import_chalk11.default.greenBright("false")}.`;
            return str;
          }
          return void 0;
        }, "printFieldError");
        this.printArgError = /* @__PURE__ */ __name(({ error: error2, path: path7, id }, hasMissingItems, minimal) => {
          if (error2.type === "invalidName") {
            let str = `Unknown arg ${import_chalk11.default.redBright(`\`${error2.providedName}\``)} in ${import_chalk11.default.bold(
              path7.join(".")
            )} for type ${import_chalk11.default.bold(error2.outputType ? error2.outputType.name : getInputTypeName(error2.originalType))}.`;
            if (error2.didYouMeanField) {
              str += `
\u2192 Did you forget to wrap it with \`${import_chalk11.default.greenBright("select")}\`? ${import_chalk11.default.dim(
                "e.g. " + import_chalk11.default.greenBright(`{ select: { ${error2.providedName}: ${error2.providedValue} } }`)
              )}`;
            } else if (error2.didYouMeanArg) {
              str += ` Did you mean \`${import_chalk11.default.greenBright(error2.didYouMeanArg)}\`?`;
              if (!hasMissingItems && !minimal) {
                str += ` ${import_chalk11.default.dim("Available args:")}
` + stringifyInputType(error2.originalType, true);
              }
            } else {
              if (error2.originalType.fields.length === 0) {
                str += ` The field ${import_chalk11.default.bold(error2.originalType.name)} has no arguments.`;
              } else if (!hasMissingItems && !minimal) {
                str += ` Available args:

` + stringifyInputType(error2.originalType, true);
              }
            }
            return str;
          }
          if (error2.type === "invalidType") {
            let valueStr = stringifyObject_default(error2.providedValue, { indent: "  " });
            const multilineValue = valueStr.split("\n").length > 1;
            if (multilineValue) {
              valueStr = `
${valueStr}
`;
            }
            if (error2.requiredType.bestFittingType.location === "enumTypes") {
              return `Argument ${import_chalk11.default.bold(error2.argName)}: Provided value ${import_chalk11.default.redBright(valueStr)}${multilineValue ? "" : " "}of type ${import_chalk11.default.redBright(getGraphQLType(error2.providedValue))} on ${import_chalk11.default.bold(
                `prisma.${this.children[0].name}`
              )} is not a ${import_chalk11.default.greenBright(
                wrapWithList(
                  stringifyGraphQLType(error2.requiredType.bestFittingType.type),
                  error2.requiredType.bestFittingType.isList
                )
              )}.
\u2192 Possible values: ${error2.requiredType.bestFittingType.type.values.map((v) => import_chalk11.default.greenBright(`${stringifyGraphQLType(error2.requiredType.bestFittingType.type)}.${v}`)).join(", ")}`;
            }
            let typeStr = ".";
            if (isInputArgType(error2.requiredType.bestFittingType.type)) {
              typeStr = ":\n" + stringifyInputType(error2.requiredType.bestFittingType.type);
            }
            let expected = `${error2.requiredType.inputType.map(
              (t) => import_chalk11.default.greenBright(wrapWithList(stringifyGraphQLType(t.type), error2.requiredType.bestFittingType.isList))
            ).join(" or ")}${typeStr}`;
            const inputType = error2.requiredType.inputType.length === 2 && error2.requiredType.inputType.find((t) => isInputArgType(t.type)) || null;
            if (inputType) {
              expected += `
` + stringifyInputType(inputType.type, true);
            }
            return `Argument ${import_chalk11.default.bold(error2.argName)}: Got invalid value ${import_chalk11.default.redBright(valueStr)}${multilineValue ? "" : " "}on ${import_chalk11.default.bold(`prisma.${this.children[0].name}`)}. Provided ${import_chalk11.default.redBright(
              getGraphQLType(error2.providedValue)
            )}, expected ${expected}`;
          }
          if (error2.type === "invalidNullArg") {
            const forStr = path7.length === 1 && path7[0] === error2.name ? "" : ` for ${import_chalk11.default.bold(`${path7.join(".")}`)}`;
            const undefinedTip = ` Please use ${import_chalk11.default.bold.greenBright("undefined")} instead.`;
            return `Argument ${import_chalk11.default.greenBright(error2.name)}${forStr} must not be ${import_chalk11.default.bold("null")}.${undefinedTip}`;
          }
          if (error2.type === "missingArg") {
            const forStr = path7.length === 1 && path7[0] === error2.missingName ? "" : ` for ${import_chalk11.default.bold(`${path7.join(".")}`)}`;
            return `Argument ${import_chalk11.default.greenBright(error2.missingName)}${forStr} is missing.`;
          }
          if (error2.type === "atLeastOne") {
            const additional = minimal ? "" : ` Available args are listed in ${import_chalk11.default.dim.green("green")}.`;
            const atLeastFieldsError = error2.atLeastFields ? ` and at least one argument for ${error2.atLeastFields.map((field) => import_chalk11.default.bold(field)).join(", or ")}` : "";
            return `Argument ${import_chalk11.default.bold(path7.join("."))} of type ${import_chalk11.default.bold(
              error2.inputType.name
            )} needs ${import_chalk11.default.greenBright("at least one")} argument${import_chalk11.default.bold(atLeastFieldsError)}.${additional}`;
          }
          if (error2.type === "atMostOne") {
            const additional = minimal ? "" : ` Please choose one. ${import_chalk11.default.dim("Available args:")} 
${stringifyInputType(error2.inputType, true)}`;
            return `Argument ${import_chalk11.default.bold(path7.join("."))} of type ${import_chalk11.default.bold(
              error2.inputType.name
            )} needs ${import_chalk11.default.greenBright("exactly one")} argument, but you provided ${error2.providedKeys.map((key) => import_chalk11.default.redBright(key)).join(" and ")}.${additional}`;
          }
          return void 0;
        }, "printArgError");
        this.type = type;
        this.children = children;
      }
      get [Symbol.toStringTag]() {
        return "Document";
      }
      toString() {
        return `${this.type} {
${(0, import_indent_string4.default)(this.children.map(String).join("\n"), tab)}
}`;
      }
      validate(select, isTopLevelQuery = false, originalMethod, errorFormat, validationCallsite) {
        var _a32;
        if (!select) {
          select = {};
        }
        const invalidChildren = this.children.filter((child) => child.hasInvalidChild || child.hasInvalidArg);
        if (invalidChildren.length === 0) {
          return;
        }
        const fieldErrors = [];
        const argErrors = [];
        const prefix = select && select.select ? "select" : select.include ? "include" : void 0;
        for (const child of invalidChildren) {
          const errors = child.collectErrors(prefix);
          fieldErrors.push(
            ...errors.fieldErrors.map((e) => ({
              ...e,
              path: isTopLevelQuery ? e.path : e.path.slice(1)
            }))
          );
          argErrors.push(
            ...errors.argErrors.map((e) => ({
              ...e,
              path: isTopLevelQuery ? e.path : e.path.slice(1)
            }))
          );
        }
        const topLevelQueryName = this.children[0].name;
        const queryName = isTopLevelQuery ? this.type : topLevelQueryName;
        const keyPaths = [];
        const valuePaths = [];
        const missingItems = [];
        for (const fieldError of fieldErrors) {
          const path7 = this.normalizePath(fieldError.path, select).join(".");
          if (fieldError.error.type === "invalidFieldName") {
            keyPaths.push(path7);
            const fieldType = fieldError.error.outputType;
            const { isInclude } = fieldError.error;
            fieldType.fields.filter((field) => isInclude ? field.outputType.location === "outputObjectTypes" : true).forEach((field) => {
              const splittedPath = path7.split(".");
              missingItems.push({
                path: `${splittedPath.slice(0, splittedPath.length - 1).join(".")}.${field.name}`,
                type: "true",
                isRequired: false
              });
            });
          } else if (fieldError.error.type === "includeAndSelect") {
            keyPaths.push("select");
            keyPaths.push("include");
          } else {
            valuePaths.push(path7);
          }
          if (fieldError.error.type === "emptySelect" || fieldError.error.type === "noTrueSelect" || fieldError.error.type === "emptyInclude") {
            const selectPathArray = this.normalizePath(fieldError.path, select);
            const selectPath = selectPathArray.slice(0, selectPathArray.length - 1).join(".");
            const fieldType = fieldError.error.field.outputType.type;
            (_a32 = fieldType.fields) == null ? void 0 : _a32.filter(
              (field) => fieldError.error.type === "emptyInclude" ? field.outputType.location === "outputObjectTypes" : true
            ).forEach((field) => {
              missingItems.push({
                path: `${selectPath}.${field.name}`,
                type: "true",
                isRequired: false
              });
            });
          }
        }
        for (const argError of argErrors) {
          const path7 = this.normalizePath(argError.path, select).join(".");
          if (argError.error.type === "invalidName") {
            keyPaths.push(path7);
          } else if (argError.error.type !== "missingArg" && argError.error.type !== "atLeastOne") {
            valuePaths.push(path7);
          } else if (argError.error.type === "missingArg") {
            const type = argError.error.missingArg.inputTypes.length === 1 ? argError.error.missingArg.inputTypes[0].type : argError.error.missingArg.inputTypes.map((t) => {
              const inputTypeName = getInputTypeName(t.type);
              if (inputTypeName === "Null") {
                return "null";
              }
              if (t.isList) {
                return inputTypeName + "[]";
              }
              return inputTypeName;
            }).join(" | ");
            missingItems.push({
              path: path7,
              type: inputTypeToJson(type, true, path7.split("where.").length === 2),
              isRequired: argError.error.missingArg.isRequired
            });
          }
        }
        const renderErrorStr = /* @__PURE__ */ __name((callsite) => {
          const hasRequiredMissingArgsErrors = argErrors.some(
            (e) => e.error.type === "missingArg" && e.error.missingArg.isRequired
          );
          const hasOptionalMissingArgsErrors = Boolean(
            argErrors.find((e) => e.error.type === "missingArg" && !e.error.missingArg.isRequired)
          );
          const hasMissingArgsErrors = hasOptionalMissingArgsErrors || hasRequiredMissingArgsErrors;
          let missingArgsLegend = "";
          if (hasRequiredMissingArgsErrors) {
            missingArgsLegend += `
${import_chalk11.default.dim("Note: Lines with ")}${import_chalk11.default.reset.greenBright("+")} ${import_chalk11.default.dim(
              "are required"
            )}`;
          }
          if (hasOptionalMissingArgsErrors) {
            if (missingArgsLegend.length === 0) {
              missingArgsLegend = "\n";
            }
            if (hasRequiredMissingArgsErrors) {
              missingArgsLegend += import_chalk11.default.dim(`, lines with ${import_chalk11.default.green("?")} are optional`);
            } else {
              missingArgsLegend += import_chalk11.default.dim(`Note: Lines with ${import_chalk11.default.green("?")} are optional`);
            }
            missingArgsLegend += import_chalk11.default.dim(".");
          }
          const relevantArgErrors = argErrors.filter((e) => e.error.type !== "missingArg" || e.error.missingArg.isRequired);
          let errorMessages = relevantArgErrors.map((e) => this.printArgError(e, hasMissingArgsErrors, errorFormat === "minimal")).join("\n");
          errorMessages += `
${fieldErrors.map((e) => this.printFieldError(e, missingItems, errorFormat === "minimal")).join("\n")}`;
          if (errorFormat === "minimal") {
            return (0, import_strip_ansi3.default)(errorMessages);
          }
          let printJsonArgs = {
            ast: isTopLevelQuery ? { [topLevelQueryName]: select } : select,
            keyPaths,
            valuePaths,
            missingItems
          };
          if (originalMethod == null ? void 0 : originalMethod.endsWith("aggregate")) {
            printJsonArgs = transformAggregatePrintJsonArgs(printJsonArgs);
          }
          const errorStr = createErrorMessageWithContext({
            callsite,
            originalMethod: originalMethod || queryName,
            showColors: errorFormat && errorFormat === "pretty",
            callArguments: printJsonWithErrors(printJsonArgs),
            message: `${errorMessages}${missingArgsLegend}
`
          });
          if (process.env.NO_COLOR || errorFormat === "colorless") {
            return (0, import_strip_ansi3.default)(errorStr);
          }
          return errorStr;
        }, "renderErrorStr");
        const error2 = new PrismaClientValidationError(renderErrorStr(validationCallsite));
        if (process.env.NODE_ENV !== "production") {
          Object.defineProperty(error2, "render", {
            get: () => renderErrorStr,
            enumerable: false
          });
        }
        throw error2;
      }
      normalizePath(inputPath, select) {
        const path7 = inputPath.slice();
        const newPath = [];
        let key;
        let pointer = select;
        while ((key = path7.shift()) !== void 0) {
          if (!Array.isArray(pointer) && key === 0) {
            continue;
          }
          if (key === "select") {
            if (!pointer[key]) {
              pointer = pointer.include;
            } else {
              pointer = pointer[key];
            }
          } else if (pointer && pointer[key]) {
            pointer = pointer[key];
          }
          newPath.push(key);
        }
        return newPath;
      }
    };
    __name(Document, "Document");
    var PrismaClientValidationError = class extends Error {
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    };
    __name(PrismaClientValidationError, "PrismaClientValidationError");
    var PrismaClientConstructorValidationError = class extends Error {
      constructor(message) {
        super(message + `
Read more at https://pris.ly/d/client-constructor`);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    };
    __name(PrismaClientConstructorValidationError, "PrismaClientConstructorValidationError");
    var Field = class {
      constructor({ name, args, children, error: error2, schemaField }) {
        this.name = name;
        this.args = args;
        this.children = children;
        this.error = error2;
        this.schemaField = schemaField;
        this.hasInvalidChild = children ? children.some((child) => Boolean(child.error || child.hasInvalidArg || child.hasInvalidChild)) : false;
        this.hasInvalidArg = args ? args.hasInvalidArg : false;
      }
      get [Symbol.toStringTag]() {
        return "Field";
      }
      toString() {
        let str = this.name;
        if (this.error) {
          return str + " # INVALID_FIELD";
        }
        if (this.args && this.args.args && this.args.args.length > 0) {
          if (this.args.args.length === 1) {
            str += `(${this.args.toString()})`;
          } else {
            str += `(
${(0, import_indent_string4.default)(this.args.toString(), tab)}
)`;
          }
        }
        if (this.children) {
          str += ` {
${(0, import_indent_string4.default)(this.children.map(String).join("\n"), tab)}
}`;
        }
        return str;
      }
      collectErrors(prefix = "select") {
        const fieldErrors = [];
        const argErrors = [];
        if (this.error) {
          fieldErrors.push({
            path: [this.name],
            error: this.error
          });
        }
        if (this.children) {
          for (const child of this.children) {
            const errors = child.collectErrors(prefix);
            fieldErrors.push(
              ...errors.fieldErrors.map((e) => ({
                ...e,
                path: [this.name, prefix, ...e.path]
              }))
            );
            argErrors.push(
              ...errors.argErrors.map((e) => ({
                ...e,
                path: [this.name, prefix, ...e.path]
              }))
            );
          }
        }
        if (this.args) {
          argErrors.push(...this.args.collectErrors().map((e) => ({ ...e, path: [this.name, ...e.path] })));
        }
        return {
          fieldErrors,
          argErrors
        };
      }
    };
    __name(Field, "Field");
    var Args = class {
      constructor(args = []) {
        this.args = args;
        this.hasInvalidArg = args ? args.some((arg2) => Boolean(arg2.hasError)) : false;
      }
      get [Symbol.toStringTag]() {
        return "Args";
      }
      toString() {
        if (this.args.length === 0) {
          return "";
        }
        return `${this.args.map((arg2) => arg2.toString()).filter((a) => a).join("\n")}`;
      }
      collectErrors() {
        if (!this.hasInvalidArg) {
          return [];
        }
        return this.args.flatMap((arg2) => arg2.collectErrors());
      }
    };
    __name(Args, "Args");
    function stringify(value, inputType) {
      if (Buffer.isBuffer(value)) {
        return JSON.stringify(value.toString("base64"));
      }
      if (value instanceof FieldRefImpl) {
        return `{ _ref: ${JSON.stringify(value.name)}}`;
      }
      if (Object.prototype.toString.call(value) === "[object BigInt]") {
        return value.toString();
      }
      if (typeof (inputType == null ? void 0 : inputType.type) === "string" && inputType.type === "Json") {
        if (value === null) {
          return "null";
        }
        if (value && value.values && value.__prismaRawParameters__) {
          return JSON.stringify(value.values);
        }
        if ((inputType == null ? void 0 : inputType.isList) && Array.isArray(value)) {
          return JSON.stringify(value.map((o) => JSON.stringify(o)));
        }
        return JSON.stringify(JSON.stringify(value));
      }
      if (value === void 0) {
        return null;
      }
      if (value === null) {
        return "null";
      }
      if (decimal_default.isDecimal(value) || (inputType == null ? void 0 : inputType.type) === "Decimal" && isDecimalJsLike(value)) {
        return stringifyDecimalJsLike(value);
      }
      if ((inputType == null ? void 0 : inputType.location) === "enumTypes" && typeof value === "string") {
        if (Array.isArray(value)) {
          return `[${value.join(", ")}]`;
        }
        return value;
      }
      if (typeof value === "number" && (inputType == null ? void 0 : inputType.type) === "Float") {
        return value.toExponential();
      }
      return JSON.stringify(value, null, 2);
    }
    __name(stringify, "stringify");
    var Arg2 = class {
      constructor({ key, value, isEnum = false, error: error2, schemaArg, inputType }) {
        this.inputType = inputType;
        this.key = key;
        this.value = value instanceof ObjectEnumValue ? value._getName() : value;
        this.isEnum = isEnum;
        this.error = error2;
        this.schemaArg = schemaArg;
        this.isNullable = (schemaArg == null ? void 0 : schemaArg.inputTypes.reduce((isNullable) => isNullable && schemaArg.isNullable, true)) || false;
        this.hasError = Boolean(error2) || (value instanceof Args ? value.hasInvalidArg : false) || Array.isArray(value) && value.some((v) => v instanceof Args ? v.hasInvalidArg : false);
      }
      get [Symbol.toStringTag]() {
        return "Arg";
      }
      _toString(value, key) {
        var _a32;
        if (typeof value === "undefined") {
          return void 0;
        }
        if (value instanceof Args) {
          return `${key}: {
${(0, import_indent_string4.default)(value.toString(), 2)}
}`;
        }
        if (Array.isArray(value)) {
          if (((_a32 = this.inputType) == null ? void 0 : _a32.type) === "Json") {
            return `${key}: ${stringify(value, this.inputType)}`;
          }
          const isScalar = !value.some((v) => typeof v === "object");
          return `${key}: [${isScalar ? "" : "\n"}${(0, import_indent_string4.default)(
            value.map((nestedValue) => {
              if (nestedValue instanceof Args) {
                return `{
${(0, import_indent_string4.default)(nestedValue.toString(), tab)}
}`;
              }
              return stringify(nestedValue, this.inputType);
            }).join(`,${isScalar ? " " : "\n"}`),
            isScalar ? 0 : tab
          )}${isScalar ? "" : "\n"}]`;
        }
        return `${key}: ${stringify(value, this.inputType)}`;
      }
      toString() {
        return this._toString(this.value, this.key);
      }
      collectErrors() {
        var _a32;
        if (!this.hasError) {
          return [];
        }
        const errors = [];
        if (this.error) {
          const id = typeof ((_a32 = this.inputType) == null ? void 0 : _a32.type) === "object" ? `${this.inputType.type.name}${this.inputType.isList ? "[]" : ""}` : void 0;
          errors.push({
            error: this.error,
            path: [this.key],
            id
          });
        }
        if (Array.isArray(this.value)) {
          return errors.concat(
            this.value.flatMap((val, index) => {
              if (!(val == null ? void 0 : val.collectErrors)) {
                return [];
              }
              return val.collectErrors().map((e) => {
                return { ...e, path: [this.key, index, ...e.path] };
              });
            })
          );
        }
        if (this.value instanceof Args) {
          return errors.concat(this.value.collectErrors().map((e) => ({ ...e, path: [this.key, ...e.path] })));
        }
        return errors;
      }
    };
    __name(Arg2, "Arg");
    function makeDocument({
      dmmf,
      rootTypeName,
      rootField,
      select,
      modelName,
      extensions
    }) {
      if (!select) {
        select = {};
      }
      const rootType = rootTypeName === "query" ? dmmf.queryType : dmmf.mutationType;
      const fakeRootField = {
        args: [],
        outputType: {
          isList: false,
          type: rootType,
          location: "outputObjectTypes"
        },
        name: rootTypeName
      };
      const context3 = {
        modelName
      };
      const children = selectionToFields({
        dmmf,
        selection: { [rootField]: select },
        schemaField: fakeRootField,
        path: [rootTypeName],
        context: context3,
        extensions
      });
      return new Document(rootTypeName, children);
    }
    __name(makeDocument, "makeDocument");
    function transformDocument(document2) {
      return document2;
    }
    __name(transformDocument, "transformDocument");
    function selectionToFields({
      dmmf,
      selection,
      schemaField,
      path: path7,
      context: context3,
      extensions
    }) {
      const outputType = schemaField.outputType.type;
      const computedFields = context3.modelName ? extensions.getAllComputedFields(context3.modelName) : {};
      selection = applyComputedFieldsToSelection(selection, computedFields);
      return Object.entries(selection).reduce((acc, [name, value]) => {
        const field = outputType.fieldMap ? outputType.fieldMap[name] : outputType.fields.find((f) => f.name === name);
        if (computedFields == null ? void 0 : computedFields[name]) {
          return acc;
        }
        if (!field) {
          acc.push(
            new Field({
              name,
              children: [],
              error: {
                type: "invalidFieldName",
                modelName: outputType.name,
                providedName: name,
                didYouMean: getSuggestion(
                  name,
                  outputType.fields.map((f) => f.name).concat(Object.keys(computedFields != null ? computedFields : {}))
                ),
                outputType
              }
            })
          );
          return acc;
        }
        if (field.outputType.location === "scalar" && field.args.length === 0 && typeof value !== "boolean") {
          acc.push(
            new Field({
              name,
              children: [],
              error: {
                type: "invalidFieldType",
                modelName: outputType.name,
                fieldName: name,
                providedValue: value
              }
            })
          );
          return acc;
        }
        if (value === false) {
          return acc;
        }
        const transformedField = {
          name: field.name,
          fields: field.args,
          constraints: {
            minNumFields: null,
            maxNumFields: null
          }
        };
        const argsWithoutIncludeAndSelect = typeof value === "object" ? omit2(value, ["include", "select"]) : void 0;
        const args = argsWithoutIncludeAndSelect ? objectToArgs(
          argsWithoutIncludeAndSelect,
          transformedField,
          context3,
          [],
          typeof field === "string" ? void 0 : field.outputType.type
        ) : void 0;
        const isRelation = field.outputType.location === "outputObjectTypes";
        if (value) {
          if (value.select && value.include) {
            acc.push(
              new Field({
                name,
                children: [
                  new Field({
                    name: "include",
                    args: new Args(),
                    error: {
                      type: "includeAndSelect",
                      field
                    }
                  })
                ]
              })
            );
          } else if (value.include) {
            const keys2 = Object.keys(value.include);
            if (keys2.length === 0) {
              acc.push(
                new Field({
                  name,
                  children: [
                    new Field({
                      name: "include",
                      args: new Args(),
                      error: {
                        type: "emptyInclude",
                        field
                      }
                    })
                  ]
                })
              );
              return acc;
            }
            if (field.outputType.location === "outputObjectTypes") {
              const fieldOutputType = field.outputType.type;
              const allowedKeys = fieldOutputType.fields.filter((f) => f.outputType.location === "outputObjectTypes").map((f) => f.name);
              const invalidKeys = keys2.filter((key) => !allowedKeys.includes(key));
              if (invalidKeys.length > 0) {
                acc.push(
                  ...invalidKeys.map(
                    (invalidKey) => new Field({
                      name: invalidKey,
                      children: [
                        new Field({
                          name: invalidKey,
                          args: new Args(),
                          error: {
                            type: "invalidFieldName",
                            modelName: fieldOutputType.name,
                            outputType: fieldOutputType,
                            providedName: invalidKey,
                            didYouMean: getSuggestion(invalidKey, allowedKeys) || void 0,
                            isInclude: true,
                            isIncludeScalar: fieldOutputType.fields.some((f) => f.name === invalidKey)
                          }
                        })
                      ]
                    })
                  )
                );
                return acc;
              }
            }
          } else if (value.select) {
            const values = Object.values(value.select);
            if (values.length === 0) {
              acc.push(
                new Field({
                  name,
                  children: [
                    new Field({
                      name: "select",
                      args: new Args(),
                      error: {
                        type: "emptySelect",
                        field
                      }
                    })
                  ]
                })
              );
              return acc;
            }
            const truthyValues = values.filter((v) => v);
            if (truthyValues.length === 0) {
              acc.push(
                new Field({
                  name,
                  children: [
                    new Field({
                      name: "select",
                      args: new Args(),
                      error: {
                        type: "noTrueSelect",
                        field
                      }
                    })
                  ]
                })
              );
              return acc;
            }
          }
        }
        const defaultSelection = isRelation ? getDefaultSelection(dmmf, field.outputType.type) : null;
        let select = defaultSelection;
        if (value) {
          if (value.select) {
            select = value.select;
          } else if (value.include) {
            select = deepExtend(defaultSelection, value.include);
          } else if (value.by && Array.isArray(value.by) && field.outputType.namespace === "prisma" && field.outputType.location === "outputObjectTypes" && isGroupByOutputName(field.outputType.type.name)) {
            select = byToSelect(value.by);
          }
        }
        let children;
        if (select !== false && isRelation) {
          let modelName = context3.modelName;
          if (typeof field.outputType.type === "object" && field.outputType.namespace === "model" && field.outputType.location === "outputObjectTypes") {
            modelName = field.outputType.type.name;
          }
          children = selectionToFields({
            dmmf,
            selection: select,
            schemaField: field,
            path: [...path7, name],
            context: { modelName },
            extensions
          });
        }
        acc.push(new Field({ name, args, children, schemaField: field }));
        return acc;
      }, []);
    }
    __name(selectionToFields, "selectionToFields");
    function byToSelect(by) {
      const obj = /* @__PURE__ */ Object.create(null);
      for (const b of by) {
        obj[b] = true;
      }
      return obj;
    }
    __name(byToSelect, "byToSelect");
    function getDefaultSelection(dmmf, outputType) {
      const acc = /* @__PURE__ */ Object.create(null);
      for (const f of outputType.fields) {
        if (dmmf.typeMap[f.outputType.type.name] !== void 0) {
          acc[f.name] = true;
        }
        if (f.outputType.location === "scalar" || f.outputType.location === "enumTypes") {
          acc[f.name] = true;
        }
      }
      return acc;
    }
    __name(getDefaultSelection, "getDefaultSelection");
    function getInvalidTypeArg(key, value, arg2, bestFittingType) {
      const arrg = new Arg2({
        key,
        value,
        isEnum: bestFittingType.location === "enumTypes",
        inputType: bestFittingType,
        error: {
          type: "invalidType",
          providedValue: value,
          argName: key,
          requiredType: {
            inputType: arg2.inputTypes,
            bestFittingType
          }
        }
      });
      return arrg;
    }
    __name(getInvalidTypeArg, "getInvalidTypeArg");
    function hasCorrectScalarType(value, inputType, context3) {
      const { isList } = inputType;
      const expectedType = getExpectedType(inputType, context3);
      const graphQLType = getGraphQLType(value, inputType);
      if (graphQLType === expectedType) {
        return true;
      }
      if (isList && graphQLType === "List<>") {
        return true;
      }
      if (expectedType === "Json" && graphQLType !== "Symbol" && !(value instanceof ObjectEnumValue) && !(value instanceof FieldRefImpl)) {
        return true;
      }
      if (graphQLType === "Int" && expectedType === "BigInt") {
        return true;
      }
      if ((graphQLType === "Int" || graphQLType === "Float") && expectedType === "Decimal") {
        return true;
      }
      if (graphQLType === "DateTime" && expectedType === "String") {
        return true;
      }
      if (graphQLType === "UUID" && expectedType === "String") {
        return true;
      }
      if (graphQLType === "String" && expectedType === "ID") {
        return true;
      }
      if (graphQLType === "Int" && expectedType === "Float") {
        return true;
      }
      if (graphQLType === "Int" && expectedType === "Long") {
        return true;
      }
      if (graphQLType === "String" && expectedType === "Decimal" && isDecimalString(value)) {
        return true;
      }
      if (value === null) {
        return true;
      }
      if (inputType.isList && Array.isArray(value)) {
        return value.every((v) => hasCorrectScalarType(v, { ...inputType, isList: false }, context3));
      }
      return false;
    }
    __name(hasCorrectScalarType, "hasCorrectScalarType");
    function getExpectedType(inputType, context3, isList = inputType.isList) {
      let type = stringifyGraphQLType(inputType.type);
      if (inputType.location === "fieldRefTypes" && context3.modelName) {
        type += `<${context3.modelName}>`;
      }
      return wrapWithList(type, isList);
    }
    __name(getExpectedType, "getExpectedType");
    var cleanObject = /* @__PURE__ */ __name((obj) => filterObject(obj, (k, v) => v !== void 0), "cleanObject");
    function isDecimalString(value) {
      return /^\-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i.test(value);
    }
    __name(isDecimalString, "isDecimalString");
    function valueToArg(key, value, arg2, context3) {
      let maybeArg = null;
      const argsWithErrors = [];
      for (const inputType of arg2.inputTypes) {
        maybeArg = tryInferArgs(key, value, arg2, inputType, context3);
        if ((maybeArg == null ? void 0 : maybeArg.collectErrors().length) === 0) {
          return maybeArg;
        }
        if (maybeArg && (maybeArg == null ? void 0 : maybeArg.collectErrors())) {
          const argErrors = maybeArg == null ? void 0 : maybeArg.collectErrors();
          if (argErrors && argErrors.length > 0) {
            argsWithErrors.push({ arg: maybeArg, errors: argErrors });
          }
        }
      }
      if ((maybeArg == null ? void 0 : maybeArg.hasError) && argsWithErrors.length > 0) {
        const argsWithScores = argsWithErrors.map(({ arg: arg3, errors }) => {
          const errorScores = errors.map((e) => {
            let score = 1;
            if (e.error.type === "invalidType") {
              score = 2 * Math.exp(getDepth(e.error.providedValue)) + 1;
            }
            score += Math.log(e.path.length);
            if (e.error.type === "missingArg") {
              if (arg3.inputType && isInputArgType(arg3.inputType.type) && arg3.inputType.type.name.includes("Unchecked")) {
                score *= 2;
              }
            }
            if (e.error.type === "invalidName") {
              if (isInputArgType(e.error.originalType)) {
                if (e.error.originalType.name.includes("Unchecked")) {
                  score *= 2;
                }
              }
            }
            return score;
          });
          return {
            score: errors.length + sum2(errorScores),
            arg: arg3,
            errors
          };
        });
        argsWithScores.sort((a, b) => a.score < b.score ? -1 : 1);
        return argsWithScores[0].arg;
      }
      return maybeArg;
    }
    __name(valueToArg, "valueToArg");
    function getDepth(object) {
      let level = 1;
      if (!object || typeof object !== "object") {
        return level;
      }
      for (const key in object) {
        if (!Object.prototype.hasOwnProperty.call(object, key)) {
          continue;
        }
        if (typeof object[key] === "object") {
          const depth = getDepth(object[key]) + 1;
          level = Math.max(depth, level);
        }
      }
      return level;
    }
    __name(getDepth, "getDepth");
    function sum2(n) {
      return n.reduce((acc, curr) => acc + curr, 0);
    }
    __name(sum2, "sum");
    function tryInferArgs(key, value, arg2, inputType, context3) {
      var _a32, _b22, _c2, _d2, _e;
      if (typeof value === "undefined") {
        if (!arg2.isRequired) {
          return null;
        }
        return new Arg2({
          key,
          value,
          isEnum: inputType.location === "enumTypes",
          inputType,
          error: {
            type: "missingArg",
            missingName: key,
            missingArg: arg2,
            atLeastOne: false,
            atMostOne: false
          }
        });
      }
      const { isNullable, isRequired } = arg2;
      if (value === null && !isNullable && !isRequired) {
        const isAtLeastOne = isInputArgType(inputType.type) ? inputType.type.constraints.minNumFields !== null && inputType.type.constraints.minNumFields > 0 : false;
        if (!isAtLeastOne) {
          return new Arg2({
            key,
            value,
            isEnum: inputType.location === "enumTypes",
            inputType,
            error: {
              type: "invalidNullArg",
              name: key,
              invalidType: arg2.inputTypes,
              atLeastOne: false,
              atMostOne: false
            }
          });
        }
      }
      if (!inputType.isList) {
        if (isInputArgType(inputType.type)) {
          if (typeof value !== "object" || Array.isArray(value) || inputType.location === "inputObjectTypes" && !isObject2(value)) {
            return getInvalidTypeArg(key, value, arg2, inputType);
          } else {
            const val = cleanObject(value);
            let error2;
            const keys2 = Object.keys(val || {});
            const numKeys = keys2.length;
            if (numKeys === 0 && typeof inputType.type.constraints.minNumFields === "number" && inputType.type.constraints.minNumFields > 0 || ((_a32 = inputType.type.constraints.fields) == null ? void 0 : _a32.some((field) => keys2.includes(field))) === false) {
              error2 = {
                type: "atLeastOne",
                key,
                inputType: inputType.type,
                atLeastFields: inputType.type.constraints.fields
              };
            } else if (numKeys > 1 && typeof inputType.type.constraints.maxNumFields === "number" && inputType.type.constraints.maxNumFields < 2) {
              error2 = {
                type: "atMostOne",
                key,
                inputType: inputType.type,
                providedKeys: keys2
              };
            }
            return new Arg2({
              key,
              value: val === null ? null : objectToArgs(val, inputType.type, context3, arg2.inputTypes),
              isEnum: inputType.location === "enumTypes",
              error: error2,
              inputType,
              schemaArg: arg2
            });
          }
        } else {
          return scalarToArg(key, value, arg2, inputType, context3);
        }
      }
      if (!Array.isArray(value) && inputType.isList) {
        if (key !== "updateMany") {
          value = [value];
        }
      }
      if (inputType.location === "enumTypes" || inputType.location === "scalar") {
        return scalarToArg(key, value, arg2, inputType, context3);
      }
      const argInputType = inputType.type;
      const hasAtLeastOneError = typeof ((_b22 = argInputType.constraints) == null ? void 0 : _b22.minNumFields) === "number" && ((_c2 = argInputType.constraints) == null ? void 0 : _c2.minNumFields) > 0 ? Array.isArray(value) && value.some((v) => !v || Object.keys(cleanObject(v)).length === 0) : false;
      let err = hasAtLeastOneError ? {
        inputType: argInputType,
        key,
        type: "atLeastOne"
      } : void 0;
      if (!err) {
        const hasOneOfError = typeof ((_d2 = argInputType.constraints) == null ? void 0 : _d2.maxNumFields) === "number" && ((_e = argInputType.constraints) == null ? void 0 : _e.maxNumFields) < 2 ? Array.isArray(value) && value.find((v) => !v || Object.keys(cleanObject(v)).length !== 1) : false;
        if (hasOneOfError) {
          err = {
            inputType: argInputType,
            key,
            type: "atMostOne",
            providedKeys: Object.keys(hasOneOfError)
          };
        }
      }
      if (!Array.isArray(value)) {
        for (const nestedArgInputType of arg2.inputTypes) {
          const args = objectToArgs(value, nestedArgInputType.type, context3);
          if (args.collectErrors().length === 0) {
            return new Arg2({
              key,
              value: args,
              isEnum: false,
              schemaArg: arg2,
              inputType: nestedArgInputType
            });
          }
        }
      }
      return new Arg2({
        key,
        value: value.map((v) => {
          if (inputType.isList && typeof v !== "object") {
            return v;
          }
          if (typeof v !== "object" || !value) {
            return getInvalidTypeArg(key, v, arg2, inputType);
          }
          return objectToArgs(v, argInputType, context3);
        }),
        isEnum: false,
        inputType,
        schemaArg: arg2,
        error: err
      });
    }
    __name(tryInferArgs, "tryInferArgs");
    function isInputArgType(argType) {
      if (typeof argType === "string") {
        return false;
      }
      if (Object.hasOwnProperty.call(argType, "values")) {
        return false;
      }
      return true;
    }
    __name(isInputArgType, "isInputArgType");
    function scalarToArg(key, value, arg2, inputType, context3) {
      if (hasCorrectScalarType(value, inputType, context3)) {
        return new Arg2({
          key,
          value,
          isEnum: inputType.location === "enumTypes",
          schemaArg: arg2,
          inputType
        });
      }
      return getInvalidTypeArg(key, value, arg2, inputType);
    }
    __name(scalarToArg, "scalarToArg");
    function objectToArgs(initialObj, inputType, context3, possibilities, outputType) {
      var _a32;
      if ((_a32 = inputType.meta) == null ? void 0 : _a32.source) {
        context3 = { modelName: inputType.meta.source };
      }
      const obj = cleanObject(initialObj);
      const { fields: args, fieldMap } = inputType;
      const requiredArgs = args.map((arg2) => [arg2.name, void 0]);
      const objEntries = Object.entries(obj || {});
      const entries2 = unionBy(objEntries, requiredArgs, (a) => a[0]);
      const argsList = entries2.reduce((acc, [argName, value]) => {
        const schemaArg = fieldMap ? fieldMap[argName] : args.find((a) => a.name === argName);
        if (!schemaArg) {
          const didYouMeanField = typeof value === "boolean" && outputType && outputType.fields.some((f) => f.name === argName) ? argName : null;
          acc.push(
            new Arg2({
              key: argName,
              value,
              error: {
                type: "invalidName",
                providedName: argName,
                providedValue: value,
                didYouMeanField,
                didYouMeanArg: !didYouMeanField && getSuggestion(argName, [...args.map((a) => a.name), "select"]) || void 0,
                originalType: inputType,
                possibilities,
                outputType
              }
            })
          );
          return acc;
        }
        const arg2 = valueToArg(argName, value, schemaArg, context3);
        if (arg2) {
          acc.push(arg2);
        }
        return acc;
      }, []);
      if (typeof inputType.constraints.minNumFields === "number" && objEntries.length < inputType.constraints.minNumFields || argsList.find((arg2) => {
        var _a4, _b22;
        return ((_a4 = arg2.error) == null ? void 0 : _a4.type) === "missingArg" || ((_b22 = arg2.error) == null ? void 0 : _b22.type) === "atLeastOne";
      })) {
        const optionalMissingArgs = inputType.fields.filter(
          (field) => !field.isRequired && obj && (typeof obj[field.name] === "undefined" || obj[field.name] === null)
        );
        argsList.push(
          ...optionalMissingArgs.map((arg2) => {
            const argInputType = arg2.inputTypes[0];
            return new Arg2({
              key: arg2.name,
              value: void 0,
              isEnum: argInputType.location === "enumTypes",
              error: {
                type: "missingArg",
                missingName: arg2.name,
                missingArg: arg2,
                atLeastOne: Boolean(inputType.constraints.minNumFields) || false,
                atMostOne: inputType.constraints.maxNumFields === 1 || false
              },
              inputType: argInputType
            });
          })
        );
      }
      return new Args(argsList);
    }
    __name(objectToArgs, "objectToArgs");
    function unpack({ document: document2, path: path7, data }) {
      const result = deepGet(data, path7);
      if (result === "undefined") {
        return null;
      }
      if (typeof result !== "object") {
        return result;
      }
      const field = getField(document2, path7);
      return mapScalars({ field, data: result });
    }
    __name(unpack, "unpack");
    function mapScalars({ field, data }) {
      var _a32;
      if (!data || typeof data !== "object" || !field.children || !field.schemaField) {
        return data;
      }
      const deserializers = {
        DateTime: (value) => new Date(value),
        Json: (value) => JSON.parse(value),
        Bytes: (value) => Buffer.from(value, "base64"),
        Decimal: (value) => {
          return new decimal_default(value);
        },
        BigInt: (value) => BigInt(value)
      };
      for (const child of field.children) {
        const outputType = (_a32 = child.schemaField) == null ? void 0 : _a32.outputType.type;
        if (outputType && typeof outputType === "string") {
          const deserializer = deserializers[outputType];
          if (deserializer) {
            if (Array.isArray(data)) {
              for (const entry of data) {
                if (typeof entry[child.name] !== "undefined" && entry[child.name] !== null) {
                  if (Array.isArray(entry[child.name])) {
                    entry[child.name] = entry[child.name].map(deserializer);
                  } else {
                    entry[child.name] = deserializer(entry[child.name]);
                  }
                }
              }
            } else {
              if (typeof data[child.name] !== "undefined" && data[child.name] !== null) {
                if (Array.isArray(data[child.name])) {
                  data[child.name] = data[child.name].map(deserializer);
                } else {
                  data[child.name] = deserializer(data[child.name]);
                }
              }
            }
          }
        }
        if (child.schemaField && child.schemaField.outputType.location === "outputObjectTypes") {
          if (Array.isArray(data)) {
            for (const entry of data) {
              mapScalars({ field: child, data: entry[child.name] });
            }
          } else {
            mapScalars({ field: child, data: data[child.name] });
          }
        }
      }
      return data;
    }
    __name(mapScalars, "mapScalars");
    function getField(document2, path7) {
      const todo = path7.slice();
      const firstElement = todo.shift();
      let pointer = document2.children.find((c) => c.name === firstElement);
      if (!pointer) {
        throw new Error(`Could not find field ${firstElement} in document ${document2}`);
      }
      while (todo.length > 0) {
        const key = todo.shift();
        if (!pointer.children) {
          throw new Error(`Can't get children for field ${pointer} with child ${key}`);
        }
        const child = pointer.children.find((c) => c.name === key);
        if (!child) {
          throw new Error(`Can't find child ${key} of field ${pointer}`);
        }
        pointer = child;
      }
      return pointer;
    }
    __name(getField, "getField");
    function removeSelectFromPath(path7) {
      return path7.split(".").filter((p) => p !== "select").join(".");
    }
    __name(removeSelectFromPath, "removeSelectFromPath");
    function removeSelectFromObject(obj) {
      const type = Object.prototype.toString.call(obj);
      if (type === "[object Object]") {
        const copy = {};
        for (const key in obj) {
          if (key === "select") {
            for (const subKey in obj["select"]) {
              copy[subKey] = removeSelectFromObject(obj["select"][subKey]);
            }
          } else {
            copy[key] = removeSelectFromObject(obj[key]);
          }
        }
        return copy;
      }
      return obj;
    }
    __name(removeSelectFromObject, "removeSelectFromObject");
    function transformAggregatePrintJsonArgs({
      ast,
      keyPaths,
      missingItems,
      valuePaths
    }) {
      const newKeyPaths = keyPaths.map(removeSelectFromPath);
      const newValuePaths = valuePaths.map(removeSelectFromPath);
      const newMissingItems = missingItems.map((item) => ({
        path: removeSelectFromPath(item.path),
        isRequired: item.isRequired,
        type: item.type
      }));
      const newAst = removeSelectFromObject(ast);
      return {
        ast: newAst,
        keyPaths: newKeyPaths,
        missingItems: newMissingItems,
        valuePaths: newValuePaths
      };
    }
    __name(transformAggregatePrintJsonArgs, "transformAggregatePrintJsonArgs");
    function addObjectProperties(object) {
      return {
        getKeys() {
          return Object.keys(object);
        },
        getPropertyValue(key) {
          return object[key];
        }
      };
    }
    __name(addObjectProperties, "addObjectProperties");
    function addProperty(key, factory) {
      return {
        getKeys() {
          return [key];
        },
        getPropertyValue() {
          return factory();
        }
      };
    }
    __name(addProperty, "addProperty");
    function cacheProperties(baseLayer) {
      const cache = new Cache();
      return {
        getKeys() {
          return baseLayer.getKeys();
        },
        getPropertyValue(key) {
          return cache.getOrCreate(key, () => baseLayer.getPropertyValue(key));
        },
        getPropertyDescriptor(key) {
          var _a32;
          return (_a32 = baseLayer.getPropertyDescriptor) == null ? void 0 : _a32.call(baseLayer, key);
        }
      };
    }
    __name(cacheProperties, "cacheProperties");
    var import_util7 = require("util");
    var defaultPropertyDescriptor = {
      enumerable: true,
      configurable: true,
      writable: true
    };
    function defaultProxyHandlers(ownKeys) {
      const _ownKeys = new Set(ownKeys);
      return {
        getOwnPropertyDescriptor: () => defaultPropertyDescriptor,
        has: (target, prop) => _ownKeys.has(prop),
        set: (target, prop, value) => {
          return _ownKeys.add(prop) && Reflect.set(target, prop, value);
        },
        ownKeys: () => [..._ownKeys]
      };
    }
    __name(defaultProxyHandlers, "defaultProxyHandlers");
    var customInspect = Symbol.for("nodejs.util.inspect.custom");
    function createCompositeProxy(target, layers) {
      const keysToLayerMap = mapKeysToLayers(layers);
      const overwrittenKeys = /* @__PURE__ */ new Set();
      const proxy = new Proxy(target, {
        get(target2, prop) {
          if (overwrittenKeys.has(prop)) {
            return target2[prop];
          }
          const layer = keysToLayerMap.get(prop);
          if (layer) {
            return layer.getPropertyValue(prop);
          }
          return target2[prop];
        },
        has(target2, prop) {
          var _a32, _b22;
          if (overwrittenKeys.has(prop)) {
            return true;
          }
          const layer = keysToLayerMap.get(prop);
          if (layer) {
            return (_b22 = (_a32 = layer.has) == null ? void 0 : _a32.call(layer, prop)) != null ? _b22 : true;
          }
          return Reflect.has(target2, prop);
        },
        ownKeys(target2) {
          const targetKeys = getExistingKeys(Reflect.ownKeys(target2), keysToLayerMap);
          const layerKeys = getExistingKeys(Array.from(keysToLayerMap.keys()), keysToLayerMap);
          return [.../* @__PURE__ */ new Set([...targetKeys, ...layerKeys, ...overwrittenKeys])];
        },
        set(target2, prop, value) {
          var _a32, _b22;
          const layer = keysToLayerMap.get(prop);
          if (((_b22 = (_a32 = layer == null ? void 0 : layer.getPropertyDescriptor) == null ? void 0 : _a32.call(layer, prop)) == null ? void 0 : _b22.writable) === false) {
            return false;
          }
          overwrittenKeys.add(prop);
          return Reflect.set(target2, prop, value);
        },
        getOwnPropertyDescriptor(target2, prop) {
          const layer = keysToLayerMap.get(prop);
          if (layer && layer.getPropertyDescriptor) {
            return {
              ...defaultPropertyDescriptor,
              ...layer.getPropertyDescriptor(prop)
            };
          }
          return defaultPropertyDescriptor;
        }
      });
      proxy[customInspect] = function(depth, options, defaultInspect = import_util7.inspect) {
        const toLog = { ...this };
        delete toLog[customInspect];
        return defaultInspect(toLog, options);
      };
      return proxy;
    }
    __name(createCompositeProxy, "createCompositeProxy");
    function mapKeysToLayers(layers) {
      const keysToLayerMap = /* @__PURE__ */ new Map();
      for (const layer of layers) {
        const keys2 = layer.getKeys();
        for (const key of keys2) {
          keysToLayerMap.set(key, layer);
        }
      }
      return keysToLayerMap;
    }
    __name(mapKeysToLayers, "mapKeysToLayers");
    function getExistingKeys(keys2, keysToLayerMap) {
      return keys2.filter((key) => {
        var _a32, _b22;
        const layer = keysToLayerMap.get(key);
        return (_b22 = (_a32 = layer == null ? void 0 : layer.has) == null ? void 0 : _a32.call(layer, key)) != null ? _b22 : true;
      });
    }
    __name(getExistingKeys, "getExistingKeys");
    function removeProperties(keys2) {
      return {
        getKeys() {
          return keys2;
        },
        has() {
          return false;
        },
        getPropertyValue() {
          return void 0;
        }
      };
    }
    __name(removeProperties, "removeProperties");
    var UNKNOWN_FUNCTION = "<unknown>";
    function parse(stackString) {
      var lines = stackString.split("\n");
      return lines.reduce(function(stack, line) {
        var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
        if (parseResult) {
          stack.push(parseResult);
        }
        return stack;
      }, []);
    }
    __name(parse, "parse");
    var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    function parseChrome(line) {
      var parts = chromeRe.exec(line);
      if (!parts) {
        return null;
      }
      var isNative = parts[2] && parts[2].indexOf("native") === 0;
      var isEval = parts[2] && parts[2].indexOf("eval") === 0;
      var submatch = chromeEvalRe.exec(parts[2]);
      if (isEval && submatch != null) {
        parts[2] = submatch[1];
        parts[3] = submatch[2];
        parts[4] = submatch[3];
      }
      return {
        file: !isNative ? parts[2] : null,
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: isNative ? [parts[2]] : [],
        lineNumber: parts[3] ? +parts[3] : null,
        column: parts[4] ? +parts[4] : null
      };
    }
    __name(parseChrome, "parseChrome");
    var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function parseWinjs(line) {
      var parts = winjsRe.exec(line);
      if (!parts) {
        return null;
      }
      return {
        file: parts[2],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[3],
        column: parts[4] ? +parts[4] : null
      };
    }
    __name(parseWinjs, "parseWinjs");
    var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    function parseGecko(line) {
      var parts = geckoRe.exec(line);
      if (!parts) {
        return null;
      }
      var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
      var submatch = geckoEvalRe.exec(parts[3]);
      if (isEval && submatch != null) {
        parts[3] = submatch[1];
        parts[4] = submatch[2];
        parts[5] = null;
      }
      return {
        file: parts[3],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: parts[2] ? parts[2].split(",") : [],
        lineNumber: parts[4] ? +parts[4] : null,
        column: parts[5] ? +parts[5] : null
      };
    }
    __name(parseGecko, "parseGecko");
    var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
    function parseJSC(line) {
      var parts = javaScriptCoreRe.exec(line);
      if (!parts) {
        return null;
      }
      return {
        file: parts[3],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[4],
        column: parts[5] ? +parts[5] : null
      };
    }
    __name(parseJSC, "parseJSC");
    var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function parseNode(line) {
      var parts = nodeRe.exec(line);
      if (!parts) {
        return null;
      }
      return {
        file: parts[2],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[3],
        column: parts[4] ? +parts[4] : null
      };
    }
    __name(parseNode, "parseNode");
    var DisabledCallSite = class {
      getLocation() {
        return null;
      }
    };
    __name(DisabledCallSite, "DisabledCallSite");
    var EnabledCallSite = class {
      constructor() {
        this._error = new Error();
      }
      getLocation() {
        const stack = this._error.stack;
        if (!stack) {
          return null;
        }
        const stackFrames = parse(stack);
        const frame = stackFrames.find((t) => {
          return t.file && t.file !== "<anonymous>" && !t.file.includes("@prisma") && !t.file.includes("getPrismaClient") && !t.file.startsWith("internal/") && !t.methodName.includes("new ") && !t.methodName.includes("getCallSite") && !t.methodName.includes("Proxy.") && t.methodName.split(".").length < 4;
        });
        if (!frame || !frame.file) {
          return null;
        }
        return {
          fileName: frame.file,
          lineNumber: frame.lineNumber,
          columnNumber: frame.column
        };
      }
    };
    __name(EnabledCallSite, "EnabledCallSite");
    function getCallSite(errorFormat) {
      if (errorFormat === "minimal") {
        return new DisabledCallSite();
      }
      return new EnabledCallSite();
    }
    __name(getCallSite, "getCallSite");
    function createPrismaPromise(callback) {
      let promise;
      const _callback = /* @__PURE__ */ __name((transaction, lock, cached = true) => {
        try {
          if (cached === true) {
            return promise != null ? promise : promise = valueToPromise(callback(transaction, lock));
          }
          return valueToPromise(callback(transaction, lock));
        } catch (error2) {
          return Promise.reject(error2);
        }
      }, "_callback");
      return {
        then(onFulfilled, onRejected, transaction) {
          return _callback(createItx(transaction), void 0).then(onFulfilled, onRejected, transaction);
        },
        catch(onRejected, transaction) {
          return _callback(createItx(transaction), void 0).catch(onRejected, transaction);
        },
        finally(onFinally, transaction) {
          return _callback(createItx(transaction), void 0).finally(onFinally, transaction);
        },
        requestTransaction(transactionOptions, lock) {
          const transaction = { kind: "batch", ...transactionOptions };
          const promise2 = _callback(transaction, lock, false);
          if (promise2.requestTransaction) {
            return promise2.requestTransaction(transaction, lock);
          }
          return promise2;
        },
        [Symbol.toStringTag]: "PrismaPromise"
      };
    }
    __name(createPrismaPromise, "createPrismaPromise");
    function createItx(transaction) {
      if (transaction) {
        return { kind: "itx", ...transaction };
      }
      return void 0;
    }
    __name(createItx, "createItx");
    function valueToPromise(thing) {
      if (typeof thing["then"] === "function") {
        return thing;
      }
      return Promise.resolve(thing);
    }
    __name(valueToPromise, "valueToPromise");
    var aggregateMap = {
      _avg: true,
      _count: true,
      _sum: true,
      _min: true,
      _max: true
    };
    function desugarUserArgs(args = {}) {
      const _args = desugarCountInUserArgs(args);
      const userArgsEntries = Object.entries(_args);
      return userArgsEntries.reduce(
        (aggregateArgs, [key, value]) => {
          if (aggregateMap[key] !== void 0) {
            aggregateArgs["select"][key] = { select: value };
          } else {
            aggregateArgs[key] = value;
          }
          return aggregateArgs;
        },
        { select: {} }
      );
    }
    __name(desugarUserArgs, "desugarUserArgs");
    function desugarCountInUserArgs(args = {}) {
      if (typeof args["_count"] === "boolean") {
        return { ...args, _count: { _all: args["_count"] } };
      }
      return args;
    }
    __name(desugarCountInUserArgs, "desugarCountInUserArgs");
    function createUnpacker(args = {}) {
      return (data) => {
        if (typeof args["_count"] === "boolean") {
          data["_count"] = data["_count"]["_all"];
        }
        return data;
      };
    }
    __name(createUnpacker, "createUnpacker");
    function aggregate(args, modelAction) {
      const aggregateUnpacker = createUnpacker(args);
      return modelAction({
        action: "aggregate",
        unpacker: aggregateUnpacker,
        argsMapper: desugarUserArgs
      })(args);
    }
    __name(aggregate, "aggregate");
    function desugarUserArgs2(args = {}) {
      const { select, ..._args } = args;
      if (typeof select === "object") {
        return desugarUserArgs({ ..._args, _count: select });
      } else {
        return desugarUserArgs({ ..._args, _count: { _all: true } });
      }
    }
    __name(desugarUserArgs2, "desugarUserArgs");
    function createUnpacker2(args = {}) {
      if (typeof args["select"] === "object") {
        return (data) => createUnpacker(args)(data)["_count"];
      } else {
        return (data) => createUnpacker(args)(data)["_count"]["_all"];
      }
    }
    __name(createUnpacker2, "createUnpacker");
    function count(args, modelAction) {
      return modelAction({
        action: "count",
        unpacker: createUnpacker2(args),
        argsMapper: desugarUserArgs2
      })(args);
    }
    __name(count, "count");
    function desugarUserArgs3(args = {}) {
      const _args = desugarUserArgs(args);
      if (Array.isArray(_args["by"])) {
        for (const key of _args["by"]) {
          if (typeof key === "string") {
            _args["select"][key] = true;
          }
        }
      }
      return _args;
    }
    __name(desugarUserArgs3, "desugarUserArgs");
    function createUnpacker3(args = {}) {
      return (data) => {
        if (typeof (args == null ? void 0 : args["_count"]) === "boolean") {
          data.forEach((row) => {
            row["_count"] = row["_count"]["_all"];
          });
        }
        return data;
      };
    }
    __name(createUnpacker3, "createUnpacker");
    function groupBy(args, modelAction) {
      return modelAction({
        action: "groupBy",
        unpacker: createUnpacker3(args),
        argsMapper: desugarUserArgs3
      })(args);
    }
    __name(groupBy, "groupBy");
    function applyAggregates(client2, action, modelAction) {
      if (action === "aggregate")
        return (userArgs) => aggregate(userArgs, modelAction);
      if (action === "count")
        return (userArgs) => count(userArgs, modelAction);
      if (action === "groupBy")
        return (userArgs) => groupBy(userArgs, modelAction);
      return void 0;
    }
    __name(applyAggregates, "applyAggregates");
    function applyFieldsProxy(model) {
      const scalarFieldsList = model.fields.filter((field) => !field.relationName);
      const scalarFields = keyBy(scalarFieldsList, (field) => field.name);
      return new Proxy(
        {},
        {
          get(target, prop) {
            if (prop in target || typeof prop === "symbol") {
              return target[prop];
            }
            const dmmfField = scalarFields[prop];
            if (dmmfField) {
              return new FieldRefImpl(model.name, prop, dmmfField.type, dmmfField.isList);
            }
            return void 0;
          },
          ...defaultProxyHandlers(Object.keys(scalarFields))
        }
      );
    }
    __name(applyFieldsProxy, "applyFieldsProxy");
    function getNextDataPath(fluentPropName, prevDataPath) {
      if (fluentPropName === void 0 || prevDataPath === void 0)
        return [];
      return [...prevDataPath, "select", fluentPropName];
    }
    __name(getNextDataPath, "getNextDataPath");
    function getNextUserArgs(callArgs, prevArgs, nextDataPath) {
      if (prevArgs === void 0)
        return callArgs != null ? callArgs : {};
      return deepSet(prevArgs, nextDataPath, callArgs || true);
    }
    __name(getNextUserArgs, "getNextUserArgs");
    function applyFluent(client2, dmmfModelName, modelAction, fluentPropName, prevDataPath, prevUserArgs) {
      const dmmfModel = client2._baseDmmf.modelMap[dmmfModelName];
      const dmmfModelFieldMap = dmmfModel.fields.reduce(
        (acc, field) => ({ ...acc, [field.name]: field }),
        {}
      );
      return (userArgs) => {
        const callsite = getCallSite(client2._errorFormat);
        const nextDataPath = getNextDataPath(fluentPropName, prevDataPath);
        const nextUserArgs = getNextUserArgs(userArgs, prevUserArgs, nextDataPath);
        const prismaPromise = modelAction({ dataPath: nextDataPath, callsite })(nextUserArgs);
        const ownKeys = getOwnKeys(client2, dmmfModelName);
        return new Proxy(prismaPromise, {
          get(target, prop) {
            if (!ownKeys.includes(prop))
              return target[prop];
            const dmmfModelName2 = dmmfModelFieldMap[prop].type;
            const modelArgs = [dmmfModelName2, modelAction, prop];
            const dataArgs = [nextDataPath, nextUserArgs];
            return applyFluent(client2, ...modelArgs, ...dataArgs);
          },
          ...defaultProxyHandlers([...ownKeys, ...Object.getOwnPropertyNames(prismaPromise)])
        });
      };
    }
    __name(applyFluent, "applyFluent");
    function getOwnKeys(client2, dmmfModelName) {
      return client2._baseDmmf.modelMap[dmmfModelName].fields.filter((field) => field.kind === "object").map((field) => field.name);
    }
    __name(getOwnKeys, "getOwnKeys");
    var clientVersion = require_package3().version;
    var NotFoundError2 = class extends PrismaClientKnownRequestError {
      constructor(message) {
        super(message, { code: "P2025", clientVersion });
        this.name = "NotFoundError";
      }
    };
    __name(NotFoundError2, "NotFoundError");
    function getRejectOnNotFound(action, modelName, args, clientInstance) {
      let rejectOnNotFound;
      if (args && typeof args === "object" && "rejectOnNotFound" in args && args["rejectOnNotFound"] !== void 0) {
        rejectOnNotFound = args["rejectOnNotFound"];
        delete args["rejectOnNotFound"];
      } else if (typeof clientInstance === "boolean") {
        rejectOnNotFound = clientInstance;
      } else if (clientInstance && typeof clientInstance === "object" && action in clientInstance) {
        const rejectPerOperation = clientInstance[action];
        if (rejectPerOperation && typeof rejectPerOperation === "object") {
          if (modelName in rejectPerOperation) {
            return rejectPerOperation[modelName];
          }
          return void 0;
        }
        rejectOnNotFound = getRejectOnNotFound(action, modelName, args, rejectPerOperation);
      } else if (typeof clientInstance === "function") {
        rejectOnNotFound = clientInstance;
      } else {
        rejectOnNotFound = false;
      }
      return rejectOnNotFound;
    }
    __name(getRejectOnNotFound, "getRejectOnNotFound");
    var REGEX = /(findUnique|findFirst)/;
    function throwIfNotFound(data, clientMethod, typeName, rejectOnNotFound) {
      if (rejectOnNotFound && !data && REGEX.exec(clientMethod)) {
        if (typeof rejectOnNotFound === "boolean" && rejectOnNotFound) {
          throw new NotFoundError2(`No ${typeName} found`);
        } else if (typeof rejectOnNotFound === "function") {
          throw rejectOnNotFound(new NotFoundError2(`No ${typeName} found`));
        } else if (isError(rejectOnNotFound)) {
          throw rejectOnNotFound;
        }
        throw new NotFoundError2(`No ${typeName} found`);
      }
    }
    __name(throwIfNotFound, "throwIfNotFound");
    function adaptErrors(action, dmmfModelName, requestCallback) {
      if (action === DMMF.ModelAction.findFirstOrThrow || action === DMMF.ModelAction.findUniqueOrThrow) {
        return applyOrThrowWrapper(dmmfModelName, requestCallback);
      }
      return requestCallback;
    }
    __name(adaptErrors, "adaptErrors");
    function applyOrThrowWrapper(dmmfModelName, requestCallback) {
      return async (requestParams) => {
        if ("rejectOnNotFound" in requestParams.args) {
          const message = createErrorMessageWithContext({
            originalMethod: requestParams.clientMethod,
            callsite: requestParams.callsite,
            message: "'rejectOnNotFound' option is not supported"
          });
          throw new PrismaClientValidationError(message);
        }
        const result = await requestCallback(requestParams).catch((e) => {
          if (e instanceof PrismaClientKnownRequestError && e.code === "P2025") {
            throw new NotFoundError2(`No ${dmmfModelName} found`);
          } else {
            throw e;
          }
        });
        return result;
      };
    }
    __name(applyOrThrowWrapper, "applyOrThrowWrapper");
    var fluentProps = [
      "findUnique",
      "findUniqueOrThrow",
      "findFirst",
      "findFirstOrThrow",
      "create",
      "update",
      "upsert",
      "delete"
    ];
    var aggregateProps = ["aggregate", "count", "groupBy"];
    function applyModel(client2, dmmfModelName) {
      var _a32;
      const layers = [modelActionsLayer(client2, dmmfModelName)];
      if ((_a32 = client2._engineConfig.previewFeatures) == null ? void 0 : _a32.includes("fieldReference")) {
        layers.push(fieldsPropertyLayer(client2, dmmfModelName));
      }
      const modelExtensions = client2._extensions.getAllModelExtensions(dmmfModelName);
      if (modelExtensions) {
        layers.push(addObjectProperties(modelExtensions));
      }
      return createCompositeProxy({}, layers);
    }
    __name(applyModel, "applyModel");
    function modelActionsLayer(client2, dmmfModelName) {
      const jsModelName = dmmfToJSModelName(dmmfModelName);
      const ownKeys = getOwnKeys2(client2, dmmfModelName);
      return {
        getKeys() {
          return ownKeys;
        },
        getPropertyValue(key) {
          const dmmfActionName = key;
          let requestFn = /* @__PURE__ */ __name((params) => client2._request(params), "requestFn");
          requestFn = adaptErrors(dmmfActionName, dmmfModelName, requestFn);
          const action = /* @__PURE__ */ __name((paramOverrides) => (userArgs) => {
            const callSite = getCallSite(client2._errorFormat);
            return createPrismaPromise((transaction, lock) => {
              const params = {
                args: userArgs,
                dataPath: [],
                action: dmmfActionName,
                model: dmmfModelName,
                clientMethod: `${jsModelName}.${key}`,
                jsModelName,
                transaction,
                lock,
                callsite: callSite
              };
              return requestFn({ ...params, ...paramOverrides });
            });
          }, "action");
          if (fluentProps.includes(dmmfActionName)) {
            return applyFluent(client2, dmmfModelName, action);
          }
          if (isValidAggregateName(key)) {
            return applyAggregates(client2, key, action);
          }
          return action({});
        }
      };
    }
    __name(modelActionsLayer, "modelActionsLayer");
    function getOwnKeys2(client2, dmmfModelName) {
      const actionKeys = Object.keys(client2._baseDmmf.mappingsMap[dmmfModelName]).filter(
        (key) => key !== "model" && key !== "plural"
      );
      actionKeys.push("count");
      return actionKeys;
    }
    __name(getOwnKeys2, "getOwnKeys");
    function isValidAggregateName(action) {
      return aggregateProps.includes(action);
    }
    __name(isValidAggregateName, "isValidAggregateName");
    function fieldsPropertyLayer(client2, dmmfModelName) {
      return cacheProperties(
        addProperty("fields", () => {
          const model = client2._baseDmmf.modelMap[dmmfModelName];
          return applyFieldsProxy(model);
        })
      );
    }
    __name(fieldsPropertyLayer, "fieldsPropertyLayer");
    function jsToDMMFModelName(name) {
      return name.replace(/^./, (str) => str.toUpperCase());
    }
    __name(jsToDMMFModelName, "jsToDMMFModelName");
    var rawClient = Symbol();
    function applyModelsAndClientExtensions(client2) {
      const layers = [modelsLayer(client2), addProperty(rawClient, () => client2)];
      const clientExtensions = client2._extensions.getAllClientExtensions();
      if (clientExtensions) {
        layers.push(addObjectProperties(clientExtensions));
      }
      return createCompositeProxy(client2, layers);
    }
    __name(applyModelsAndClientExtensions, "applyModelsAndClientExtensions");
    function modelsLayer(client2) {
      const dmmfModelKeys = Object.keys(client2._baseDmmf.modelMap);
      const jsModelKeys = dmmfModelKeys.map(dmmfToJSModelName);
      const allKeys = [...new Set(dmmfModelKeys.concat(jsModelKeys))];
      return cacheProperties({
        getKeys() {
          return allKeys;
        },
        getPropertyValue(prop) {
          const dmmfModelName = jsToDMMFModelName(prop);
          if (client2._baseDmmf.modelMap[dmmfModelName] !== void 0) {
            return applyModel(client2, dmmfModelName);
          }
          if (client2._baseDmmf.modelMap[prop] !== void 0) {
            return applyModel(client2, prop);
          }
          return void 0;
        },
        getPropertyDescriptor(key) {
          if (!jsModelKeys.includes(key)) {
            return { enumerable: false };
          }
          return void 0;
        }
      });
    }
    __name(modelsLayer, "modelsLayer");
    function unapplyModelsAndClientExtensions(client2) {
      if (client2[rawClient]) {
        return client2[rawClient];
      }
      return client2;
    }
    __name(unapplyModelsAndClientExtensions, "unapplyModelsAndClientExtensions");
    function $extends(extension) {
      if (!this._hasPreviewFlag("clientExtensions")) {
        throw new PrismaClientValidationError(
          "Extensions are not yet generally available, please add `clientExtensions` to the `previewFeatures` field in the `generator` block in the `schema.prisma` file."
        );
      }
      if (typeof extension === "function") {
        return extension(this);
      }
      const oldClient = unapplyModelsAndClientExtensions(this);
      const newClient = Object.create(oldClient, {
        _extensions: {
          value: this._extensions.append(extension)
        }
      });
      return applyModelsAndClientExtensions(newClient);
    }
    __name($extends, "$extends");
    function klona(x) {
      if (typeof x !== "object")
        return x;
      var k, tmp, str = Object.prototype.toString.call(x);
      if (str === "[object Object]") {
        if (x.constructor !== Object && typeof x.constructor === "function") {
          tmp = new x.constructor();
          for (k in x) {
            if (x.hasOwnProperty(k) && tmp[k] !== x[k]) {
              tmp[k] = klona(x[k]);
            }
          }
        } else {
          tmp = {};
          for (k in x) {
            if (k === "__proto__") {
              Object.defineProperty(tmp, k, {
                value: klona(x[k]),
                configurable: true,
                enumerable: true,
                writable: true
              });
            } else {
              tmp[k] = klona(x[k]);
            }
          }
        }
        return tmp;
      }
      if (str === "[object Array]") {
        k = x.length;
        for (tmp = Array(k); k--; ) {
          tmp[k] = klona(x[k]);
        }
        return tmp;
      }
      if (str === "[object Set]") {
        tmp = /* @__PURE__ */ new Set();
        x.forEach(function(val) {
          tmp.add(klona(val));
        });
        return tmp;
      }
      if (str === "[object Map]") {
        tmp = /* @__PURE__ */ new Map();
        x.forEach(function(val, key) {
          tmp.set(klona(key), klona(val));
        });
        return tmp;
      }
      if (str === "[object Date]") {
        return /* @__PURE__ */ new Date(+x);
      }
      if (str === "[object RegExp]") {
        tmp = new RegExp(x.source, x.flags);
        tmp.lastIndex = x.lastIndex;
        return tmp;
      }
      if (str === "[object DataView]") {
        return new x.constructor(klona(x.buffer));
      }
      if (str === "[object ArrayBuffer]") {
        return x.slice(0);
      }
      if (str.slice(-6) === "Array]") {
        return new x.constructor(x);
      }
      return x;
    }
    __name(klona, "klona");
    function iterateAndCallQueryCallbacks(client2, params, queryCbs, i = 0) {
      if (queryCbs.length === 0)
        return client2._executeRequest(params);
      return createPrismaPromise((transaction, lock) => {
        var _a32, _b22;
        if (transaction !== void 0) {
          void ((_a32 = params.lock) == null ? void 0 : _a32.then());
          params.transaction = transaction;
          params.lock = lock;
        }
        if (i === queryCbs.length) {
          return client2._executeRequest(params);
        }
        return queryCbs[i]({
          model: params.model,
          operation: params.action,
          args: klona((_b22 = params.args) != null ? _b22 : {}),
          query: (args) => {
            params.args = args;
            return iterateAndCallQueryCallbacks(client2, params, queryCbs, i + 1);
          }
        });
      });
    }
    __name(iterateAndCallQueryCallbacks, "iterateAndCallQueryCallbacks");
    function applyQueryExtensions(client2, params) {
      const { jsModelName, action } = params;
      if (jsModelName === void 0 || client2._extensions.isEmpty()) {
        return client2._executeRequest(params);
      }
      return iterateAndCallQueryCallbacks(client2, params, client2._extensions.getAllQueryCallbacks(jsModelName, action));
    }
    __name(applyQueryExtensions, "applyQueryExtensions");
    function lazyProperty(compute) {
      let resultContainer;
      return {
        get() {
          if (resultContainer) {
            return resultContainer.value;
          }
          resultContainer = { value: compute() };
          return resultContainer.value;
        }
      };
    }
    __name(lazyProperty, "lazyProperty");
    var MergedExtensionsListNode = class {
      constructor(extension, previous) {
        this.extension = extension;
        this.previous = previous;
        this.computedFieldsCache = new Cache();
        this.modelExtensionsCache = new Cache();
        this.queryCallbacksCache = new Cache();
        this.clientExtensions = lazyProperty(() => {
          var _a32, _b22;
          if (!this.extension.client) {
            return (_a32 = this.previous) == null ? void 0 : _a32.getAllClientExtensions();
          }
          return {
            ...(_b22 = this.previous) == null ? void 0 : _b22.getAllClientExtensions(),
            ...wrapAllExtensionCallbacks(this.extension.name, this.extension.client)
          };
        });
      }
      getAllComputedFields(dmmfModelName) {
        return this.computedFieldsCache.getOrCreate(dmmfModelName, () => {
          var _a32;
          return getComputedFields((_a32 = this.previous) == null ? void 0 : _a32.getAllComputedFields(dmmfModelName), this.extension, dmmfModelName);
        });
      }
      getAllClientExtensions() {
        return this.clientExtensions.get();
      }
      getAllModelExtensions(dmmfModelName) {
        return this.modelExtensionsCache.getOrCreate(dmmfModelName, () => {
          var _a32, _b22;
          const jsModelName = dmmfToJSModelName(dmmfModelName);
          if (!this.extension.model || !(this.extension.model[jsModelName] || this.extension.model.$allModels)) {
            return (_a32 = this.previous) == null ? void 0 : _a32.getAllModelExtensions(dmmfModelName);
          }
          return {
            ...(_b22 = this.previous) == null ? void 0 : _b22.getAllModelExtensions(dmmfModelName),
            ...wrapAllExtensionCallbacks(this.extension.name, this.extension.model.$allModels),
            ...wrapAllExtensionCallbacks(this.extension.name, this.extension.model[jsModelName])
          };
        });
      }
      getAllQueryCallbacks(jsModelName, action) {
        return this.queryCallbacksCache.getOrCreate(`${jsModelName}:${action}`, () => {
          var _a32, _b22;
          const previous = (_b22 = (_a32 = this.previous) == null ? void 0 : _a32.getAllQueryCallbacks(jsModelName, action)) != null ? _b22 : [];
          const query2 = this.extension.query;
          if (!query2 || !(query2[jsModelName] || query2.$allModels)) {
            return previous;
          }
          const newCallbacks = [];
          if (query2[jsModelName] !== void 0) {
            if (query2[jsModelName][action] !== void 0) {
              newCallbacks.push(query2[jsModelName][action]);
            }
            if (query2[jsModelName]["$allOperations"] !== void 0) {
              newCallbacks.push(query2[jsModelName]["$allOperations"]);
            }
          }
          if (query2["$allModels"] !== void 0) {
            if (query2["$allModels"][action] !== void 0) {
              newCallbacks.push(query2["$allModels"][action]);
            }
            if (query2["$allModels"]["$allOperations"] !== void 0) {
              newCallbacks.push(query2["$allModels"]["$allOperations"]);
            }
          }
          return previous.concat(newCallbacks.map((callback) => wrapExtensionCallback(this.extension.name, callback)));
        });
      }
    };
    __name(MergedExtensionsListNode, "MergedExtensionsListNode");
    var MergedExtensionsList = class {
      constructor(head) {
        this.head = head;
      }
      static empty() {
        return new MergedExtensionsList();
      }
      static single(extension) {
        return new MergedExtensionsList(new MergedExtensionsListNode(extension));
      }
      isEmpty() {
        return this.head === void 0;
      }
      append(extension) {
        return new MergedExtensionsList(new MergedExtensionsListNode(extension, this.head));
      }
      getAllComputedFields(dmmfModelName) {
        var _a32;
        return (_a32 = this.head) == null ? void 0 : _a32.getAllComputedFields(dmmfModelName);
      }
      getAllClientExtensions() {
        var _a32;
        return (_a32 = this.head) == null ? void 0 : _a32.getAllClientExtensions();
      }
      getAllModelExtensions(dmmfModelName) {
        var _a32;
        return (_a32 = this.head) == null ? void 0 : _a32.getAllModelExtensions(dmmfModelName);
      }
      getAllQueryCallbacks(jsModelName, action) {
        var _a32, _b22;
        return (_b22 = (_a32 = this.head) == null ? void 0 : _a32.getAllQueryCallbacks(jsModelName, action)) != null ? _b22 : [];
      }
    };
    __name(MergedExtensionsList, "MergedExtensionsList");
    function getLockCountPromise(knock, cb = () => {
    }) {
      let resolve;
      const lock = new Promise((res) => resolve = res);
      return {
        then(onFulfilled) {
          if (--knock === 0)
            resolve(cb());
          return onFulfilled == null ? void 0 : onFulfilled(lock);
        }
      };
    }
    __name(getLockCountPromise, "getLockCountPromise");
    function getLogLevel(log3) {
      if (typeof log3 === "string") {
        return log3;
      }
      return log3.reduce((acc, curr) => {
        const currentLevel = typeof curr === "string" ? curr : curr.level;
        if (currentLevel === "query") {
          return acc;
        }
        if (!acc) {
          return currentLevel;
        }
        if (curr === "info" || acc === "info") {
          return "info";
        }
        return currentLevel;
      }, void 0);
    }
    __name(getLogLevel, "getLogLevel");
    function mergeBy(arr1, arr2, cb) {
      const groupedArr1 = groupBy2(arr1, cb);
      const groupedArr2 = groupBy2(arr2, cb);
      const result = Object.values(groupedArr2).map((value) => value[value.length - 1]);
      const arr2Keys = Object.keys(groupedArr2);
      Object.entries(groupedArr1).forEach(([key, value]) => {
        if (!arr2Keys.includes(key)) {
          result.push(value[value.length - 1]);
        }
      });
      return result;
    }
    __name(mergeBy, "mergeBy");
    var groupBy2 = /* @__PURE__ */ __name((arr, cb) => {
      return arr.reduce((acc, curr) => {
        const key = cb(curr);
        if (!acc[key]) {
          acc[key] = [];
        }
        acc[key].push(curr);
        return acc;
      }, {});
    }, "groupBy");
    var MiddlewareHandler = class {
      constructor() {
        this._middlewares = [];
      }
      use(middleware) {
        this._middlewares.push(middleware);
      }
      get(id) {
        return this._middlewares[id];
      }
      has(id) {
        return !!this._middlewares[id];
      }
      length() {
        return this._middlewares.length;
      }
    };
    __name(MiddlewareHandler, "MiddlewareHandler");
    var Middlewares = class {
      constructor() {
        this.query = new MiddlewareHandler();
        this.engine = new MiddlewareHandler();
      }
    };
    __name(Middlewares, "Middlewares");
    var import_strip_ansi4 = __toESM(require_strip_ansi());
    function applyResultExtensions({ result, modelName, select, extensions }) {
      const computedFields = extensions.getAllComputedFields(modelName);
      if (!computedFields) {
        return result;
      }
      const computedPropertiesLayers = [];
      const maskingLayers = [];
      for (const field of Object.values(computedFields)) {
        if (select) {
          if (!select[field.name]) {
            continue;
          }
          const toMask = field.needs.filter((prop) => !select[prop]);
          if (toMask.length > 0) {
            maskingLayers.push(removeProperties(toMask));
          }
        }
        if (areNeedsMet(result, field.needs)) {
          computedPropertiesLayers.push(
            computedPropertyLayer(field, createCompositeProxy(result, computedPropertiesLayers))
          );
        }
      }
      if (computedPropertiesLayers.length > 0 || maskingLayers.length > 0) {
        return createCompositeProxy(result, [...computedPropertiesLayers, ...maskingLayers]);
      }
      return result;
    }
    __name(applyResultExtensions, "applyResultExtensions");
    function areNeedsMet(result, neededProperties) {
      return neededProperties.every((property) => hasOwnProperty2(result, property));
    }
    __name(areNeedsMet, "areNeedsMet");
    function computedPropertyLayer(field, result) {
      return cacheProperties(addProperty(field.name, () => field.compute(result)));
    }
    __name(computedPropertyLayer, "computedPropertyLayer");
    function visitQueryResult({ visitor, result, args, dmmf, model }) {
      var _a32;
      if (Array.isArray(result)) {
        for (let i = 0; i < result.length; i++) {
          result[i] = visitQueryResult({
            result: result[i],
            args,
            model,
            dmmf,
            visitor
          });
        }
        return result;
      }
      const visitResult = (_a32 = visitor(result, model, args)) != null ? _a32 : result;
      if (args.include) {
        visitNested({ includeOrSelect: args.include, result: visitResult, parentModel: model, dmmf, visitor });
      }
      if (args.select) {
        visitNested({ includeOrSelect: args.select, result: visitResult, parentModel: model, dmmf, visitor });
      }
      return visitResult;
    }
    __name(visitQueryResult, "visitQueryResult");
    function visitNested({ includeOrSelect, result, parentModel, dmmf, visitor }) {
      for (const [fieldName, subConfig] of Object.entries(includeOrSelect)) {
        if (!subConfig || result[fieldName] == null) {
          continue;
        }
        const field = parentModel.fields.find((field2) => field2.name === fieldName);
        if (!field || field.kind !== "object" || !field.relationName) {
          continue;
        }
        const args = typeof subConfig === "object" ? subConfig : {};
        result[fieldName] = visitQueryResult({
          visitor,
          result: result[fieldName],
          args,
          model: dmmf.getModelMap()[field.type],
          dmmf
        });
      }
    }
    __name(visitNested, "visitNested");
    var DataLoader = class {
      constructor(options) {
        this.options = options;
        this.tickActive = false;
        this.batches = {};
      }
      request(request2) {
        const hash = this.options.batchBy(request2);
        if (!hash) {
          return this.options.singleLoader(request2);
        }
        if (!this.batches[hash]) {
          this.batches[hash] = [];
          if (!this.tickActive) {
            this.tickActive = true;
            process.nextTick(() => {
              this.dispatchBatches();
              this.tickActive = false;
            });
          }
        }
        return new Promise((resolve, reject) => {
          this.batches[hash].push({
            request: request2,
            resolve,
            reject
          });
        });
      }
      dispatchBatches() {
        for (const key in this.batches) {
          const batch = this.batches[key];
          delete this.batches[key];
          if (batch.length === 1) {
            this.options.singleLoader(batch[0].request).then((result) => {
              if (result instanceof Error) {
                batch[0].reject(result);
              } else {
                batch[0].resolve(result);
              }
            }).catch((e) => {
              batch[0].reject(e);
            });
          } else {
            this.options.batchLoader(batch.map((j) => j.request)).then((results) => {
              if (results instanceof Error) {
                for (let i = 0; i < batch.length; i++) {
                  batch[i].reject(results);
                }
              } else {
                for (let i = 0; i < batch.length; i++) {
                  const value = results[i];
                  if (value instanceof Error) {
                    batch[i].reject(value);
                  } else {
                    batch[i].resolve(value);
                  }
                }
              }
            }).catch((e) => {
              for (let i = 0; i < batch.length; i++) {
                batch[i].reject(e);
              }
            });
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    };
    __name(DataLoader, "DataLoader");
    var debug11 = src_default("prisma:client:request_handler");
    function getRequestInfo(request2) {
      var _a32;
      const transaction = request2.transaction;
      const headers = (_a32 = request2.headers) != null ? _a32 : {};
      const traceparent = getTraceParent({ tracingConfig: request2.tracingConfig });
      if ((transaction == null ? void 0 : transaction.kind) === "itx") {
        headers.transactionId = transaction.id;
      }
      if (traceparent !== void 0) {
        headers.traceparent = traceparent;
      }
      return {
        transaction,
        headers
      };
    }
    __name(getRequestInfo, "getRequestInfo");
    var RequestHandler = class {
      constructor(client2, hooks, logEmitter) {
        this.logEmmitter = logEmitter;
        this.client = client2;
        this.hooks = hooks;
        this.dataloader = new DataLoader({
          batchLoader: (requests) => {
            var _a32;
            const info2 = getRequestInfo(requests[0]);
            const queries = requests.map((r) => String(r.document));
            const traceparent = getTraceParent({ context: requests[0].otelParentCtx, tracingConfig: client2._tracingConfig });
            if (traceparent)
              info2.headers.traceparent = traceparent;
            const containsWrite = requests.some((r) => r.document.type === "mutation");
            const batchTransaction = ((_a32 = info2.transaction) == null ? void 0 : _a32.kind) === "batch" ? info2.transaction : void 0;
            return this.client._engine.requestBatch({
              queries,
              headers: info2.headers,
              transaction: batchTransaction,
              containsWrite
            });
          },
          singleLoader: (request2) => {
            var _a32;
            const info2 = getRequestInfo(request2);
            const query2 = String(request2.document);
            const interactiveTransaction = ((_a32 = info2.transaction) == null ? void 0 : _a32.kind) === "itx" ? info2.transaction : void 0;
            return this.client._engine.request({
              query: query2,
              headers: info2.headers,
              transaction: interactiveTransaction,
              isWrite: request2.document.type === "mutation"
            });
          },
          batchBy: (request2) => {
            var _a32;
            if ((_a32 = request2.transaction) == null ? void 0 : _a32.id) {
              return `transaction-${request2.transaction.id}`;
            }
            return batchFindUniqueBy(request2);
          }
        });
      }
      async request({
        document: document2,
        dataPath = [],
        rootField,
        typeName,
        isList,
        callsite,
        rejectOnNotFound,
        clientMethod,
        engineHook,
        args,
        headers,
        transaction,
        unpacker,
        extensions,
        otelParentCtx,
        otelChildCtx
      }) {
        if (this.hooks && this.hooks.beforeRequest) {
          const query2 = String(document2);
          this.hooks.beforeRequest({
            query: query2,
            path: dataPath,
            rootField,
            typeName,
            document: document2,
            isList,
            clientMethod,
            args
          });
        }
        try {
          let data, elapsed;
          if (engineHook) {
            const result = await engineHook(
              {
                document: document2,
                runInTransaction: Boolean(transaction)
              },
              (params) => {
                return this.dataloader.request({ ...params, tracingConfig: this.client._tracingConfig });
              }
            );
            data = result.data;
            elapsed = result.elapsed;
          } else {
            const result = await this.dataloader.request({
              document: document2,
              headers,
              transaction,
              otelParentCtx,
              otelChildCtx,
              tracingConfig: this.client._tracingConfig
            });
            data = result == null ? void 0 : result.data;
            elapsed = result == null ? void 0 : result.elapsed;
          }
          const unpackResult = this.unpack(document2, data, dataPath, rootField, unpacker);
          throwIfNotFound(unpackResult, clientMethod, typeName, rejectOnNotFound);
          const extendedResult = this.applyResultExtensions({ result: unpackResult, modelName: typeName, args, extensions });
          if (process.env.PRISMA_CLIENT_GET_TIME) {
            return { data: extendedResult, elapsed };
          }
          return extendedResult;
        } catch (error2) {
          this.handleAndLogRequestError({ error: error2, clientMethod, callsite, transaction });
        }
      }
      handleAndLogRequestError({ error: error2, clientMethod, callsite, transaction }) {
        try {
          this.handleRequestError({ error: error2, clientMethod, callsite, transaction });
        } catch (err) {
          if (this.logEmmitter) {
            this.logEmmitter.emit("error", { message: err.message, target: clientMethod, timestamp: /* @__PURE__ */ new Date() });
          }
          throw err;
        }
      }
      handleRequestError({ error: error2, clientMethod, callsite, transaction }) {
        debug11(error2);
        if (isMismatchingBatchIndex(error2, transaction)) {
          throw error2;
        }
        if (error2 instanceof NotFoundError2) {
          throw error2;
        }
        let message = error2.message;
        if (callsite) {
          message = createErrorMessageWithContext({
            callsite,
            originalMethod: clientMethod,
            isPanic: error2.isPanic,
            showColors: this.client._errorFormat === "pretty",
            message
          });
        }
        message = this.sanitizeMessage(message);
        if (error2.code) {
          throw new PrismaClientKnownRequestError(message, {
            code: error2.code,
            clientVersion: this.client._clientVersion,
            meta: error2.meta,
            batchRequestIdx: error2.batchRequestIdx
          });
        } else if (error2.isPanic) {
          throw new PrismaClientRustPanicError(message, this.client._clientVersion);
        } else if (error2 instanceof PrismaClientUnknownRequestError) {
          throw new PrismaClientUnknownRequestError(message, {
            clientVersion: this.client._clientVersion,
            batchRequestIdx: error2.batchRequestIdx
          });
        } else if (error2 instanceof PrismaClientInitializationError) {
          throw new PrismaClientInitializationError(message, this.client._clientVersion);
        } else if (error2 instanceof PrismaClientRustPanicError) {
          throw new PrismaClientRustPanicError(message, this.client._clientVersion);
        }
        error2.clientVersion = this.client._clientVersion;
        throw error2;
      }
      sanitizeMessage(message) {
        if (this.client._errorFormat && this.client._errorFormat !== "pretty") {
          return (0, import_strip_ansi4.default)(message);
        }
        return message;
      }
      unpack(document2, data, path7, rootField, unpacker) {
        if (data == null ? void 0 : data.data) {
          data = data.data;
        }
        if (unpacker) {
          data[rootField] = unpacker(data[rootField]);
        }
        const getPath = [];
        if (rootField) {
          getPath.push(rootField);
        }
        getPath.push(...path7.filter((p) => p !== "select" && p !== "include"));
        return unpack({ document: document2, data, path: getPath });
      }
      applyResultExtensions({ result, modelName, args, extensions }) {
        if (extensions.isEmpty() || result == null) {
          return result;
        }
        const model = this.client._baseDmmf.getModelMap()[modelName];
        if (!model) {
          return result;
        }
        return visitQueryResult({
          result,
          args: args != null ? args : {},
          model,
          dmmf: this.client._baseDmmf,
          visitor(value, model2, args2) {
            const modelName2 = dmmfToJSModelName(model2.name);
            return applyResultExtensions({ result: value, modelName: modelName2, select: args2.select, extensions });
          }
        });
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    };
    __name(RequestHandler, "RequestHandler");
    function isMismatchingBatchIndex(error2, transaction) {
      return hasBatchIndex(error2) && (transaction == null ? void 0 : transaction.kind) === "batch" && error2.batchRequestIdx !== transaction.index;
    }
    __name(isMismatchingBatchIndex, "isMismatchingBatchIndex");
    function batchFindUniqueBy(request2) {
      var _a32;
      if (!request2.document.children[0].name.startsWith("findUnique")) {
        return void 0;
      }
      const args = (_a32 = request2.document.children[0].args) == null ? void 0 : _a32.args.map((a) => {
        if (a.value instanceof Args) {
          return `${a.key}-${a.value.args.map((a2) => a2.key).join(",")}`;
        }
        return a.key;
      }).join(",");
      const selectionSet = request2.document.children[0].children.join(",");
      return `${request2.document.children[0].name}|${args}|${selectionSet}`;
    }
    __name(batchFindUniqueBy, "batchFindUniqueBy");
    function deserializeRawResults(rows) {
      return rows.map((row) => {
        const mappedRow = {};
        for (const key of Object.keys(row)) {
          mappedRow[key] = deserializeValue(row[key]);
        }
        return mappedRow;
      });
    }
    __name(deserializeRawResults, "deserializeRawResults");
    function deserializeValue({ prisma__type: type, prisma__value: value }) {
      switch (type) {
        case "bigint":
          return BigInt(value);
        case "bytes":
          return Buffer.from(value, "base64");
        case "decimal":
          return new decimal_default(value);
        case "datetime":
        case "date":
          return new Date(value);
        case "time":
          return /* @__PURE__ */ new Date(`1970-01-01T${value}Z`);
        case "array":
          return value.map(deserializeValue);
        default:
          return value;
      }
    }
    __name(deserializeValue, "deserializeValue");
    var mssqlPreparedStatement = /* @__PURE__ */ __name((template) => {
      return template.reduce((acc, str, idx) => `${acc}@P${idx}${str}`);
    }, "mssqlPreparedStatement");
    function serializeRawParameters(parameters) {
      try {
        return serializeRawParametersInternal(parameters, "fast");
      } catch (error2) {
        return serializeRawParametersInternal(parameters, "slow");
      }
    }
    __name(serializeRawParameters, "serializeRawParameters");
    function serializeRawParametersInternal(parameters, objectSerialization) {
      return JSON.stringify(parameters.map((parameter) => encodeParameter(parameter, objectSerialization)));
    }
    __name(serializeRawParametersInternal, "serializeRawParametersInternal");
    function encodeParameter(parameter, objectSerialization) {
      if (typeof parameter === "bigint") {
        return {
          prisma__type: "bigint",
          prisma__value: parameter.toString()
        };
      }
      if (isDate(parameter)) {
        return {
          prisma__type: "date",
          prisma__value: parameter.toJSON()
        };
      }
      if (decimal_default.isDecimal(parameter)) {
        return {
          prisma__type: "decimal",
          prisma__value: parameter.toJSON()
        };
      }
      if (Buffer.isBuffer(parameter)) {
        return {
          prisma__type: "bytes",
          prisma__value: parameter.toString("base64")
        };
      }
      if (isArrayBufferLike(parameter) || ArrayBuffer.isView(parameter)) {
        return {
          prisma__type: "bytes",
          prisma__value: Buffer.from(parameter).toString("base64")
        };
      }
      if (typeof parameter === "object" && objectSerialization === "slow") {
        return preprocessObject(parameter);
      }
      return parameter;
    }
    __name(encodeParameter, "encodeParameter");
    function isDate(value) {
      if (value instanceof Date) {
        return true;
      }
      return Object.prototype.toString.call(value) === "[object Date]" && typeof value.toJSON === "function";
    }
    __name(isDate, "isDate");
    function isArrayBufferLike(value) {
      if (value instanceof ArrayBuffer || value instanceof SharedArrayBuffer) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        return value[Symbol.toStringTag] === "ArrayBuffer" || value[Symbol.toStringTag] === "SharedArrayBuffer";
      }
      return false;
    }
    __name(isArrayBufferLike, "isArrayBufferLike");
    function preprocessObject(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (typeof obj.toJSON === "function") {
        return obj.toJSON();
      }
      if (Array.isArray(obj)) {
        return obj.map(preprocessValueInObject);
      }
      const result = {};
      for (const key of Object.keys(obj)) {
        result[key] = preprocessValueInObject(obj[key]);
      }
      return result;
    }
    __name(preprocessObject, "preprocessObject");
    function preprocessValueInObject(value) {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return preprocessObject(value);
    }
    __name(preprocessValueInObject, "preprocessValueInObject");
    var import_js_levenshtein2 = __toESM(require_js_levenshtein());
    var knownProperties = ["datasources", "errorFormat", "log", "__internal", "rejectOnNotFound"];
    var errorFormats = ["pretty", "colorless", "minimal"];
    var logLevels = ["info", "query", "warn", "error"];
    var validators = {
      datasources: (options, datasourceNames) => {
        if (!options) {
          return;
        }
        if (typeof options !== "object" || Array.isArray(options)) {
          throw new PrismaClientConstructorValidationError(
            `Invalid value ${JSON.stringify(options)} for "datasources" provided to PrismaClient constructor`
          );
        }
        for (const [key, value] of Object.entries(options)) {
          if (!datasourceNames.includes(key)) {
            const didYouMean = getDidYouMean(key, datasourceNames) || `Available datasources: ${datasourceNames.join(", ")}`;
            throw new PrismaClientConstructorValidationError(
              `Unknown datasource ${key} provided to PrismaClient constructor.${didYouMean}`
            );
          }
          if (typeof value !== "object" || Array.isArray(value)) {
            throw new PrismaClientConstructorValidationError(
              `Invalid value ${JSON.stringify(options)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`
            );
          }
          if (value && typeof value === "object") {
            for (const [key1, value1] of Object.entries(value)) {
              if (key1 !== "url") {
                throw new PrismaClientConstructorValidationError(
                  `Invalid value ${JSON.stringify(options)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`
                );
              }
              if (typeof value1 !== "string") {
                throw new PrismaClientConstructorValidationError(
                  `Invalid value ${JSON.stringify(value1)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`
                );
              }
            }
          }
        }
      },
      errorFormat: (options) => {
        if (!options) {
          return;
        }
        if (typeof options !== "string") {
          throw new PrismaClientConstructorValidationError(
            `Invalid value ${JSON.stringify(options)} for "errorFormat" provided to PrismaClient constructor.`
          );
        }
        if (!errorFormats.includes(options)) {
          const didYouMean = getDidYouMean(options, errorFormats);
          throw new PrismaClientConstructorValidationError(
            `Invalid errorFormat ${options} provided to PrismaClient constructor.${didYouMean}`
          );
        }
      },
      log: (options) => {
        if (!options) {
          return;
        }
        if (!Array.isArray(options)) {
          throw new PrismaClientConstructorValidationError(
            `Invalid value ${JSON.stringify(options)} for "log" provided to PrismaClient constructor.`
          );
        }
        function validateLogLevel(level) {
          if (typeof level === "string") {
            if (!logLevels.includes(level)) {
              const didYouMean = getDidYouMean(level, logLevels);
              throw new PrismaClientConstructorValidationError(
                `Invalid log level "${level}" provided to PrismaClient constructor.${didYouMean}`
              );
            }
          }
        }
        __name(validateLogLevel, "validateLogLevel");
        for (const option of options) {
          validateLogLevel(option);
          const logValidators = {
            level: validateLogLevel,
            emit: (value) => {
              const emits = ["stdout", "event"];
              if (!emits.includes(value)) {
                const didYouMean = getDidYouMean(value, emits);
                throw new PrismaClientConstructorValidationError(
                  `Invalid value ${JSON.stringify(
                    value
                  )} for "emit" in logLevel provided to PrismaClient constructor.${didYouMean}`
                );
              }
            }
          };
          if (option && typeof option === "object") {
            for (const [key, value] of Object.entries(option)) {
              if (logValidators[key]) {
                logValidators[key](value);
              } else {
                throw new PrismaClientConstructorValidationError(
                  `Invalid property ${key} for "log" provided to PrismaClient constructor`
                );
              }
            }
          }
        }
      },
      __internal: (value) => {
        if (!value) {
          return;
        }
        const knownKeys = ["debug", "hooks", "engine", "measurePerformance"];
        if (typeof value !== "object") {
          throw new PrismaClientConstructorValidationError(
            `Invalid value ${JSON.stringify(value)} for "__internal" to PrismaClient constructor`
          );
        }
        for (const [key] of Object.entries(value)) {
          if (!knownKeys.includes(key)) {
            const didYouMean = getDidYouMean(key, knownKeys);
            throw new PrismaClientConstructorValidationError(
              `Invalid property ${JSON.stringify(key)} for "__internal" provided to PrismaClient constructor.${didYouMean}`
            );
          }
        }
      },
      rejectOnNotFound: (value) => {
        if (!value) {
          return;
        }
        if (isError(value) || typeof value === "boolean" || typeof value === "object" || typeof value === "function") {
          return value;
        }
        throw new PrismaClientConstructorValidationError(
          `Invalid rejectOnNotFound expected a boolean/Error/{[modelName: Error | boolean]} but received ${JSON.stringify(
            value
          )}`
        );
      }
    };
    function validatePrismaClientOptions(options, datasourceNames) {
      for (const [key, value] of Object.entries(options)) {
        if (!knownProperties.includes(key)) {
          const didYouMean = getDidYouMean(key, knownProperties);
          throw new PrismaClientConstructorValidationError(
            `Unknown property ${key} provided to PrismaClient constructor.${didYouMean}`
          );
        }
        validators[key](value, datasourceNames);
      }
    }
    __name(validatePrismaClientOptions, "validatePrismaClientOptions");
    function getDidYouMean(str, options) {
      if (options.length === 0) {
        return "";
      }
      if (typeof str !== "string") {
        return "";
      }
      const alternative = getAlternative(str, options);
      if (!alternative) {
        return "";
      }
      return ` Did you mean "${alternative}"?`;
    }
    __name(getDidYouMean, "getDidYouMean");
    function getAlternative(str, options) {
      if (options.length === 0) {
        return null;
      }
      const optionsWithDistances = options.map((value) => ({
        value,
        distance: (0, import_js_levenshtein2.default)(str, value)
      }));
      optionsWithDistances.sort((a, b) => {
        return a.distance < b.distance ? -1 : 1;
      });
      const bestAlternative = optionsWithDistances[0];
      if (bestAlternative.distance < 3) {
        return bestAlternative.value;
      }
      return null;
    }
    __name(getAlternative, "getAlternative");
    function waitForBatch(promises) {
      if (promises.length === 0) {
        return Promise.resolve([]);
      }
      return new Promise((resolve, reject) => {
        const successfulResults = new Array(promises.length);
        let bestError = null;
        let done = false;
        let settledPromisesCount = 0;
        const settleOnePromise = /* @__PURE__ */ __name(() => {
          if (done) {
            return;
          }
          settledPromisesCount++;
          if (settledPromisesCount === promises.length) {
            done = true;
            if (bestError) {
              reject(bestError);
            } else {
              resolve(successfulResults);
            }
          }
        }, "settleOnePromise");
        const immediatelyReject = /* @__PURE__ */ __name((error2) => {
          if (!done) {
            done = true;
            reject(error2);
          }
        }, "immediatelyReject");
        for (let i = 0; i < promises.length; i++) {
          promises[i].then(
            (result) => {
              successfulResults[i] = result;
              settleOnePromise();
            },
            (error2) => {
              if (!hasBatchIndex(error2)) {
                immediatelyReject(error2);
                return;
              }
              if (error2.batchRequestIdx === i) {
                immediatelyReject(error2);
              } else {
                if (!bestError) {
                  bestError = error2;
                }
                settleOnePromise();
              }
            }
          );
        }
      });
    }
    __name(waitForBatch, "waitForBatch");
    var debug12 = src_default("prisma:client");
    var ALTER_RE = /^(\s*alter\s)/i;
    typeof globalThis === "object" ? globalThis.NODE_CLIENT = true : 0;
    function isReadonlyArray(arg2) {
      return Array.isArray(arg2);
    }
    __name(isReadonlyArray, "isReadonlyArray");
    function checkAlter(query2, values, invalidCall) {
      if (values.length > 0 && ALTER_RE.exec(query2)) {
        throw new Error(`Running ALTER using ${invalidCall} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
      }
    }
    __name(checkAlter, "checkAlter");
    var actionOperationMap = {
      findUnique: "query",
      findUniqueOrThrow: "query",
      findFirst: "query",
      findFirstOrThrow: "query",
      findMany: "query",
      count: "query",
      create: "mutation",
      createMany: "mutation",
      update: "mutation",
      updateMany: "mutation",
      upsert: "mutation",
      delete: "mutation",
      deleteMany: "mutation",
      executeRaw: "mutation",
      queryRaw: "mutation",
      aggregate: "query",
      groupBy: "query",
      runCommandRaw: "mutation",
      findRaw: "query",
      aggregateRaw: "query"
    };
    var TX_ID = Symbol.for("prisma.client.transaction.id");
    var BatchTxIdCounter = {
      id: 0,
      nextId() {
        return ++this.id;
      }
    };
    function getPrismaClient(config2) {
      class PrismaClient2 {
        constructor(optionsArg) {
          this._middlewares = new Middlewares();
          this._getDmmf = callOnce(async (params) => {
            try {
              const dmmf = await this._engine.getDmmf();
              return new DMMFHelper(getPrismaClientDMMF(dmmf));
            } catch (error2) {
              this._fetcher.handleAndLogRequestError({ ...params, error: error2 });
            }
          });
          this.$extends = $extends;
          var _a32, _b22, _c2, _d2, _e, _f, _g, _h, _i;
          if (optionsArg) {
            validatePrismaClientOptions(optionsArg, config2.datasourceNames);
          }
          const logEmitter = new import_events.EventEmitter().on("error", (e) => {
          });
          this._extensions = MergedExtensionsList.empty();
          this._previewFeatures = (_b22 = (_a32 = config2.generator) == null ? void 0 : _a32.previewFeatures) != null ? _b22 : [];
          this._rejectOnNotFound = optionsArg == null ? void 0 : optionsArg.rejectOnNotFound;
          this._clientVersion = (_c2 = config2.clientVersion) != null ? _c2 : clientVersion;
          this._activeProvider = config2.activeProvider;
          this._dataProxy = config2.dataProxy;
          this._tracingConfig = getTracingConfig(this._previewFeatures);
          this._clientEngineType = getClientEngineType(config2.generator);
          const envPaths = {
            rootEnvPath: config2.relativeEnvPaths.rootEnvPath && import_path5.default.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
            schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && import_path5.default.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
          };
          const loadedEnv = tryLoadEnvs(envPaths, { conflictCheck: "none" });
          try {
            const options = optionsArg != null ? optionsArg : {};
            const internal = (_d2 = options.__internal) != null ? _d2 : {};
            const useDebug = internal.debug === true;
            if (useDebug) {
              src_default.enable("prisma:client");
            }
            if (internal.hooks) {
              this._hooks = internal.hooks;
            }
            let cwd = import_path5.default.resolve(config2.dirname, config2.relativePath);
            if (!import_fs9.default.existsSync(cwd)) {
              cwd = config2.dirname;
            }
            debug12("dirname", config2.dirname);
            debug12("relativePath", config2.relativePath);
            debug12("cwd", cwd);
            const thedatasources = options.datasources || {};
            const inputDatasources = Object.entries(thedatasources).filter(([_, source]) => {
              return source && source.url;
            }).map(([name, { url: url2 }]) => ({
              name,
              url: url2
            }));
            const datasources = mergeBy([], inputDatasources, (source) => source.name);
            const engineConfig = internal.engine || {};
            if (options.errorFormat) {
              this._errorFormat = options.errorFormat;
            } else if (process.env.NODE_ENV === "production") {
              this._errorFormat = "minimal";
            } else if (process.env.NO_COLOR) {
              this._errorFormat = "colorless";
            } else {
              this._errorFormat = "colorless";
            }
            this._baseDmmf = new BaseDMMFHelper(config2.document);
            if (this._dataProxy) {
              const rawDmmf = config2.document;
              this._dmmf = new DMMFHelper(rawDmmf);
            }
            this._engineConfig = {
              cwd,
              dirname: config2.dirname,
              enableDebugLogs: useDebug,
              allowTriggerPanic: engineConfig.allowTriggerPanic,
              datamodelPath: import_path5.default.join(config2.dirname, (_e = config2.filename) != null ? _e : "schema.prisma"),
              prismaPath: (_f = engineConfig.binaryPath) != null ? _f : void 0,
              engineEndpoint: engineConfig.endpoint,
              datasources,
              generator: config2.generator,
              showColors: this._errorFormat === "pretty",
              logLevel: options.log && getLogLevel(options.log),
              logQueries: options.log && Boolean(
                typeof options.log === "string" ? options.log === "query" : options.log.find((o) => typeof o === "string" ? o === "query" : o.level === "query")
              ),
              env: (_i = (_h = loadedEnv == null ? void 0 : loadedEnv.parsed) != null ? _h : (_g = config2.injectableEdgeEnv) == null ? void 0 : _g.parsed) != null ? _i : {},
              flags: [],
              clientVersion: config2.clientVersion,
              previewFeatures: this._previewFeatures,
              activeProvider: config2.activeProvider,
              inlineSchema: config2.inlineSchema,
              inlineDatasources: config2.inlineDatasources,
              inlineSchemaHash: config2.inlineSchemaHash,
              tracingConfig: this._tracingConfig,
              logEmitter
            };
            debug12("clientVersion", config2.clientVersion);
            debug12("clientEngineType", this._dataProxy ? "dataproxy" : this._clientEngineType);
            if (this._dataProxy) {
              const runtime = true ? "Node.js" : "edge";
              debug12(`using Data Proxy with ${runtime} runtime`);
            }
            this._engine = this.getEngine();
            void this._getActiveProvider();
            this._fetcher = new RequestHandler(this, this._hooks, logEmitter);
            if (options.log) {
              for (const log3 of options.log) {
                const level = typeof log3 === "string" ? log3 : log3.emit === "stdout" ? log3.level : null;
                if (level) {
                  this.$on(level, (event) => {
                    var _a4;
                    logger_exports.log(`${(_a4 = logger_exports.tags[level]) != null ? _a4 : ""}`, event.message || event.query);
                  });
                }
              }
            }
            this._metrics = new MetricsClient(this._engine);
          } catch (e) {
            e.clientVersion = this._clientVersion;
            throw e;
          }
          return applyModelsAndClientExtensions(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        getEngine() {
          if (this._dataProxy === true) {
            return new DataProxyEngine(this._engineConfig);
          } else if (this._clientEngineType === "library") {
            return new LibraryEngine(this._engineConfig);
          } else if (this._clientEngineType === "binary") {
            return new BinaryEngine(this._engineConfig);
          }
          throw new PrismaClientValidationError("Invalid client engine type, please use `library` or `binary`");
        }
        $use(arg0, arg1) {
          if (typeof arg0 === "function") {
            this._middlewares.query.use(arg0);
          } else if (arg0 === "all") {
            this._middlewares.query.use(arg1);
          } else if (arg0 === "engine") {
            this._middlewares.engine.use(arg1);
          } else {
            throw new Error(`Invalid middleware ${arg0}`);
          }
        }
        $on(eventType, callback) {
          if (eventType === "beforeExit") {
            this._engine.on("beforeExit", callback);
          } else {
            this._engine.on(eventType, (event) => {
              var _a32, _b22, _c2, _d2;
              const fields = event.fields;
              if (eventType === "query") {
                return callback({
                  timestamp: event.timestamp,
                  query: (_a32 = fields == null ? void 0 : fields.query) != null ? _a32 : event.query,
                  params: (_b22 = fields == null ? void 0 : fields.params) != null ? _b22 : event.params,
                  duration: (_c2 = fields == null ? void 0 : fields.duration_ms) != null ? _c2 : event.duration,
                  target: event.target
                });
              } else {
                return callback({
                  timestamp: event.timestamp,
                  message: (_d2 = fields == null ? void 0 : fields.message) != null ? _d2 : event.message,
                  target: event.target
                });
              }
            });
          }
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (e) {
            e.clientVersion = this._clientVersion;
            throw e;
          }
        }
        async _runDisconnect() {
          await this._engine.stop();
          delete this._connectionPromise;
          this._engine = this.getEngine();
          delete this._disconnectionPromise;
          delete this._getConfigPromise;
        }
        async $disconnect() {
          try {
            await this._engine.stop();
          } catch (e) {
            e.clientVersion = this._clientVersion;
            throw e;
          } finally {
            if (!this._dataProxy) {
              this._dmmf = void 0;
            }
          }
        }
        async _getActiveProvider() {
          try {
            const configResult = await this._engine.getConfig();
            this._activeProvider = configResult.datasources[0].activeProvider;
          } catch (e) {
          }
        }
        $executeRawInternal(transaction, lock, query2, ...values) {
          let queryString = "";
          let parameters = void 0;
          if (typeof query2 === "string") {
            queryString = query2;
            parameters = {
              values: serializeRawParameters(values || []),
              __prismaRawParameters__: true
            };
            checkAlter(queryString, values, "prisma.$executeRawUnsafe(<SQL>, [...values])");
          } else if (isReadonlyArray(query2)) {
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql": {
                const queryInstance = new Sql(query2, values);
                queryString = queryInstance.sql;
                parameters = {
                  values: serializeRawParameters(queryInstance.values),
                  __prismaRawParameters__: true
                };
                break;
              }
              case "cockroachdb":
              case "postgresql": {
                const queryInstance = new Sql(query2, values);
                queryString = queryInstance.text;
                checkAlter(queryString, queryInstance.values, "prisma.$executeRaw`<SQL>`");
                parameters = {
                  values: serializeRawParameters(queryInstance.values),
                  __prismaRawParameters__: true
                };
                break;
              }
              case "sqlserver": {
                queryString = mssqlPreparedStatement(query2);
                parameters = {
                  values: serializeRawParameters(values),
                  __prismaRawParameters__: true
                };
                break;
              }
              default: {
                throw new Error(`The ${this._activeProvider} provider does not support $executeRaw`);
              }
            }
          } else {
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql":
                queryString = query2.sql;
                break;
              case "cockroachdb":
              case "postgresql":
                queryString = query2.text;
                checkAlter(queryString, query2.values, "prisma.$executeRaw(sql`<SQL>`)");
                break;
              case "sqlserver":
                queryString = mssqlPreparedStatement(query2.strings);
                break;
              default:
                throw new Error(`The ${this._activeProvider} provider does not support $executeRaw`);
            }
            parameters = {
              values: serializeRawParameters(query2.values),
              __prismaRawParameters__: true
            };
          }
          if (parameters == null ? void 0 : parameters.values) {
            debug12(`prisma.$executeRaw(${queryString}, ${parameters.values})`);
          } else {
            debug12(`prisma.$executeRaw(${queryString})`);
          }
          const args = { query: queryString, parameters };
          debug12(`Prisma Client call:`);
          return this._request({
            args,
            clientMethod: "$executeRaw",
            dataPath: [],
            action: "executeRaw",
            callsite: getCallSite(this._errorFormat),
            transaction,
            lock
          });
        }
        $executeRaw(query2, ...values) {
          return createPrismaPromise((transaction, lock) => {
            if (query2.raw !== void 0 || query2.sql !== void 0) {
              return this.$executeRawInternal(transaction, lock, query2, ...values);
            }
            throw new PrismaClientValidationError(`\`$executeRaw\` is a tag function, please use it like the following:
\`\`\`
const result = await prisma.$executeRaw\`UPDATE User SET cool = \${true} WHERE email = \${'user@email.com'};\`
\`\`\`

Or read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw
`);
          });
        }
        $executeRawUnsafe(query2, ...values) {
          return createPrismaPromise((transaction, lock) => {
            return this.$executeRawInternal(transaction, lock, query2, ...values);
          });
        }
        $runCommandRaw(command) {
          if (config2.activeProvider !== "mongodb") {
            throw new PrismaClientValidationError(
              `The ${config2.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`
            );
          }
          return createPrismaPromise((transaction, lock) => {
            return this._request({
              args: { command },
              clientMethod: "$runCommandRaw",
              dataPath: [],
              action: "runCommandRaw",
              callsite: getCallSite(this._errorFormat),
              transaction,
              lock
            });
          });
        }
        async $queryRawInternal(transaction, lock, query2, ...values) {
          let queryString = "";
          let parameters = void 0;
          if (typeof query2 === "string") {
            queryString = query2;
            parameters = {
              values: serializeRawParameters(values || []),
              __prismaRawParameters__: true
            };
          } else if (isReadonlyArray(query2)) {
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql": {
                const queryInstance = new Sql(query2, values);
                queryString = queryInstance.sql;
                parameters = {
                  values: serializeRawParameters(queryInstance.values),
                  __prismaRawParameters__: true
                };
                break;
              }
              case "cockroachdb":
              case "postgresql": {
                const queryInstance = new Sql(query2, values);
                queryString = queryInstance.text;
                parameters = {
                  values: serializeRawParameters(queryInstance.values),
                  __prismaRawParameters__: true
                };
                break;
              }
              case "sqlserver": {
                const queryInstance = new Sql(query2, values);
                queryString = mssqlPreparedStatement(queryInstance.strings);
                parameters = {
                  values: serializeRawParameters(queryInstance.values),
                  __prismaRawParameters__: true
                };
                break;
              }
              default: {
                throw new Error(`The ${this._activeProvider} provider does not support $queryRaw`);
              }
            }
          } else {
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql":
                queryString = query2.sql;
                break;
              case "cockroachdb":
              case "postgresql":
                queryString = query2.text;
                break;
              case "sqlserver":
                queryString = mssqlPreparedStatement(query2.strings);
                break;
              default: {
                throw new Error(`The ${this._activeProvider} provider does not support $queryRaw`);
              }
            }
            parameters = {
              values: serializeRawParameters(query2.values),
              __prismaRawParameters__: true
            };
          }
          if (parameters == null ? void 0 : parameters.values) {
            debug12(`prisma.queryRaw(${queryString}, ${parameters.values})`);
          } else {
            debug12(`prisma.queryRaw(${queryString})`);
          }
          const args = { query: queryString, parameters };
          debug12(`Prisma Client call:`);
          return this._request({
            args,
            clientMethod: "$queryRaw",
            dataPath: [],
            action: "queryRaw",
            callsite: getCallSite(this._errorFormat),
            transaction,
            lock
          }).then(deserializeRawResults);
        }
        $queryRaw(query2, ...values) {
          return createPrismaPromise((txId, lock) => {
            if (query2.raw !== void 0 || query2.sql !== void 0) {
              return this.$queryRawInternal(txId, lock, query2, ...values);
            }
            throw new PrismaClientValidationError(`\`$queryRaw\` is a tag function, please use it like the following:
\`\`\`
const result = await prisma.$queryRaw\`SELECT * FROM User WHERE id = \${1} OR email = \${'user@email.com'};\`
\`\`\`

Or read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw
`);
          });
        }
        $queryRawUnsafe(query2, ...values) {
          return createPrismaPromise((txId, lock) => {
            return this.$queryRawInternal(txId, lock, query2, ...values);
          });
        }
        __internal_triggerPanic(fatal) {
          if (!this._engineConfig.allowTriggerPanic) {
            throw new Error(`In order to use .__internal_triggerPanic(), please enable it like so:
new PrismaClient({
  __internal: {
    engine: {
      allowTriggerPanic: true
    }
  }
})`);
          }
          const headers = fatal ? { "X-DEBUG-FATAL": "1" } : { "X-DEBUG-NON-FATAL": "1" };
          return this._request({
            action: "queryRaw",
            args: {
              query: "SELECT 1",
              parameters: void 0
            },
            clientMethod: "queryRaw",
            dataPath: [],
            headers,
            callsite: getCallSite(this._errorFormat)
          });
        }
        _transactionWithArray({
          promises,
          options
        }) {
          const id = BatchTxIdCounter.nextId();
          const lock = getLockCountPromise(promises.length);
          const requests = promises.map((request2, index) => {
            var _a32, _b22;
            if ((request2 == null ? void 0 : request2[Symbol.toStringTag]) !== "PrismaPromise") {
              throw new Error(
                `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`
              );
            }
            return (_b22 = (_a32 = request2.requestTransaction) == null ? void 0 : _a32.call(request2, { id, index, isolationLevel: options == null ? void 0 : options.isolationLevel }, lock)) != null ? _b22 : request2;
          });
          return waitForBatch(requests);
        }
        async _transactionWithCallback({
          callback,
          options
        }) {
          const headers = { traceparent: getTraceParent({ tracingConfig: this._tracingConfig }) };
          const info2 = await this._engine.transaction("start", headers, options);
          let result;
          try {
            result = await callback(transactionProxy(this, { id: info2.id, payload: info2.payload }));
            await this._engine.transaction("commit", headers, info2);
          } catch (e) {
            await this._engine.transaction("rollback", headers, info2).catch(() => {
            });
            throw e;
          }
          return result;
        }
        $transaction(input, options) {
          let callback;
          if (typeof input === "function") {
            callback = /* @__PURE__ */ __name(() => this._transactionWithCallback({ callback: input, options }), "callback");
          } else {
            callback = /* @__PURE__ */ __name(() => this._transactionWithArray({ promises: input, options }), "callback");
          }
          const spanOptions = {
            name: "transaction",
            enabled: this._tracingConfig.enabled,
            attributes: { method: "$transaction" }
          };
          return runInChildSpan(spanOptions, callback);
        }
        async _request(internalParams) {
          internalParams.otelParentCtx = context2.active();
          try {
            const params = {
              args: internalParams.args,
              dataPath: internalParams.dataPath,
              runInTransaction: Boolean(internalParams.transaction),
              action: internalParams.action,
              model: internalParams.model
            };
            const spanOptions = {
              middleware: {
                name: "middleware",
                enabled: this._tracingConfig.middleware,
                attributes: { method: "$use" },
                active: false
              },
              operation: {
                name: "operation",
                enabled: this._tracingConfig.enabled,
                attributes: {
                  method: params.action,
                  model: params.model,
                  name: `${params.model}.${params.action}`
                }
              }
            };
            let index = -1;
            const consumer = /* @__PURE__ */ __name((changedMiddlewareParams) => {
              const nextMiddleware = this._middlewares.query.get(++index);
              if (nextMiddleware) {
                return runInChildSpan(spanOptions.middleware, async (span) => {
                  return nextMiddleware(changedMiddlewareParams, (p) => (span == null ? void 0 : span.end(), consumer(p)));
                });
              }
              const { runInTransaction, ...changedRequestParams } = changedMiddlewareParams;
              const requestParams = {
                ...internalParams,
                ...changedRequestParams
              };
              if (!runInTransaction) {
                requestParams.transaction = void 0;
              }
              return applyQueryExtensions(this, requestParams);
            }, "consumer");
            return await runInChildSpan(spanOptions.operation, () => {
              if (true) {
                const asyncRes = new import_async_hooks.AsyncResource("prisma-client-request");
                return asyncRes.runInAsyncScope(() => consumer(params));
              }
              return consumer(params);
            });
          } catch (e) {
            e.clientVersion = this._clientVersion;
            throw e;
          }
        }
        async _executeRequest({
          args,
          clientMethod,
          jsModelName,
          dataPath,
          callsite,
          action,
          model,
          headers,
          argsMapper,
          transaction,
          lock,
          unpacker,
          otelParentCtx
        }) {
          var _a32, _b22;
          if (this._dmmf === void 0) {
            this._dmmf = await this._getDmmf({ clientMethod, callsite });
          }
          args = argsMapper ? argsMapper(args) : args;
          let rootField;
          const operation = actionOperationMap[action];
          if (action === "executeRaw" || action === "queryRaw" || action === "runCommandRaw") {
            rootField = action;
          }
          let mapping;
          if (model !== void 0) {
            mapping = (_a32 = this._dmmf) == null ? void 0 : _a32.mappingsMap[model];
            if (mapping === void 0) {
              throw new Error(`Could not find mapping for model ${model}`);
            }
            rootField = mapping[action === "count" ? "aggregate" : action];
          }
          if (operation !== "query" && operation !== "mutation") {
            throw new Error(`Invalid operation ${operation} for action ${action}`);
          }
          const field = (_b22 = this._dmmf) == null ? void 0 : _b22.rootFieldMap[rootField];
          if (field === void 0) {
            throw new Error(
              `Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`
            );
          }
          const { isList } = field.outputType;
          const typeName = getOutputTypeName(field.outputType.type);
          const rejectOnNotFound = getRejectOnNotFound(action, typeName, args, this._rejectOnNotFound);
          warnAboutRejectOnNotFound(rejectOnNotFound, jsModelName, action);
          const serializationFn = /* @__PURE__ */ __name(() => {
            const document3 = makeDocument({
              dmmf: this._dmmf,
              rootField,
              rootTypeName: operation,
              select: args,
              modelName: model,
              extensions: this._extensions
            });
            document3.validate(args, false, clientMethod, this._errorFormat, callsite);
            return transformDocument(document3);
          }, "serializationFn");
          const spanOptions = {
            name: "serialize",
            enabled: this._tracingConfig.enabled
          };
          const document2 = await runInChildSpan(spanOptions, serializationFn);
          if (src_default.enabled("prisma:client")) {
            const query2 = String(document2);
            debug12(`Prisma Client call:`);
            debug12(
              `prisma.${clientMethod}(${printJsonWithErrors({
                ast: args,
                keyPaths: [],
                valuePaths: [],
                missingItems: []
              })})`
            );
            debug12(`Generated request:`);
            debug12(query2 + "\n");
          }
          await lock;
          return this._fetcher.request({
            document: document2,
            clientMethod,
            typeName,
            dataPath,
            rejectOnNotFound,
            isList,
            rootField,
            callsite,
            args,
            engineHook: this._middlewares.engine.get(0),
            extensions: this._extensions,
            headers,
            transaction,
            unpacker,
            otelParentCtx,
            otelChildCtx: context2.active()
          });
        }
        get $metrics() {
          if (!this._hasPreviewFlag("metrics")) {
            throw new PrismaClientValidationError(
              "`metrics` preview feature must be enabled in order to access metrics API"
            );
          }
          return this._metrics;
        }
        _hasPreviewFlag(feature) {
          var _a32;
          return !!((_a32 = this._engineConfig.previewFeatures) == null ? void 0 : _a32.includes(feature));
        }
      }
      __name(PrismaClient2, "PrismaClient");
      return PrismaClient2;
    }
    __name(getPrismaClient, "getPrismaClient");
    var forbidden = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
    function transactionProxy(thing, transaction) {
      if (typeof thing !== "object")
        return thing;
      return new Proxy(thing, {
        get: (target, prop) => {
          if (forbidden.includes(prop))
            return void 0;
          if (prop === TX_ID)
            return transaction == null ? void 0 : transaction.id;
          if (typeof target[prop] === "function") {
            return (...args) => {
              if (prop === "then")
                return target[prop](args[0], args[1], transaction);
              if (prop === "catch")
                return target[prop](args[0], transaction);
              if (prop === "finally")
                return target[prop](args[0], transaction);
              return transactionProxy(target[prop](...args), transaction);
            };
          }
          return transactionProxy(target[prop], transaction);
        },
        has(target, prop) {
          if (forbidden.includes(prop)) {
            return false;
          }
          return Reflect.has(target, prop);
        }
      });
    }
    __name(transactionProxy, "transactionProxy");
    var rejectOnNotFoundReplacements = {
      findUnique: "findUniqueOrThrow",
      findFirst: "findFirstOrThrow"
    };
    function warnAboutRejectOnNotFound(rejectOnNotFound, model, action) {
      if (rejectOnNotFound) {
        const replacementAction = rejectOnNotFoundReplacements[action];
        const replacementCall = model ? `prisma.${model}.${replacementAction}` : `prisma.${replacementAction}`;
        const key = `rejectOnNotFound.${model != null ? model : ""}.${action}`;
        warnOnce(
          key,
          `\`rejectOnNotFound\` option is deprecated and will be removed in Prisma 5. Please use \`${replacementCall}\` method instead`
        );
      }
    }
    __name(warnAboutRejectOnNotFound, "warnAboutRejectOnNotFound");
    var allowList = /* @__PURE__ */ new Set([
      "toJSON",
      "asymmetricMatch",
      Symbol.iterator,
      Symbol.toStringTag,
      Symbol.isConcatSpreadable,
      Symbol.toPrimitive
    ]);
    function makeStrictEnum(definition) {
      return new Proxy(definition, {
        get(target, property) {
          if (property in target) {
            return target[property];
          }
          if (allowList.has(property)) {
            return void 0;
          }
          throw new TypeError(`Invalid enum value: ${String(property)}`);
        }
      });
    }
    __name(makeStrictEnum, "makeStrictEnum");
    var import_fs10 = __toESM(require("fs"));
    var import_path6 = __toESM(require("path"));
    var import_util8 = require("util");
    var readdirAsync = (0, import_util8.promisify)(import_fs10.default.readdir);
    var realpathAsync = (0, import_util8.promisify)(import_fs10.default.realpath);
    var statAsync = (0, import_util8.promisify)(import_fs10.default.stat);
    var readdirSync = import_fs10.default.readdirSync;
    var realpathSync = import_fs10.default.realpathSync;
    var statSync = import_fs10.default.statSync;
    function direntToType(dirent) {
      return dirent.isFile() ? "f" : dirent.isDirectory() ? "d" : dirent.isSymbolicLink() ? "l" : void 0;
    }
    __name(direntToType, "direntToType");
    function isMatched(string, regexs) {
      for (const regex of regexs) {
        if (typeof regex === "string") {
          if (string.includes(regex)) {
            return true;
          }
        } else if (regex.exec(string)) {
          return true;
        }
      }
      return false;
    }
    __name(isMatched, "isMatched");
    function findSync(root, match, types2 = ["f", "d", "l"], deep = [], limit = Infinity, handler = () => true, found = [], seen = {}) {
      try {
        const realRoot = realpathSync(root);
        if (seen[realRoot]) {
          return found;
        }
        if (limit - found.length <= 0) {
          return found;
        }
        if (direntToType(statSync(realRoot)) !== "d") {
          return found;
        }
        const items = readdirSync(root, { withFileTypes: true });
        seen[realRoot] = true;
        for (const item of items) {
          const itemName = item.name;
          const itemType = direntToType(item);
          const itemPath = import_path6.default.join(root, item.name);
          if (itemType && types2.includes(itemType)) {
            if (isMatched(itemPath, match)) {
              const value = handler(root, itemName, itemType);
              if (typeof value === "string") {
                found.push(value);
              } else if (value === true) {
                found.push(itemPath);
              }
            }
          }
          if (deep.includes(itemType)) {
            findSync(itemPath, match, types2, deep, limit, handler, found, seen);
          }
        }
      } catch (e) {
      }
      return found;
    }
    __name(findSync, "findSync");
    function warnEnvConflicts(envPaths) {
      tryLoadEnvs(envPaths, { conflictCheck: "warn" });
    }
    __name(warnEnvConflicts, "warnEnvConflicts");
    var decompressFromBase642 = lzString.decompressFromBase64;
  }
});

// node_modules/.prisma/client/index.js
var require_client2 = __commonJS2({
  "node_modules/.prisma/client/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      NotFoundError: NotFoundError3,
      decompressFromBase64: decompressFromBase643,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join2,
      raw: raw2,
      Decimal: Decimal2,
      Debug: Debug2,
      objectEnumValues: objectEnumValues2,
      makeStrictEnum: makeStrictEnum2,
      Extensions: Extensions2
    } = require_runtime();
    var Prisma = {};
    exports2.Prisma = Prisma;
    Prisma.prismaVersion = {
      client: "4.7.1",
      engine: "272861e07ab64f234d3ffc4094e32bd61775599c"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.NotFoundError = NotFoundError3;
    Prisma.Decimal = Decimal2;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join2;
    Prisma.raw = raw2;
    Prisma.validator = () => (val) => val;
    Prisma.DbNull = objectEnumValues2.instances.DbNull;
    Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
    Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
    Prisma.NullTypes = {
      DbNull: objectEnumValues2.classes.DbNull,
      JsonNull: objectEnumValues2.classes.JsonNull,
      AnyNull: objectEnumValues2.classes.AnyNull
    };
    var path2 = require("path");
    var { findSync: findSync2 } = require_runtime();
    var fs = require("fs");
    var hasDirname = typeof __dirname !== "undefined" && __dirname !== "/";
    var regularDirname = hasDirname && fs.existsSync(path2.join(__dirname, "schema.prisma")) && __dirname;
    var foundDirname = !regularDirname && findSync2(process.cwd(), [
      "node_modules/.prisma/client",
      ".prisma/client"
    ], ["d"], ["d"], 1)[0];
    var dirname2 = regularDirname || foundDirname || __dirname;
    function makeEnum(x) {
      return x;
    }
    exports2.Prisma.DocumentScalarFieldEnum = makeEnum({
      id: "id",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      did: "did",
      vc: "vc",
      location: "location",
      username: "username"
    });
    exports2.Prisma.QueryMode = makeEnum({
      default: "default",
      insensitive: "insensitive"
    });
    exports2.Prisma.SortOrder = makeEnum({
      asc: "asc",
      desc: "desc"
    });
    exports2.Prisma.TransactionIsolationLevel = makeStrictEnum2({
      ReadUncommitted: "ReadUncommitted",
      ReadCommitted: "ReadCommitted",
      RepeatableRead: "RepeatableRead",
      Serializable: "Serializable"
    });
    exports2.Prisma.UserScalarFieldEnum = makeEnum({
      id: "id",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      email: "email",
      password: "password"
    });
    exports2.Prisma.ModelName = makeEnum({
      User: "User",
      Document: "Document"
    });
    var dmmfString = '{"datamodel":{"enums":[],"models":[{"name":"User","dbName":"users","fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false,"documentation":"@encrypted"}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},{"name":"Document","dbName":"documents","fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"did","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"vc","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"location","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"username","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}],"types":[]},"mappings":{"modelOperations":[{"model":"User","plural":"users","findUnique":"findUniqueUser","findUniqueOrThrow":"findUniqueUserOrThrow","findFirst":"findFirstUser","findFirstOrThrow":"findFirstUserOrThrow","findMany":"findManyUser","create":"createOneUser","createMany":"createManyUser","delete":"deleteOneUser","update":"updateOneUser","deleteMany":"deleteManyUser","updateMany":"updateManyUser","upsert":"upsertOneUser","aggregate":"aggregateUser","groupBy":"groupByUser"},{"model":"Document","plural":"documents","findUnique":"findUniqueDocument","findUniqueOrThrow":"findUniqueDocumentOrThrow","findFirst":"findFirstDocument","findFirstOrThrow":"findFirstDocumentOrThrow","findMany":"findManyDocument","create":"createOneDocument","createMany":"createManyDocument","delete":"deleteOneDocument","update":"updateOneDocument","deleteMany":"deleteManyDocument","updateMany":"updateManyDocument","upsert":"upsertOneDocument","aggregate":"aggregateDocument","groupBy":"groupByDocument"}],"otherOperations":{"read":[],"write":["executeRaw","queryRaw"]}}}';
    var dmmf = JSON.parse(dmmfString);
    exports2.Prisma.dmmf = JSON.parse(dmmfString);
    var config2 = {
      "generator": {
        "name": "client",
        "provider": {
          "fromEnvVar": null,
          "value": "prisma-client-js"
        },
        "output": {
          "value": "/Users/shotaro/projects/ttec/ttec-docs-sys/node_modules/@prisma/client",
          "fromEnvVar": null
        },
        "config": {
          "engineType": "library"
        },
        "binaryTargets": [],
        "previewFeatures": []
      },
      "relativeEnvPaths": {
        "rootEnvPath": "../../../.env",
        "schemaEnvPath": "../../../.env"
      },
      "relativePath": "../../../prisma",
      "clientVersion": "4.7.1",
      "engineVersion": "272861e07ab64f234d3ffc4094e32bd61775599c",
      "datasourceNames": [
        "db"
      ],
      "activeProvider": "postgresql",
      "dataProxy": false
    };
    config2.document = dmmf;
    config2.dirname = dirname2;
    var { warnEnvConflicts: warnEnvConflicts2 } = require_runtime();
    warnEnvConflicts2({
      rootEnvPath: config2.relativeEnvPaths.rootEnvPath && path2.resolve(dirname2, config2.relativeEnvPaths.rootEnvPath),
      schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && path2.resolve(dirname2, config2.relativeEnvPaths.schemaEnvPath)
    });
    var PrismaClient2 = getPrismaClient2(config2);
    exports2.PrismaClient = PrismaClient2;
    Object.assign(exports2, Prisma);
    path2.join(__dirname, "libquery_engine-darwin.dylib.node");
    path2.join(process.cwd(), "node_modules/.prisma/client/libquery_engine-darwin.dylib.node");
    path2.join(__dirname, "schema.prisma");
    path2.join(process.cwd(), "node_modules/.prisma/client/schema.prisma");
  }
});

// node_modules/@prisma/client/index.js
var require_client3 = __commonJS2({
  "node_modules/@prisma/client/index.js"(exports2, module2) {
    module2.exports = {
      ...require_client2()
    };
  }
});

// node_modules/prisma-field-encryption/dist/debugger.js
var require_debugger = __commonJS2({
  "node_modules/prisma-field-encryption/dist/debugger.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.debug = exports2.namespace = void 0;
    var debug_1 = __importDefault(require_src2());
    exports2.namespace = "prisma-field-encryption";
    exports2.debug = {
      setup: (0, debug_1.default)(`${exports2.namespace}:setup`),
      runtime: (0, debug_1.default)(`${exports2.namespace}:runtime`),
      encryption: (0, debug_1.default)(`${exports2.namespace}:encryption`),
      decryption: (0, debug_1.default)(`${exports2.namespace}:decryption`)
    };
  }
});

// node_modules/prisma-field-encryption/dist/errors.js
var require_errors3 = __commonJS2({
  "node_modules/prisma-field-encryption/dist/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.warnings = exports2.errors = void 0;
    var debugger_1 = require_debugger();
    var error2 = `[${debugger_1.namespace}] Error`;
    var warning = `[${debugger_1.namespace}] Warning`;
    exports2.errors = {
      // Setup errors
      noEncryptionKey: `${error2}: no encryption key provided.`,
      unsupportedFieldType: (model, field) => `${error2}: encryption enabled for field ${model.name}.${field.name} of unsupported type ${field.type}: only String fields can be encrypted.`,
      unsupporteHashFieldType: (model, field) => `${error2}: hash enabled for field ${model.name}.${field.name} of unsupported type ${field.type}: only String fields can contain hashes.`,
      hashSourceFieldNotFound: (model, hashField, sourceField) => `${error2}: no such field \`${sourceField}\` in ${model.name}
  -> Referenced by hash field ${model.name}.${hashField.name}`,
      // Runtime errors
      fieldEncryptionError: (model, field, path2, error3) => `Encryption error for ${model}.${field} at ${path2}: ${error3}`,
      encryptionErrorReport: (operation, errors) => `${error2}: encryption error(s) encountered in operation ${operation}:
  ${errors.join("\n  ")}`,
      fieldDecryptionError: (model, field, path2, error3) => `Decryption error for ${model}.${field} at ${path2}: ${error3}`,
      decryptionErrorReport: (operation, errors) => `${error2}: decryption error(s) encountered in operation ${operation}:
  ${errors.join("\n  ")}`,
      // Generator errors
      nonUniqueCursor: (model, field) => `${error2}: the cursor field ${model}.${field} should have a @unique attribute.
  Read more: https://github.com/47ng/prisma-field-encryption#custom-cursors`,
      unsupportedCursorType: (model, field, type) => `${error2}: the cursor field ${model}.${field} has an unsupported type ${type}.
  Only String and Int cursors are supported.
  Read more: https://github.com/47ng/prisma-field-encryption#custom-cursors`,
      encryptedCursor: (model, field) => `${error2}: the field ${model}.${field} cannot be used as a cursor as it is encrypted.
  Read more: https://github.com/47ng/prisma-field-encryption#custom-cursors`,
      noInteractiveTransactions: `${error2}: this generator requires enabling the \`interactiveTransactions\` preview feature on \`prisma-client-js\`:

  generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["interactiveTransactions"] // <- Add this line
  }

  Read more: https://github.com/47ng/prisma-field-encryption#migrations
`
    };
    exports2.warnings = {
      // Setup warnings
      deprecatedModeAnnotation: (model, field, mode) => `${warning}: deprecated annotation \`/// @encrypted?${mode}\` on field ${model}.${field}.
  -> Please replace with /// @encrypted?mode=${mode}
  (support for undocumented annotations will be removed in a future update)`,
      unknownFieldModeAnnotation: (model, field, mode) => `${warning}: the field ${model}.${field} defines an unknown mode \`${mode}\`.
  Accepted modes are \`strict\` or \`readonly\`.`,
      noCursorFound: (model) => `${warning}: could not find a field to use to iterate over rows in model ${model}.
  Automatic encryption/decryption/key rotation migrations are disabled for this model.
  Read more: https://github.com/47ng/prisma-field-encryption#migrations`,
      // Runtime warnings
      whereClauseNoHash: (operation, path2) => `${warning}: you're using an encrypted field in a \`where\` clause without a hash.
  -> In ${operation}: ${path2}
  This will not work as-is, read more: https://github.com/47ng/prisma-field-encryption#caveats--limitations
  Consider adding a hash field to enable searching encrypted fields:
  https://github.com/47ng/prisma-field-encryption#enable-search-with-hashes
  `,
      unsupportedHashAlgorithm: (model, field, algorithm) => `${warning}: unsupported hash algorithm \`${algorithm}\` for hash field ${model}.${field}
  -> Valid values are algorithms accepted by Node's crypto.createHash:
  https://nodejs.org/dist/latest-v16.x/docs/api/crypto.html#cryptocreatehashalgorithm-options
`,
      unsupportedEncoding: (model, field, encoding, io) => `${warning}: unsupported ${io} encoding \`${encoding}\` for hash field ${model}.${field}
  -> Valid values are utf8, base64, hex
`
    };
  }
});

// node_modules/zod/lib/helpers/util.js
var require_util4 = __commonJS2({
  "node_modules/zod/lib/helpers/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getParsedType = exports2.ZodParsedType = exports2.util = void 0;
    var util;
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys2 = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys2.push(key);
          }
        }
        return keys2;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util = exports2.util || (exports2.util = {}));
    exports2.ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return exports2.ZodParsedType.undefined;
        case "string":
          return exports2.ZodParsedType.string;
        case "number":
          return isNaN(data) ? exports2.ZodParsedType.nan : exports2.ZodParsedType.number;
        case "boolean":
          return exports2.ZodParsedType.boolean;
        case "function":
          return exports2.ZodParsedType.function;
        case "bigint":
          return exports2.ZodParsedType.bigint;
        case "symbol":
          return exports2.ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return exports2.ZodParsedType.array;
          }
          if (data === null) {
            return exports2.ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return exports2.ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return exports2.ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return exports2.ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return exports2.ZodParsedType.date;
          }
          return exports2.ZodParsedType.object;
        default:
          return exports2.ZodParsedType.unknown;
      }
    };
    exports2.getParsedType = getParsedType;
  }
});

// node_modules/zod/lib/ZodError.js
var require_ZodError = __commonJS2({
  "node_modules/zod/lib/ZodError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodError = exports2.quotelessJson = exports2.ZodIssueCode = void 0;
    var util_1 = require_util4();
    exports2.ZodIssueCode = util_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    exports2.quotelessJson = quotelessJson;
    var ZodError = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub2) => {
          this.issues = [...this.issues, sub2];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error2) => {
          for (const issue of error2.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub2 of this.issues) {
          if (sub2.path.length > 0) {
            fieldErrors[sub2.path[0]] = fieldErrors[sub2.path[0]] || [];
            fieldErrors[sub2.path[0]].push(mapper(sub2));
          } else {
            formErrors.push(mapper(sub2));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    exports2.ZodError = ZodError;
    ZodError.create = (issues) => {
      const error2 = new ZodError(issues);
      return error2;
    };
  }
});

// node_modules/zod/lib/locales/en.js
var require_en = __commonJS2({
  "node_modules/zod/lib/locales/en.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util4();
    var ZodError_1 = require_ZodError();
    var errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
          if (issue.received === util_1.ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodError_1.ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodError_1.ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodError_1.ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util_1.util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodError_1.ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(issue.minimum)}`;
          else
            message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(issue.maximum)}`;
          else
            message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_1.ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util_1.util.assertNever(issue);
      }
      return { message };
    };
    exports2.default = errorMap;
  }
});

// node_modules/zod/lib/errors.js
var require_errors4 = __commonJS2({
  "node_modules/zod/lib/errors.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getErrorMap = exports2.setErrorMap = exports2.defaultErrorMap = void 0;
    var en_1 = __importDefault(require_en());
    exports2.defaultErrorMap = en_1.default;
    var overrideErrorMap = en_1.default;
    function setErrorMap(map) {
      overrideErrorMap = map;
    }
    exports2.setErrorMap = setErrorMap;
    function getErrorMap() {
      return overrideErrorMap;
    }
    exports2.getErrorMap = getErrorMap;
  }
});

// node_modules/zod/lib/helpers/parseUtil.js
var require_parseUtil = __commonJS2({
  "node_modules/zod/lib/helpers/parseUtil.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsync = exports2.isValid = exports2.isDirty = exports2.isAborted = exports2.OK = exports2.DIRTY = exports2.INVALID = exports2.ParseStatus = exports2.addIssueToContext = exports2.EMPTY_PATH = exports2.makeIssue = void 0;
    var errors_1 = require_errors4();
    var en_1 = __importDefault(require_en());
    var makeIssue = (params) => {
      const { data, path: path2, errorMaps, issueData } = params;
      const fullPath = [...path2, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    exports2.makeIssue = makeIssue;
    exports2.EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      const issue = (0, exports2.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          (0, errors_1.getErrorMap)(),
          en_1.default
          // then global default map
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    exports2.addIssueToContext = addIssueToContext;
    var ParseStatus = class {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return exports2.INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return exports2.INVALID;
          if (value.status === "aborted")
            return exports2.INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (typeof value.value !== "undefined" || pair.alwaysSet) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    exports2.ParseStatus = ParseStatus;
    exports2.INVALID = Object.freeze({
      status: "aborted"
    });
    var DIRTY = (value) => ({ status: "dirty", value });
    exports2.DIRTY = DIRTY;
    var OK = (value) => ({ status: "valid", value });
    exports2.OK = OK;
    var isAborted = (x) => x.status === "aborted";
    exports2.isAborted = isAborted;
    var isDirty = (x) => x.status === "dirty";
    exports2.isDirty = isDirty;
    var isValid = (x) => x.status === "valid";
    exports2.isValid = isValid;
    var isAsync = (x) => typeof Promise !== void 0 && x instanceof Promise;
    exports2.isAsync = isAsync;
  }
});

// node_modules/zod/lib/helpers/typeAliases.js
var require_typeAliases = __commonJS2({
  "node_modules/zod/lib/helpers/typeAliases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/zod/lib/helpers/errorUtil.js
var require_errorUtil = __commonJS2({
  "node_modules/zod/lib/helpers/errorUtil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.errorUtil = void 0;
    var errorUtil;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil = exports2.errorUtil || (exports2.errorUtil = {}));
  }
});

// node_modules/zod/lib/types.js
var require_types = __commonJS2({
  "node_modules/zod/lib/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.date = exports2.boolean = exports2.bigint = exports2.array = exports2.any = exports2.coerce = exports2.ZodFirstPartyTypeKind = exports2.late = exports2.ZodSchema = exports2.Schema = exports2.custom = exports2.ZodPipeline = exports2.ZodBranded = exports2.BRAND = exports2.ZodNaN = exports2.ZodCatch = exports2.ZodDefault = exports2.ZodNullable = exports2.ZodOptional = exports2.ZodTransformer = exports2.ZodEffects = exports2.ZodPromise = exports2.ZodNativeEnum = exports2.ZodEnum = exports2.ZodLiteral = exports2.ZodLazy = exports2.ZodFunction = exports2.ZodSet = exports2.ZodMap = exports2.ZodRecord = exports2.ZodTuple = exports2.ZodIntersection = exports2.ZodDiscriminatedUnion = exports2.ZodUnion = exports2.ZodObject = exports2.objectUtil = exports2.ZodArray = exports2.ZodVoid = exports2.ZodNever = exports2.ZodUnknown = exports2.ZodAny = exports2.ZodNull = exports2.ZodUndefined = exports2.ZodSymbol = exports2.ZodDate = exports2.ZodBoolean = exports2.ZodBigInt = exports2.ZodNumber = exports2.ZodString = exports2.ZodType = void 0;
    exports2.NEVER = exports2.void = exports2.unknown = exports2.union = exports2.undefined = exports2.tuple = exports2.transformer = exports2.symbol = exports2.string = exports2.strictObject = exports2.set = exports2.record = exports2.promise = exports2.preprocess = exports2.pipeline = exports2.ostring = exports2.optional = exports2.onumber = exports2.oboolean = exports2.object = exports2.number = exports2.nullable = exports2.null = exports2.never = exports2.nativeEnum = exports2.nan = exports2.map = exports2.literal = exports2.lazy = exports2.intersection = exports2.instanceof = exports2.function = exports2.enum = exports2.effect = exports2.discriminatedUnion = void 0;
    var errors_1 = require_errors4();
    var errorUtil_1 = require_errorUtil();
    var parseUtil_1 = require_parseUtil();
    var util_1 = require_util4();
    var ZodError_1 = require_ZodError();
    var ParseInputLazyPath = class {
      constructor(parent, value, path2, key) {
        this.parent = parent;
        this.data = value;
        this._path = path2;
        this._key = key;
      }
      get path() {
        return this._path.concat(this._key);
      }
    };
    var handleResult = (ctx, result) => {
      if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        const error2 = new ZodError_1.ZodError(ctx.common.issues);
        return { success: false, error: error2 };
      }
    };
    function processCreateParams(params) {
      if (!params)
        return {};
      const { errorMap, invalid_type_error, required_error, description } = params;
      if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap)
        return { errorMap, description };
      const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
          return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    var ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a4;
        const ctx = {
          common: {
            issues: [],
            async: (_a4 = params === null || params === void 0 ? void 0 : params.async) !== null && _a4 !== void 0 ? _a4 : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodError_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this);
      }
      nullable() {
        return ZodNullable.create(this);
      }
      nullish() {
        return this.optional().nullable();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this);
      }
      or(option) {
        return ZodUnion.create([this, option]);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming);
      }
      transform(transform) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(void 0)
        });
      }
      catch(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    exports2.ZodType = ZodType;
    exports2.Schema = ZodType;
    exports2.ZodSchema = ZodType;
    var cuidRegex = /^c[^\s-]{8,}$/i;
    var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
    var emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
    var datetimeRegex = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}:\\d{2})|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}:\\d{2})|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}:\\d{2})|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    var ZodString = class extends ZodType {
      constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
          validation,
          code: ZodError_1.ZodIssueCode.invalid_string,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
        this.nonempty = (message) => this.min(1, errorUtil_1.errorUtil.errToObj(message));
        this.trim = () => new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(
            ctx2,
            {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.string,
              received: ctx2.parsedType
            }
            //
          );
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "email",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "uuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a4) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "regex",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _addCheck(check) {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      datetime(options) {
        var _a4;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a4 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a4 !== void 0 ? _a4 : false,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get minLength() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxLength() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    };
    exports2.ZodString = ZodString;
    ZodString.create = (params) => {
      var _a4;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a4 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a4 !== void 0 ? _a4 : false,
        ...processCreateParams(params)
      });
    };
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    var ZodNumber = class extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.number,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util_1.util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int");
      }
    };
    exports2.ZodNumber = ZodNumber;
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    var ZodBigInt = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.bigint,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodBigInt = ZodBigInt;
    ZodBigInt.create = (params) => {
      var _a4;
      return new ZodBigInt({
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a4 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a4 !== void 0 ? _a4 : false,
        ...processCreateParams(params)
      });
    };
    var ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodBoolean = ZodBoolean;
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    var ZodDate = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.date,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_date
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minDate() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2 != null ? new Date(min2) : null;
      }
      get maxDate() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2 != null ? new Date(max2) : null;
      }
    };
    exports2.ZodDate = ZodDate;
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    var ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodSymbol = ZodSymbol;
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    var ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodUndefined = ZodUndefined;
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    var ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.null,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodNull = ZodNull;
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    var ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodAny = ZodAny;
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    var ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodUnknown = ZodUnknown;
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    var ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.never,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
    };
    exports2.ZodNever = ZodNever;
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    var ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.void,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodVoid = ZodVoid;
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    var ZodArray = class extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all(ctx.data.map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return parseUtil_1.ParseStatus.mergeArray(status, result2);
          });
        }
        const result = ctx.data.map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports2.ZodArray = ZodArray;
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil = exports2.objectUtil || (exports2.objectUtil = {}));
    var AugmentFactory = (def) => (augmentation) => {
      return new ZodObject({
        ...def,
        shape: () => ({
          ...def.shape(),
          ...augmentation
        })
      });
    };
    function deepPartialify(schema) {
      if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
          const fieldSchema = schema.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema._def,
          shape: () => newShape
        });
      } else if (schema instanceof ZodArray) {
        return ZodArray.create(deepPartialify(schema.element));
      } else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
      } else {
        return schema;
      }
    }
    var ZodObject = class extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = AugmentFactory(this._def);
        this.extend = AugmentFactory(this._def);
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys2 = util_1.util.objectKeys(shape);
        return this._cached = { shape, keys: keys2 };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil_1.errorUtil.errToObj;
        return new ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a4, _b3, _c2, _d2;
              const defaultError = (_c2 = (_b3 = (_a4 = this._def).errorMap) === null || _b3 === void 0 ? void 0 : _b3.call(_a4, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d2 = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      catchall(index) {
        return new ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).map((key) => {
          if (this.shape[key])
            shape[key] = this.shape[key];
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).map((key) => {
          if (util_1.util.objectKeys(mask).indexOf(key) === -1) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        if (mask) {
          util_1.util.objectKeys(this.shape).map((key) => {
            if (util_1.util.objectKeys(mask).indexOf(key) === -1) {
              newShape[key] = this.shape[key];
            } else {
              newShape[key] = this.shape[key].optional();
            }
          });
          return new ZodObject({
            ...this._def,
            shape: () => newShape
          });
        } else {
          for (const key in this.shape) {
            const fieldSchema = this.shape[key];
            newShape[key] = fieldSchema.optional();
          }
        }
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        if (mask) {
          util_1.util.objectKeys(this.shape).map((key) => {
            if (util_1.util.objectKeys(mask).indexOf(key) === -1) {
              newShape[key] = this.shape[key];
            } else {
              const fieldSchema = this.shape[key];
              let newField = fieldSchema;
              while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
              }
              newShape[key] = newField;
            }
          });
        } else {
          for (const key in this.shape) {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
      }
    };
    exports2.ZodObject = ZodObject;
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    var ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    exports2.ZodUnion = ZodUnion;
    ZodUnion.create = (types2, params) => {
      return new ZodUnion({
        options: types2,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    var getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else {
        return null;
      }
    };
    var ZodDiscriminatedUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    exports2.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
    function mergeValues(a, b) {
      const aType = (0, util_1.getParsedType)(a);
      const bType = (0, util_1.getParsedType)(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    var ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
            return parseUtil_1.INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_intersection_types
            });
            return parseUtil_1.INVALID;
          }
          if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    exports2.ZodIntersection = ZodIntersection;
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    var ZodTuple = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = ctx.data.map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return parseUtil_1.ParseStatus.mergeArray(status, results);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    exports2.ZodTuple = ZodTuple;
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    var ZodRecord = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
          });
        }
        if (ctx.common.async) {
          return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    exports2.ZodRecord = ZodRecord;
    var ZodMap = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.map,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    exports2.ZodMap = ZodMap;
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    var ZodSet = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.set,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return parseUtil_1.INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports2.ZodSet = ZodSet;
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    var ZodFunction = class extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.function,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error2) {
          return (0, parseUtil_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_arguments,
              argumentsError: error2
            }
          });
        }
        function makeReturnsIssue(returns, error2) {
          return (0, parseUtil_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error2
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          return (0, parseUtil_1.OK)(async (...args) => {
            const error2 = new ZodError_1.ZodError([]);
            const parsedArgs = await this._def.args.parseAsync(args, params).catch((e) => {
              error2.addIssue(makeArgsIssue(args, e));
              throw error2;
            });
            const result = await fn(...parsedArgs);
            const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error2.addIssue(makeReturnsIssue(result, e));
              throw error2;
            });
            return parsedReturns;
          });
        } else {
          return (0, parseUtil_1.OK)((...args) => {
            const parsedArgs = this._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = fn(...parsedArgs.data);
            const parsedReturns = this._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    exports2.ZodFunction = ZodFunction;
    var ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    exports2.ZodLazy = ZodLazy;
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    var ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    exports2.ZodLiteral = ZodLiteral;
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    function createZodEnum(values, params) {
      return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
      });
    }
    var ZodEnum = class extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
    };
    exports2.ZodEnum = ZodEnum;
    ZodEnum.create = createZodEnum;
    var ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    exports2.ZodNativeEnum = ZodNativeEnum;
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    var ZodPromise = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.promise,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    exports2.ZodPromise = ZodPromise;
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    var ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data);
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        const checkCtx = {
          addIssue: (arg) => {
            (0, parseUtil_1.addIssueToContext)(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return parseUtil_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return parseUtil_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_1.isValid)(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!(0, parseUtil_1.isValid)(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util_1.util.assertNever(effect);
      }
    };
    exports2.ZodEffects = ZodEffects;
    exports2.ZodTransformer = ZodEffects;
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    var ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
          return (0, parseUtil_1.OK)(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports2.ZodOptional = ZodOptional;
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    var ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
          return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports2.ZodNullable = ZodNullable;
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    var ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    exports2.ZodDefault = ZodDefault;
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    var ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const result = this._def.innerType._parse({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if ((0, parseUtil_1.isAsync)(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.defaultValue()
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.defaultValue()
          };
        }
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    exports2.ZodCatch = ZodCatch;
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    var ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.nan,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    exports2.ZodNaN = ZodNaN;
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    exports2.BRAND = Symbol("zod_brand");
    var ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    exports2.ZodBranded = ZodBranded;
    var ZodPipeline = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return (0, parseUtil_1.DIRTY)(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    exports2.ZodPipeline = ZodPipeline;
    var custom = (check, params = {}, fatal) => {
      if (check)
        return ZodAny.create().superRefine((data, ctx) => {
          if (!check(data)) {
            const p = typeof params === "function" ? params(data) : params;
            const p2 = typeof p === "string" ? { message: p } : p;
            ctx.addIssue({ code: "custom", ...p2, fatal });
          }
        });
      return ZodAny.create();
    };
    exports2.custom = custom;
    exports2.late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    })(ZodFirstPartyTypeKind = exports2.ZodFirstPartyTypeKind || (exports2.ZodFirstPartyTypeKind = {}));
    var instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => (0, exports2.custom)((data) => data instanceof cls, params, true);
    exports2.instanceof = instanceOfType;
    var stringType = ZodString.create;
    exports2.string = stringType;
    var numberType = ZodNumber.create;
    exports2.number = numberType;
    var nanType = ZodNaN.create;
    exports2.nan = nanType;
    var bigIntType = ZodBigInt.create;
    exports2.bigint = bigIntType;
    var booleanType = ZodBoolean.create;
    exports2.boolean = booleanType;
    var dateType = ZodDate.create;
    exports2.date = dateType;
    var symbolType = ZodSymbol.create;
    exports2.symbol = symbolType;
    var undefinedType = ZodUndefined.create;
    exports2.undefined = undefinedType;
    var nullType = ZodNull.create;
    exports2.null = nullType;
    var anyType = ZodAny.create;
    exports2.any = anyType;
    var unknownType = ZodUnknown.create;
    exports2.unknown = unknownType;
    var neverType = ZodNever.create;
    exports2.never = neverType;
    var voidType = ZodVoid.create;
    exports2.void = voidType;
    var arrayType = ZodArray.create;
    exports2.array = arrayType;
    var objectType = ZodObject.create;
    exports2.object = objectType;
    var strictObjectType = ZodObject.strictCreate;
    exports2.strictObject = strictObjectType;
    var unionType = ZodUnion.create;
    exports2.union = unionType;
    var discriminatedUnionType = ZodDiscriminatedUnion.create;
    exports2.discriminatedUnion = discriminatedUnionType;
    var intersectionType = ZodIntersection.create;
    exports2.intersection = intersectionType;
    var tupleType = ZodTuple.create;
    exports2.tuple = tupleType;
    var recordType = ZodRecord.create;
    exports2.record = recordType;
    var mapType = ZodMap.create;
    exports2.map = mapType;
    var setType = ZodSet.create;
    exports2.set = setType;
    var functionType = ZodFunction.create;
    exports2.function = functionType;
    var lazyType = ZodLazy.create;
    exports2.lazy = lazyType;
    var literalType = ZodLiteral.create;
    exports2.literal = literalType;
    var enumType = ZodEnum.create;
    exports2.enum = enumType;
    var nativeEnumType = ZodNativeEnum.create;
    exports2.nativeEnum = nativeEnumType;
    var promiseType = ZodPromise.create;
    exports2.promise = promiseType;
    var effectsType = ZodEffects.create;
    exports2.effect = effectsType;
    exports2.transformer = effectsType;
    var optionalType = ZodOptional.create;
    exports2.optional = optionalType;
    var nullableType = ZodNullable.create;
    exports2.nullable = nullableType;
    var preprocessType = ZodEffects.createWithPreprocess;
    exports2.preprocess = preprocessType;
    var pipelineType = ZodPipeline.create;
    exports2.pipeline = pipelineType;
    var ostring = () => stringType().optional();
    exports2.ostring = ostring;
    var onumber = () => numberType().optional();
    exports2.onumber = onumber;
    var oboolean = () => booleanType().optional();
    exports2.oboolean = oboolean;
    exports2.coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({ ...arg, coerce: true }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    exports2.NEVER = parseUtil_1.INVALID;
  }
});

// node_modules/zod/lib/external.js
var require_external = __commonJS2({
  "node_modules/zod/lib/external.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_errors4(), exports2);
    __exportStar(require_parseUtil(), exports2);
    __exportStar(require_typeAliases(), exports2);
    __exportStar(require_util4(), exports2);
    __exportStar(require_types(), exports2);
    __exportStar(require_ZodError(), exports2);
  }
});

// node_modules/zod/lib/index.js
var require_lib3 = __commonJS2({
  "node_modules/zod/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule)
        return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.z = void 0;
    var mod2 = __importStar(require_external());
    exports2.z = mod2;
    __exportStar(require_external(), exports2);
    exports2.default = mod2;
  }
});

// node_modules/prisma-field-encryption/dist/types.js
var require_types2 = __commonJS2({
  "node_modules/prisma-field-encryption/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dmmfDocumentParser = void 0;
    var zod_1 = require_lib3();
    var dmmfFieldParser = zod_1.z.object({
      name: zod_1.z.string(),
      isList: zod_1.z.boolean(),
      isUnique: zod_1.z.boolean(),
      isId: zod_1.z.boolean(),
      type: zod_1.z.any(),
      documentation: zod_1.z.string().optional()
    });
    var dmmfModelParser = zod_1.z.object({
      name: zod_1.z.string(),
      fields: zod_1.z.array(dmmfFieldParser)
    });
    exports2.dmmfDocumentParser = zod_1.z.object({
      datamodel: zod_1.z.object({
        models: zod_1.z.array(dmmfModelParser)
      })
    });
  }
});

// node_modules/prisma-field-encryption/dist/dmmf.js
var require_dmmf = __commonJS2({
  "node_modules/prisma-field-encryption/dist/dmmf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseHashAnnotation = exports2.parseEncryptedAnnotation = exports2.analyseDMMF = void 0;
    var errors_1 = require_errors3();
    var types_1 = require_types2();
    var supportedCursorTypes = ["Int", "String"];
    function analyseDMMF(input) {
      const dmmf = types_1.dmmfDocumentParser.parse(input);
      const allModels = dmmf.datamodel.models;
      return allModels.reduce((output, model) => {
        var _a4, _b3, _c2;
        const idField = model.fields.find((field) => field.isId && supportedCursorTypes.includes(String(field.type)));
        const uniqueField = model.fields.find((field) => field.isUnique && supportedCursorTypes.includes(String(field.type)));
        const cursorField = model.fields.find((field) => {
          var _a5;
          return (_a5 = field.documentation) === null || _a5 === void 0 ? void 0 : _a5.includes("@encryption:cursor");
        });
        if (cursorField) {
          if (!cursorField.isUnique) {
            throw new Error(errors_1.errors.nonUniqueCursor(model.name, cursorField.name));
          }
          if (!supportedCursorTypes.includes(String(cursorField.type))) {
            throw new Error(errors_1.errors.unsupportedCursorType(model.name, cursorField.name, String(cursorField.type)));
          }
          if ((_a4 = cursorField.documentation) === null || _a4 === void 0 ? void 0 : _a4.includes("@encrypted")) {
            throw new Error(errors_1.errors.encryptedCursor(model.name, cursorField.name));
          }
        }
        const modelDescriptor = {
          cursor: (_c2 = (_b3 = cursorField === null || cursorField === void 0 ? void 0 : cursorField.name) !== null && _b3 !== void 0 ? _b3 : idField === null || idField === void 0 ? void 0 : idField.name) !== null && _c2 !== void 0 ? _c2 : uniqueField === null || uniqueField === void 0 ? void 0 : uniqueField.name,
          fields: model.fields.reduce((fields, field) => {
            const fieldConfig = parseEncryptedAnnotation(field.documentation, model.name, field.name);
            if (fieldConfig && field.type !== "String") {
              throw new Error(errors_1.errors.unsupportedFieldType(model, field));
            }
            return fieldConfig ? { ...fields, [field.name]: fieldConfig } : fields;
          }, {}),
          connections: model.fields.reduce((connections, field) => {
            const targetModel = allModels.find((model2) => field.type === model2.name);
            if (!targetModel) {
              return connections;
            }
            const connection = {
              modelName: targetModel.name,
              isList: field.isList
            };
            return {
              ...connections,
              [field.name]: connection
            };
          }, {})
        };
        model.fields.forEach((field) => {
          const hashConfig = parseHashAnnotation(field.documentation, model.name, field.name);
          if (!hashConfig) {
            return;
          }
          if (field.type !== "String") {
            throw new Error(errors_1.errors.unsupporteHashFieldType(model, field));
          }
          const { sourceField, ...hash } = hashConfig;
          if (!(sourceField in modelDescriptor.fields)) {
            throw new Error(errors_1.errors.hashSourceFieldNotFound(model, field, sourceField));
          }
          modelDescriptor.fields[hashConfig.sourceField].hash = hash;
        });
        if (Object.keys(modelDescriptor.fields).length > 0 && !modelDescriptor.cursor) {
          console.warn(errors_1.warnings.noCursorFound(model.name));
        }
        return {
          ...output,
          [model.name]: modelDescriptor
        };
      }, {});
    }
    exports2.analyseDMMF = analyseDMMF;
    var encryptedAnnotationRegex = /@encrypted(?<query>\?[\w=&]+)?/;
    var hashAnnotationRegex = /@encryption:hash\((?<fieldName>\w+)\)(?<query>\?[\w=&]+)?/;
    function parseEncryptedAnnotation(annotation = "", model, field) {
      var _a4, _b3, _c2;
      const match = annotation.match(encryptedAnnotationRegex);
      if (!match) {
        return null;
      }
      const query2 = new URLSearchParams((_b3 = (_a4 = match.groups) === null || _a4 === void 0 ? void 0 : _a4.query) !== null && _b3 !== void 0 ? _b3 : "");
      const strict = query2.get("strict") !== null;
      const readonly = query2.get("readonly") !== null;
      if (strict && process.env.NODE_ENV === "development" && model && field) {
        console.warn(errors_1.warnings.deprecatedModeAnnotation(model, field, "strict"));
      }
      if (readonly && process.env.NODE_ENV === "development" && model && field) {
        console.warn(errors_1.warnings.deprecatedModeAnnotation(model, field, "readonly"));
      }
      const mode = (_c2 = query2.get("mode")) !== null && _c2 !== void 0 ? _c2 : readonly ? "readonly" : strict ? "strict" : "default";
      if (!["default", "strict", "readonly"].includes(mode)) {
        if (process.env.NODE_ENV === "development" && model && field) {
          console.warn(errors_1.warnings.unknownFieldModeAnnotation(model, field, mode));
        }
      }
      return {
        encrypt: mode !== "readonly",
        strictDecryption: mode === "strict"
      };
    }
    exports2.parseEncryptedAnnotation = parseEncryptedAnnotation;
    function parseHashAnnotation(annotation = "", model, field) {
      var _a4, _b3, _c2, _d2, _e, _f;
      const match = annotation.match(hashAnnotationRegex);
      if (!match || !((_a4 = match.groups) === null || _a4 === void 0 ? void 0 : _a4.fieldName)) {
        return null;
      }
      const query2 = new URLSearchParams((_b3 = match.groups.query) !== null && _b3 !== void 0 ? _b3 : "");
      const inputEncoding = (_c2 = query2.get("inputEncoding")) !== null && _c2 !== void 0 ? _c2 : "utf8";
      if (!isValidEncoding(inputEncoding) && process.env.NODE_ENV === "development" && model && field) {
        console.warn(errors_1.warnings.unsupportedEncoding(model, field, inputEncoding, "input"));
      }
      const outputEncoding = (_d2 = query2.get("outputEncoding")) !== null && _d2 !== void 0 ? _d2 : "hex";
      if (!isValidEncoding(outputEncoding) && process.env.NODE_ENV === "development" && model && field) {
        console.warn(errors_1.warnings.unsupportedEncoding(model, field, outputEncoding, "output"));
      }
      const saltEnv = query2.get("saltEnv");
      const salt = (_e = query2.get("salt")) !== null && _e !== void 0 ? _e : saltEnv ? process.env[saltEnv] : process.env.PRISMA_FIELD_ENCRYPTION_HASH_SALT;
      return {
        sourceField: match.groups.fieldName,
        targetField: field !== null && field !== void 0 ? field : match.groups.fieldName + "Hash",
        algorithm: (_f = query2.get("algorithm")) !== null && _f !== void 0 ? _f : "sha256",
        salt,
        inputEncoding,
        outputEncoding
      };
    }
    exports2.parseHashAnnotation = parseHashAnnotation;
    function isValidEncoding(encoding) {
      return ["hex", "base64", "utf8"].includes(encoding);
    }
  }
});

// node_modules/@stablelib/base64/lib/base64.js
var require_base64 = __commonJS2({
  "node_modules/@stablelib/base64/lib/base64.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var INVALID_BYTE = 256;
    var Coder = (
      /** @class */
      function() {
        function Coder2(_paddingCharacter) {
          if (_paddingCharacter === void 0) {
            _paddingCharacter = "=";
          }
          this._paddingCharacter = _paddingCharacter;
        }
        Coder2.prototype.encodedLength = function(length) {
          if (!this._paddingCharacter) {
            return (length * 8 + 5) / 6 | 0;
          }
          return (length + 2) / 3 * 4 | 0;
        };
        Coder2.prototype.encode = function(data) {
          var out = "";
          var i = 0;
          for (; i < data.length - 2; i += 3) {
            var c = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
            out += this._encodeByte(c >>> 3 * 6 & 63);
            out += this._encodeByte(c >>> 2 * 6 & 63);
            out += this._encodeByte(c >>> 1 * 6 & 63);
            out += this._encodeByte(c >>> 0 * 6 & 63);
          }
          var left = data.length - i;
          if (left > 0) {
            var c = data[i] << 16 | (left === 2 ? data[i + 1] << 8 : 0);
            out += this._encodeByte(c >>> 3 * 6 & 63);
            out += this._encodeByte(c >>> 2 * 6 & 63);
            if (left === 2) {
              out += this._encodeByte(c >>> 1 * 6 & 63);
            } else {
              out += this._paddingCharacter || "";
            }
            out += this._paddingCharacter || "";
          }
          return out;
        };
        Coder2.prototype.maxDecodedLength = function(length) {
          if (!this._paddingCharacter) {
            return (length * 6 + 7) / 8 | 0;
          }
          return length / 4 * 3 | 0;
        };
        Coder2.prototype.decodedLength = function(s) {
          return this.maxDecodedLength(s.length - this._getPaddingLength(s));
        };
        Coder2.prototype.decode = function(s) {
          if (s.length === 0) {
            return new Uint8Array(0);
          }
          var paddingLength = this._getPaddingLength(s);
          var length = s.length - paddingLength;
          var out = new Uint8Array(this.maxDecodedLength(length));
          var op = 0;
          var i = 0;
          var haveBad = 0;
          var v0 = 0, v1 = 0, v2 = 0, v3 = 0;
          for (; i < length - 4; i += 4) {
            v0 = this._decodeChar(s.charCodeAt(i + 0));
            v1 = this._decodeChar(s.charCodeAt(i + 1));
            v2 = this._decodeChar(s.charCodeAt(i + 2));
            v3 = this._decodeChar(s.charCodeAt(i + 3));
            out[op++] = v0 << 2 | v1 >>> 4;
            out[op++] = v1 << 4 | v2 >>> 2;
            out[op++] = v2 << 6 | v3;
            haveBad |= v0 & INVALID_BYTE;
            haveBad |= v1 & INVALID_BYTE;
            haveBad |= v2 & INVALID_BYTE;
            haveBad |= v3 & INVALID_BYTE;
          }
          if (i < length - 1) {
            v0 = this._decodeChar(s.charCodeAt(i));
            v1 = this._decodeChar(s.charCodeAt(i + 1));
            out[op++] = v0 << 2 | v1 >>> 4;
            haveBad |= v0 & INVALID_BYTE;
            haveBad |= v1 & INVALID_BYTE;
          }
          if (i < length - 2) {
            v2 = this._decodeChar(s.charCodeAt(i + 2));
            out[op++] = v1 << 4 | v2 >>> 2;
            haveBad |= v2 & INVALID_BYTE;
          }
          if (i < length - 3) {
            v3 = this._decodeChar(s.charCodeAt(i + 3));
            out[op++] = v2 << 6 | v3;
            haveBad |= v3 & INVALID_BYTE;
          }
          if (haveBad !== 0) {
            throw new Error("Base64Coder: incorrect characters for decoding");
          }
          return out;
        };
        Coder2.prototype._encodeByte = function(b) {
          var result = b;
          result += 65;
          result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
          result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
          result += 61 - b >>> 8 & 52 - 48 - 62 + 43;
          result += 62 - b >>> 8 & 62 - 43 - 63 + 47;
          return String.fromCharCode(result);
        };
        Coder2.prototype._decodeChar = function(c) {
          var result = INVALID_BYTE;
          result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;
          result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;
          result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
          result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
          result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
          return result;
        };
        Coder2.prototype._getPaddingLength = function(s) {
          var paddingLength = 0;
          if (this._paddingCharacter) {
            for (var i = s.length - 1; i >= 0; i--) {
              if (s[i] !== this._paddingCharacter) {
                break;
              }
              paddingLength++;
            }
            if (s.length < 4 || paddingLength > 2) {
              throw new Error("Base64Coder: incorrect padding");
            }
          }
          return paddingLength;
        };
        return Coder2;
      }()
    );
    exports2.Coder = Coder;
    var stdCoder = new Coder();
    function encode3(data) {
      return stdCoder.encode(data);
    }
    exports2.encode = encode3;
    function decode(s) {
      return stdCoder.decode(s);
    }
    exports2.decode = decode;
    var URLSafeCoder = (
      /** @class */
      function(_super) {
        __extends2(URLSafeCoder2, _super);
        function URLSafeCoder2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        URLSafeCoder2.prototype._encodeByte = function(b) {
          var result = b;
          result += 65;
          result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
          result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
          result += 61 - b >>> 8 & 52 - 48 - 62 + 45;
          result += 62 - b >>> 8 & 62 - 45 - 63 + 95;
          return String.fromCharCode(result);
        };
        URLSafeCoder2.prototype._decodeChar = function(c) {
          var result = INVALID_BYTE;
          result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;
          result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;
          result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
          result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
          result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
          return result;
        };
        return URLSafeCoder2;
      }(Coder)
    );
    exports2.URLSafeCoder = URLSafeCoder;
    var urlSafeCoder = new URLSafeCoder();
    function encodeURLSafe(data) {
      return urlSafeCoder.encode(data);
    }
    exports2.encodeURLSafe = encodeURLSafe;
    function decodeURLSafe(s) {
      return urlSafeCoder.decode(s);
    }
    exports2.decodeURLSafe = decodeURLSafe;
    exports2.encodedLength = function(length) {
      return stdCoder.encodedLength(length);
    };
    exports2.maxDecodedLength = function(length) {
      return stdCoder.maxDecodedLength(length);
    };
    exports2.decodedLength = function(s) {
      return stdCoder.decodedLength(s);
    };
  }
});

// node_modules/@47ng/codec/dist/b64.js
var require_b64 = __commonJS2({
  "node_modules/@47ng/codec/dist/b64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base64_1 = require_base64();
    var b64 = {
      urlSafe: (str) => str.replace(/\+/g, "-").replace(/\//g, "_"),
      urlUnsafe: (str) => str.replace(/\-/g, "+").replace(/\_/g, "/"),
      encode: function b64Encode(input) {
        if (typeof Buffer !== "undefined") {
          return b64.urlSafe(Buffer.from(input, 0, input.length).toString("base64"));
        }
        return (0, base64_1.encodeURLSafe)(input);
      },
      decode: function b64Decode(input) {
        if (typeof Buffer !== "undefined") {
          const buf = Buffer.from(input, "base64");
          return new Uint8Array(buf, 0, buf.length);
        }
        return (0, base64_1.decodeURLSafe)(b64.urlSafe(input));
      }
    };
    exports2.default = b64;
  }
});

// node_modules/@stablelib/hex/lib/hex.js
var require_hex = __commonJS2({
  "node_modules/@stablelib/hex/lib/hex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function encodeNibble(b) {
      var result = b + 48;
      result += 9 - b >>> 8 & -48 + 65 - 10;
      return String.fromCharCode(result);
    }
    function encodeNibbleLower(b) {
      var result = b + 48;
      result += 9 - b >>> 8 & -48 + 97 - 10;
      return String.fromCharCode(result);
    }
    var INVALID_HEX_NIBBLE = 256;
    function decodeNibble(c) {
      var result = INVALID_HEX_NIBBLE;
      result += (47 - c & c - 58) >> 8 & -INVALID_HEX_NIBBLE + c - 48;
      result += (64 - c & c - 71) >> 8 & -INVALID_HEX_NIBBLE + c - 65 + 10;
      result += (96 - c & c - 103) >> 8 & -INVALID_HEX_NIBBLE + c - 97 + 10;
      return result;
    }
    function encode3(data, lowerCase2) {
      if (lowerCase2 === void 0) {
        lowerCase2 = false;
      }
      var enc = lowerCase2 ? encodeNibbleLower : encodeNibble;
      var s = "";
      for (var i = 0; i < data.length; i++) {
        s += enc(data[i] >>> 4);
        s += enc(data[i] & 15);
      }
      return s;
    }
    exports2.encode = encode3;
    function decode(hex) {
      if (hex.length === 0) {
        return new Uint8Array(0);
      }
      if (hex.length % 2 !== 0) {
        throw new Error("hex: input string must be divisible by two");
      }
      var result = new Uint8Array(hex.length / 2);
      var haveBad = 0;
      for (var i = 0; i < hex.length; i += 2) {
        var v0 = decodeNibble(hex.charCodeAt(i));
        var v1 = decodeNibble(hex.charCodeAt(i + 1));
        result[i / 2] = v0 << 4 | v1;
        haveBad |= v0 & INVALID_HEX_NIBBLE;
        haveBad |= v1 & INVALID_HEX_NIBBLE;
      }
      if (haveBad !== 0) {
        throw new Error("hex: incorrect characters for decoding");
      }
      return result;
    }
    exports2.decode = decode;
  }
});

// node_modules/@47ng/codec/dist/hex.js
var require_hex2 = __commonJS2({
  "node_modules/@47ng/codec/dist/hex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hex_1 = require_hex();
    var hex = {
      encode: function HexEncode(input) {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(input, 0, input.length).toString("hex");
        }
        const lowerCase2 = true;
        return (0, hex_1.encode)(input, lowerCase2);
      },
      decode: function HexDecode(input) {
        if (input.length % 2 !== 0) {
          input = "0" + input;
        }
        if (typeof Buffer !== "undefined") {
          const buf = Buffer.from(input, "hex");
          return new Uint8Array(buf, 0, buf.length);
        }
        return (0, hex_1.decode)(input);
      }
    };
    exports2.default = hex;
  }
});

// node_modules/@47ng/codec/dist/utf8.js
var require_utf8 = __commonJS2({
  "node_modules/@47ng/codec/dist/utf8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utf8Encoder = new TextEncoder();
    var utf8Decoder = new TextDecoder();
    var utf8 = {
      decode: function Utf8Decode(input) {
        return utf8Decoder.decode(input);
      },
      encode: function Utf8Encode(input) {
        const buf = utf8Encoder.encode(input);
        return new Uint8Array(buf, 0, buf.length);
      }
    };
    exports2.default = utf8;
  }
});

// node_modules/@47ng/codec/dist/index.js
var require_dist = __commonJS2({
  "node_modules/@47ng/codec/dist/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.detectEncoding = exports2.decoders = exports2.encoders = exports2.hexToUTF8 = exports2.utf8ToHex = exports2.base64toUTF8 = exports2.utf8ToBase64 = exports2.base64ToHex = exports2.hexToBase64url = exports2.utf8 = exports2.b64 = exports2.hex = void 0;
    var b64_1 = __importDefault(require_b64());
    exports2.b64 = b64_1.default;
    var hex_1 = __importDefault(require_hex2());
    exports2.hex = hex_1.default;
    var utf8_1 = __importDefault(require_utf8());
    exports2.utf8 = utf8_1.default;
    function hexToBase64url(input) {
      return b64_1.default.encode(hex_1.default.decode(input));
    }
    exports2.hexToBase64url = hexToBase64url;
    function base64ToHex(base64) {
      return hex_1.default.encode(b64_1.default.decode(base64));
    }
    exports2.base64ToHex = base64ToHex;
    function utf8ToBase64(input) {
      return b64_1.default.encode(utf8_1.default.encode(input));
    }
    exports2.utf8ToBase64 = utf8ToBase64;
    function base64toUTF8(input) {
      return utf8_1.default.decode(b64_1.default.decode(input));
    }
    exports2.base64toUTF8 = base64toUTF8;
    function utf8ToHex(input) {
      return hex_1.default.encode(utf8_1.default.encode(input));
    }
    exports2.utf8ToHex = utf8ToHex;
    function hexToUTF8(input) {
      return utf8_1.default.decode(hex_1.default.decode(input));
    }
    exports2.hexToUTF8 = hexToUTF8;
    exports2.encoders = {
      base64: b64_1.default.encode,
      utf8: utf8_1.default.decode,
      hex: hex_1.default.encode
    };
    exports2.decoders = {
      base64: b64_1.default.decode,
      utf8: utf8_1.default.encode,
      hex: hex_1.default.decode
    };
    function detectEncoding(input) {
      const hex = /^[\dabcdef]+$/i;
      const b64 = /^[a-z0-9+/]+[=]{0,2}$/i;
      const b64url = /^[\w\-]+[=]{0,2}$/;
      if (hex.test(input)) {
        return "hex";
      }
      if (b64url.test(input) || b64.test(input)) {
        return "base64";
      }
      return "utf8";
    }
    exports2.detectEncoding = detectEncoding;
  }
});

// node_modules/@47ng/cloak/dist/key.js
var require_key = __commonJS2({
  "node_modules/@47ng/cloak/dist/key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKeyFingerprintSync = exports2.getKeyFingerprint = exports2.importKeySync = exports2.importKey = exports2.exportCryptoKey = exports2.generateKey = exports2.serializeKey = exports2.parseKeySync = exports2.parseKey = exports2.formatKey = exports2.cloakKeyRegex = exports2.FINGERPRINT_LENGTH = void 0;
    var codec_1 = require_dist();
    var nodeCrypto;
    if (typeof window === "undefined") {
      nodeCrypto = require("crypto");
    }
    exports2.FINGERPRINT_LENGTH = 8;
    exports2.cloakKeyRegex = /^k1\.aesgcm256\.(?<key>[a-zA-Z0-9-_]{43}=?)$/;
    function formatKey(raw2) {
      return ["k1", "aesgcm256", codec_1.b64.encode(raw2)].join(".");
    }
    exports2.formatKey = formatKey;
    async function parseKey(key, usage) {
      return {
        raw: await importKey(key, usage),
        fingerprint: await getKeyFingerprint(key)
      };
    }
    exports2.parseKey = parseKey;
    function parseKeySync(key) {
      return {
        raw: importKeySync(key),
        fingerprint: getKeyFingerprintSync(key)
      };
    }
    exports2.parseKeySync = parseKeySync;
    async function serializeKey(key) {
      return key.raw.algorithm ? await exportCryptoKey(key.raw) : formatKey(key.raw);
    }
    exports2.serializeKey = serializeKey;
    function generateKey() {
      const keyLength = 32;
      if (typeof window === "undefined") {
        const key = nodeCrypto.randomBytes(keyLength);
        return formatKey(key);
      } else {
        const key = window.crypto.getRandomValues(new Uint8Array(keyLength));
        return formatKey(key);
      }
    }
    exports2.generateKey = generateKey;
    async function exportCryptoKey(key) {
      const algo = key.algorithm;
      if (algo.name !== "AES-GCM" || algo.length !== 256) {
        throw new Error("Unsupported key type");
      }
      const raw2 = await window.crypto.subtle.exportKey("raw", key);
      return formatKey(new Uint8Array(raw2));
    }
    exports2.exportCryptoKey = exportCryptoKey;
    async function importKey(key, usage) {
      const match = key.match(exports2.cloakKeyRegex);
      if (!match) {
        throw new Error("Unknown key format");
      }
      const raw2 = codec_1.b64.decode(match.groups.key);
      if (typeof window === "undefined") {
        return raw2;
      } else {
        return await window.crypto.subtle.importKey("raw", raw2, {
          name: "AES-GCM",
          length: 256
        }, true, usage ? [usage] : ["encrypt", "decrypt"]);
      }
    }
    exports2.importKey = importKey;
    function importKeySync(key) {
      const match = key.match(exports2.cloakKeyRegex);
      if (!match) {
        throw new Error("Unknown key format");
      }
      return codec_1.b64.decode(match.groups.key);
    }
    exports2.importKeySync = importKeySync;
    async function getKeyFingerprint(key) {
      const data = codec_1.utf8.encode(key);
      if (typeof window === "undefined") {
        const hash = nodeCrypto.createHash("sha256");
        hash.update(data);
        return hash.digest("hex").slice(0, exports2.FINGERPRINT_LENGTH);
      } else {
        const hash = await window.crypto.subtle.digest("SHA-256", data);
        return codec_1.hex.encode(new Uint8Array(hash)).slice(0, exports2.FINGERPRINT_LENGTH);
      }
    }
    exports2.getKeyFingerprint = getKeyFingerprint;
    function getKeyFingerprintSync(key) {
      const data = codec_1.utf8.encode(key);
      const hash = nodeCrypto.createHash("sha256");
      hash.update(data);
      return hash.digest("hex").slice(0, exports2.FINGERPRINT_LENGTH);
    }
    exports2.getKeyFingerprintSync = getKeyFingerprintSync;
  }
});

// node_modules/@47ng/cloak/dist/ciphers/aes-gcm.js
var require_aes_gcm = __commonJS2({
  "node_modules/@47ng/cloak/dist/ciphers/aes-gcm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decryptAesGcmSync = exports2.decryptAesGcm = exports2.encryptAesGcmSync = exports2.encryptAesGcm = void 0;
    var codec_1 = require_dist();
    var nodeCrypto;
    if (typeof window === "undefined") {
      nodeCrypto = require("crypto");
    }
    async function encryptAesGcm(key, message) {
      if (typeof window === "undefined") {
        return encryptAesGcmSync(key, message);
      } else {
        const buf = codec_1.utf8.encode(message);
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const cipherText = await window.crypto.subtle.encrypt({
          name: "AES-GCM",
          iv
        }, key, buf);
        return {
          text: new Uint8Array(cipherText),
          iv
        };
      }
    }
    exports2.encryptAesGcm = encryptAesGcm;
    function encryptAesGcmSync(key, message) {
      const iv = nodeCrypto.randomBytes(12);
      const cipher = nodeCrypto.createCipheriv("aes-256-gcm", key, iv);
      const encrypted = cipher.update(message, "utf8");
      cipher.final();
      const tag2 = cipher.getAuthTag();
      return {
        // Authentication tag is the last 16 bytes
        // (for compatibility with WebCrypto serialization)
        text: new Uint8Array(Buffer.concat([encrypted, tag2])),
        iv
      };
    }
    exports2.encryptAesGcmSync = encryptAesGcmSync;
    async function decryptAesGcm(key, cipher) {
      if (typeof window === "undefined") {
        return decryptAesGcmSync(key, cipher);
      } else {
        const buf = await window.crypto.subtle.decrypt({
          name: "AES-GCM",
          iv: cipher.iv
        }, key, cipher.text);
        return codec_1.utf8.decode(new Uint8Array(buf));
      }
    }
    exports2.decryptAesGcm = decryptAesGcm;
    function decryptAesGcmSync(key, cipher) {
      const decipher = nodeCrypto.createDecipheriv("aes-256-gcm", key, cipher.iv);
      const tagStart = cipher.text.length - 16;
      const msg = cipher.text.slice(0, tagStart);
      const tag2 = cipher.text.slice(tagStart);
      decipher.setAuthTag(tag2);
      return decipher.update(msg, void 0, "utf8") + decipher.final("utf8");
    }
    exports2.decryptAesGcmSync = decryptAesGcmSync;
  }
});

// node_modules/@47ng/cloak/dist/message.js
var require_message = __commonJS2({
  "node_modules/@47ng/cloak/dist/message.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMessageKeyFingerprint = exports2.decryptStringSync = exports2.decryptString = exports2.cloakedStringRegex = exports2.encryptStringSync = exports2.encryptString = exports2.encodeEncryptedString = void 0;
    var codec_1 = require_dist();
    var aes_gcm_1 = require_aes_gcm();
    var key_1 = require_key();
    function encodeEncryptedString(fingerprint, iv, ciphertext) {
      return [
        "v1",
        "aesgcm256",
        fingerprint,
        codec_1.b64.encode(iv),
        codec_1.b64.encode(ciphertext)
      ].join(".");
    }
    exports2.encodeEncryptedString = encodeEncryptedString;
    async function encryptString(input, key) {
      if (typeof key === "string") {
        key = await (0, key_1.parseKey)(key, "encrypt");
      }
      const { text: ciphertext, iv } = await (0, aes_gcm_1.encryptAesGcm)(key.raw, input);
      return encodeEncryptedString(key.fingerprint, iv, ciphertext);
    }
    exports2.encryptString = encryptString;
    function encryptStringSync(input, key) {
      if (typeof key === "string") {
        key = (0, key_1.parseKeySync)(key);
      }
      const { text: ciphertext, iv } = (0, aes_gcm_1.encryptAesGcmSync)(key.raw, input);
      return encodeEncryptedString(key.fingerprint, iv, ciphertext);
    }
    exports2.encryptStringSync = encryptStringSync;
    exports2.cloakedStringRegex = /^v1\.aesgcm256\.(?<fingerprint>[0-9a-fA-F]{8})\.(?<iv>[a-zA-Z0-9-_]{16})\.(?<ciphertext>[a-zA-Z0-9-_]{22,})={0,2}$/;
    async function decryptString(input, key) {
      const match = input.match(exports2.cloakedStringRegex);
      if (!match) {
        throw new Error(`Unknown message format: ${input}`);
      }
      const iv = match.groups.iv;
      const ciphertext = match.groups.ciphertext;
      let aesKey;
      if (typeof key === "string") {
        aesKey = await (0, key_1.importKey)(key, "decrypt");
      } else {
        aesKey = key.raw;
      }
      return await (0, aes_gcm_1.decryptAesGcm)(aesKey, {
        iv: codec_1.b64.decode(iv),
        text: codec_1.b64.decode(ciphertext)
      });
    }
    exports2.decryptString = decryptString;
    function decryptStringSync(input, key) {
      const match = input.match(exports2.cloakedStringRegex);
      if (!match) {
        throw new Error(`Unknown message format: ${input}`);
      }
      const iv = match.groups.iv;
      const ciphertext = match.groups.ciphertext;
      let aesKey;
      if (typeof key === "string") {
        aesKey = (0, key_1.importKeySync)(key);
      } else {
        aesKey = key.raw;
      }
      return (0, aes_gcm_1.decryptAesGcmSync)(aesKey, {
        iv: codec_1.b64.decode(iv),
        text: codec_1.b64.decode(ciphertext)
      });
    }
    exports2.decryptStringSync = decryptStringSync;
    function getMessageKeyFingerprint(message) {
      const match = message.match(exports2.cloakedStringRegex);
      if (!match) {
        throw new Error("Unknown message format");
      }
      return match.groups.fingerprint;
    }
    exports2.getMessageKeyFingerprint = getMessageKeyFingerprint;
  }
});

// node_modules/@47ng/cloak/dist/keychain.js
var require_keychain = __commonJS2({
  "node_modules/@47ng/cloak/dist/keychain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKeyAge = exports2.findKeyForMessage = exports2.exportKeychainSync = exports2.exportKeychain = exports2.importKeychainSync = exports2.importKeychain = exports2.makeKeychainSync = exports2.makeKeychain = void 0;
    var key_1 = require_key();
    var message_1 = require_message();
    async function makeKeychain(keys2) {
      const keychain = {};
      for (const key of keys2) {
        const parsedKey = await (0, key_1.parseKey)(key);
        keychain[parsedKey.fingerprint] = {
          key: parsedKey,
          createdAt: Date.now()
        };
      }
      return keychain;
    }
    exports2.makeKeychain = makeKeychain;
    function makeKeychainSync(keys2) {
      const keychain = {};
      for (const key of keys2) {
        const parsedKey = (0, key_1.parseKeySync)(key);
        keychain[parsedKey.fingerprint] = {
          key: parsedKey,
          createdAt: Date.now()
        };
      }
      return keychain;
    }
    exports2.makeKeychainSync = makeKeychainSync;
    async function importKeychain(encryptedKeychain, masterKey) {
      const json = await (0, message_1.decryptString)(encryptedKeychain, masterKey);
      const keys2 = JSON.parse(json);
      const keychain = {};
      for (const { key, ...rest } of keys2) {
        const parsedKey = await (0, key_1.parseKey)(key);
        keychain[parsedKey.fingerprint] = {
          key: parsedKey,
          ...rest
        };
      }
      return keychain;
    }
    exports2.importKeychain = importKeychain;
    function importKeychainSync(encryptedKeychain, masterKey) {
      const json = (0, message_1.decryptStringSync)(encryptedKeychain, masterKey);
      const keys2 = JSON.parse(json);
      const keychain = {};
      for (const { key, ...rest } of keys2) {
        const parsedKey = (0, key_1.parseKeySync)(key);
        keychain[parsedKey.fingerprint] = {
          key: parsedKey,
          ...rest
        };
      }
      return keychain;
    }
    exports2.importKeychainSync = importKeychainSync;
    async function exportKeychain(keychain, masterKey) {
      const rawEntries = Object.values(keychain);
      const entries2 = [];
      for (const entry of rawEntries) {
        entries2.push({
          key: await (0, key_1.serializeKey)(entry.key),
          createdAt: entry.createdAt,
          label: entry.label
        });
      }
      return await (0, message_1.encryptString)(JSON.stringify(entries2), masterKey);
    }
    exports2.exportKeychain = exportKeychain;
    function exportKeychainSync(keychain, masterKey) {
      const rawEntries = Object.values(keychain);
      const entries2 = [];
      for (const entry of rawEntries) {
        entries2.push({
          key: (0, key_1.formatKey)(entry.key.raw),
          createdAt: entry.createdAt,
          label: entry.label
        });
      }
      return (0, message_1.encryptStringSync)(JSON.stringify(entries2), masterKey);
    }
    exports2.exportKeychainSync = exportKeychainSync;
    function findKeyForMessage(message, keychain) {
      const fingerprint = (0, message_1.getMessageKeyFingerprint)(message);
      if (!(fingerprint in keychain)) {
        throw new Error("Key is not available");
      }
      return keychain[fingerprint].key;
    }
    exports2.findKeyForMessage = findKeyForMessage;
    function getKeyAge(fingerprint, keychain, now = Date.now()) {
      if (!(fingerprint in keychain)) {
        throw new Error("Key is not available");
      }
      return now - keychain[fingerprint].createdAt;
    }
    exports2.getKeyAge = getKeyAge;
  }
});

// node_modules/@47ng/cloak/dist/index.js
var require_dist2 = __commonJS2({
  "node_modules/@47ng/cloak/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeKey = exports2.parseKeySync = exports2.parseKey = exports2.generateKey = exports2.exportCryptoKey = exports2.cloakKeyRegex = void 0;
    var key_1 = require_key();
    Object.defineProperty(exports2, "cloakKeyRegex", { enumerable: true, get: function() {
      return key_1.cloakKeyRegex;
    } });
    Object.defineProperty(exports2, "exportCryptoKey", { enumerable: true, get: function() {
      return key_1.exportCryptoKey;
    } });
    Object.defineProperty(exports2, "generateKey", { enumerable: true, get: function() {
      return key_1.generateKey;
    } });
    Object.defineProperty(exports2, "parseKey", { enumerable: true, get: function() {
      return key_1.parseKey;
    } });
    Object.defineProperty(exports2, "parseKeySync", { enumerable: true, get: function() {
      return key_1.parseKeySync;
    } });
    Object.defineProperty(exports2, "serializeKey", { enumerable: true, get: function() {
      return key_1.serializeKey;
    } });
    __exportStar(require_keychain(), exports2);
    __exportStar(require_message(), exports2);
  }
});

// node_modules/immer/dist/immer.cjs.production.min.js
var require_immer_cjs_production_min = __commonJS2({
  "node_modules/immer/dist/immer.cjs.production.min.js"(exports2) {
    function n(n2) {
      for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e2 = 1; e2 < r2; e2++)
        t2[e2 - 1] = arguments[e2];
      throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
        return "'" + n3 + "'";
      }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
    }
    function r(n2) {
      return !!n2 && !!n2[H];
    }
    function t(n2) {
      var r2;
      return !!n2 && (function(n3) {
        if (!n3 || "object" != typeof n3)
          return false;
        var r3 = Object.getPrototypeOf(n3);
        if (null === r3)
          return true;
        var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
        return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Q;
      }(n2) || Array.isArray(n2) || !!n2[G] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[G]) || c(n2) || v(n2));
    }
    function e(n2, r2, t2) {
      void 0 === t2 && (t2 = false), 0 === i(n2) ? (t2 ? Object.keys : T)(n2).forEach(function(e2) {
        t2 && "symbol" == typeof e2 || r2(e2, n2[e2], n2);
      }) : n2.forEach(function(t3, e2) {
        return r2(e2, t3, n2);
      });
    }
    function i(n2) {
      var r2 = n2[H];
      return r2 ? r2.t > 3 ? r2.t - 4 : r2.t : Array.isArray(n2) ? 1 : c(n2) ? 2 : v(n2) ? 3 : 0;
    }
    function u(n2, r2) {
      return 2 === i(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
    }
    function o(n2, r2) {
      return 2 === i(n2) ? n2.get(r2) : n2[r2];
    }
    function f(n2, r2, t2) {
      var e2 = i(n2);
      2 === e2 ? n2.set(r2, t2) : 3 === e2 ? (n2.delete(r2), n2.add(t2)) : n2[r2] = t2;
    }
    function a(n2, r2) {
      return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
    }
    function c(n2) {
      return W && n2 instanceof Map;
    }
    function v(n2) {
      return X && n2 instanceof Set;
    }
    function s(n2) {
      return n2.i || n2.u;
    }
    function p(n2) {
      if (Array.isArray(n2))
        return Array.prototype.slice.call(n2);
      var r2 = U(n2);
      delete r2[H];
      for (var t2 = T(r2), e2 = 0; e2 < t2.length; e2++) {
        var i2 = t2[e2], u2 = r2[i2];
        false === u2.writable && (u2.writable = true, u2.configurable = true), (u2.get || u2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: u2.enumerable, value: n2[i2] });
      }
      return Object.create(Object.getPrototypeOf(n2), r2);
    }
    function l(n2, u2) {
      return void 0 === u2 && (u2 = false), h(n2) || r(n2) || !t(n2) || (i(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = d), Object.freeze(n2), u2 && e(n2, function(n3, r2) {
        return l(r2, true);
      }, true)), n2;
    }
    function d() {
      n(2);
    }
    function h(n2) {
      return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
    }
    function y(r2) {
      var t2 = V[r2];
      return t2 || n(18, r2), t2;
    }
    function _(n2, r2) {
      V[n2] || (V[n2] = r2);
    }
    function b() {
      return I;
    }
    function m(n2, r2) {
      r2 && (y("Patches"), n2.o = [], n2.v = [], n2.s = r2);
    }
    function j(n2) {
      O(n2), n2.p.forEach(w), n2.p = null;
    }
    function O(n2) {
      n2 === I && (I = n2.l);
    }
    function x(n2) {
      return I = { p: [], l: I, h: n2, _: true, m: 0 };
    }
    function w(n2) {
      var r2 = n2[H];
      0 === r2.t || 1 === r2.t ? r2.j() : r2.O = true;
    }
    function S(r2, e2) {
      e2.m = e2.p.length;
      var i2 = e2.p[0], u2 = void 0 !== r2 && r2 !== i2;
      return e2.h.S || y("ES5").P(e2, r2, u2), u2 ? (i2[H].M && (j(e2), n(4)), t(r2) && (r2 = P3(e2, r2), e2.l || g(e2, r2)), e2.o && y("Patches").g(i2[H].u, r2, e2.o, e2.v)) : r2 = P3(e2, i2, []), j(e2), e2.o && e2.s(e2.o, e2.v), r2 !== B ? r2 : void 0;
    }
    function P3(n2, r2, t2) {
      if (h(r2))
        return r2;
      var i2 = r2[H];
      if (!i2)
        return e(r2, function(e2, u3) {
          return M(n2, i2, r2, e2, u3, t2);
        }, true), r2;
      if (i2.A !== n2)
        return r2;
      if (!i2.M)
        return g(n2, i2.u, true), i2.u;
      if (!i2.R) {
        i2.R = true, i2.A.m--;
        var u2 = 4 === i2.t || 5 === i2.t ? i2.i = p(i2.k) : i2.i;
        e(3 === i2.t ? new Set(u2) : u2, function(r3, e2) {
          return M(n2, i2, u2, r3, e2, t2);
        }), g(n2, u2, false), t2 && n2.o && y("Patches").F(i2, t2, n2.o, n2.v);
      }
      return i2.i;
    }
    function M(n2, e2, i2, o2, a2, c2) {
      if (r(a2)) {
        var v2 = P3(n2, a2, c2 && e2 && 3 !== e2.t && !u(e2.N, o2) ? c2.concat(o2) : void 0);
        if (f(i2, o2, v2), !r(v2))
          return;
        n2._ = false;
      }
      if (t(a2) && !h(a2)) {
        if (!n2.h.D && n2.m < 1)
          return;
        P3(n2, a2), e2 && e2.A.l || g(n2, a2);
      }
    }
    function g(n2, r2, t2) {
      void 0 === t2 && (t2 = false), n2.h.D && n2._ && l(r2, t2);
    }
    function A(n2, r2) {
      var t2 = n2[H];
      return (t2 ? s(t2) : n2)[r2];
    }
    function z(n2, r2) {
      if (r2 in n2)
        for (var t2 = Object.getPrototypeOf(n2); t2; ) {
          var e2 = Object.getOwnPropertyDescriptor(t2, r2);
          if (e2)
            return e2;
          t2 = Object.getPrototypeOf(t2);
        }
    }
    function E(n2) {
      n2.M || (n2.M = true, n2.l && E(n2.l));
    }
    function R(n2) {
      n2.i || (n2.i = p(n2.u));
    }
    function k(n2, r2, t2) {
      var e2 = c(r2) ? y("MapSet").K(r2, t2) : v(r2) ? y("MapSet").$(r2, t2) : n2.S ? function(n3, r3) {
        var t3 = Array.isArray(n3), e3 = { t: t3 ? 1 : 0, A: r3 ? r3.A : b(), M: false, R: false, N: {}, l: r3, u: n3, k: null, i: null, j: null, C: false }, i2 = e3, u2 = Y;
        t3 && (i2 = [e3], u2 = Z);
        var o2 = Proxy.revocable(i2, u2), f2 = o2.revoke, a2 = o2.proxy;
        return e3.k = a2, e3.j = f2, a2;
      }(r2, t2) : y("ES5").I(r2, t2);
      return (t2 ? t2.A : b()).p.push(e2), e2;
    }
    function F(u2) {
      return r(u2) || n(22, u2), function n2(r2) {
        if (!t(r2))
          return r2;
        var u3, a2 = r2[H], c2 = i(r2);
        if (a2) {
          if (!a2.M && (a2.t < 4 || !y("ES5").J(a2)))
            return a2.u;
          a2.R = true, u3 = N(r2, c2), a2.R = false;
        } else
          u3 = N(r2, c2);
        return e(u3, function(r3, t2) {
          a2 && o(a2.u, r3) === t2 || f(u3, r3, n2(t2));
        }), 3 === c2 ? new Set(u3) : u3;
      }(u2);
    }
    function N(n2, r2) {
      switch (r2) {
        case 2:
          return new Map(n2);
        case 3:
          return Array.from(n2);
      }
      return p(n2);
    }
    function D() {
      function n2(n3, r2) {
        var t3 = f2[n3];
        return t3 ? t3.enumerable = r2 : f2[n3] = t3 = { configurable: true, enumerable: r2, get: function() {
          return Y.get(this[H], n3);
        }, set: function(r3) {
          Y.set(this[H], n3, r3);
        } }, t3;
      }
      function t2(n3) {
        for (var r2 = n3.length - 1; r2 >= 0; r2--) {
          var t3 = n3[r2][H];
          if (!t3.M)
            switch (t3.t) {
              case 5:
                o2(t3) && E(t3);
                break;
              case 4:
                i2(t3) && E(t3);
            }
        }
      }
      function i2(n3) {
        for (var r2 = n3.u, t3 = n3.k, e2 = T(t3), i3 = e2.length - 1; i3 >= 0; i3--) {
          var o3 = e2[i3];
          if (o3 !== H) {
            var f3 = r2[o3];
            if (void 0 === f3 && !u(r2, o3))
              return true;
            var c2 = t3[o3], v2 = c2 && c2[H];
            if (v2 ? v2.u !== f3 : !a(c2, f3))
              return true;
          }
        }
        var s2 = !!r2[H];
        return e2.length !== T(r2).length + (s2 ? 0 : 1);
      }
      function o2(n3) {
        var r2 = n3.k;
        if (r2.length !== n3.u.length)
          return true;
        var t3 = Object.getOwnPropertyDescriptor(r2, r2.length - 1);
        if (t3 && !t3.get)
          return true;
        for (var e2 = 0; e2 < r2.length; e2++)
          if (!r2.hasOwnProperty(e2))
            return true;
        return false;
      }
      var f2 = {};
      _("ES5", { I: function(r2, t3) {
        var e2 = Array.isArray(r2), i3 = function(r3, t4) {
          if (r3) {
            for (var e3 = Array(t4.length), i4 = 0; i4 < t4.length; i4++)
              Object.defineProperty(e3, "" + i4, n2(i4, true));
            return e3;
          }
          var u3 = U(t4);
          delete u3[H];
          for (var o3 = T(u3), f3 = 0; f3 < o3.length; f3++) {
            var a2 = o3[f3];
            u3[a2] = n2(a2, r3 || !!u3[a2].enumerable);
          }
          return Object.create(Object.getPrototypeOf(t4), u3);
        }(e2, r2), u2 = { t: e2 ? 5 : 4, A: t3 ? t3.A : b(), M: false, R: false, N: {}, l: t3, u: r2, k: i3, i: null, O: false, C: false };
        return Object.defineProperty(i3, H, { value: u2, writable: true }), i3;
      }, P: function(n3, i3, f3) {
        f3 ? r(i3) && i3[H].A === n3 && t2(n3.p) : (n3.o && function n4(r2) {
          if (r2 && "object" == typeof r2) {
            var t3 = r2[H];
            if (t3) {
              var i4 = t3.u, f4 = t3.k, a2 = t3.N, c2 = t3.t;
              if (4 === c2)
                e(f4, function(r3) {
                  r3 !== H && (void 0 !== i4[r3] || u(i4, r3) ? a2[r3] || n4(f4[r3]) : (a2[r3] = true, E(t3)));
                }), e(i4, function(n5) {
                  void 0 !== f4[n5] || u(f4, n5) || (a2[n5] = false, E(t3));
                });
              else if (5 === c2) {
                if (o2(t3) && (E(t3), a2.length = true), f4.length < i4.length)
                  for (var v2 = f4.length; v2 < i4.length; v2++)
                    a2[v2] = false;
                else
                  for (var s2 = i4.length; s2 < f4.length; s2++)
                    a2[s2] = true;
                for (var p2 = Math.min(f4.length, i4.length), l2 = 0; l2 < p2; l2++)
                  f4.hasOwnProperty(l2) || (a2[l2] = true), void 0 === a2[l2] && n4(f4[l2]);
              }
            }
          }
        }(n3.p[0]), t2(n3.p));
      }, J: function(n3) {
        return 4 === n3.t ? i2(n3) : o2(n3);
      } });
    }
    function K() {
      function f2(n2) {
        if (!t(n2))
          return n2;
        if (Array.isArray(n2))
          return n2.map(f2);
        if (c(n2))
          return new Map(Array.from(n2.entries()).map(function(n3) {
            return [n3[0], f2(n3[1])];
          }));
        if (v(n2))
          return new Set(Array.from(n2).map(f2));
        var r2 = Object.create(Object.getPrototypeOf(n2));
        for (var e2 in n2)
          r2[e2] = f2(n2[e2]);
        return u(n2, G) && (r2[G] = n2[G]), r2;
      }
      function a2(n2) {
        return r(n2) ? f2(n2) : n2;
      }
      var s2 = "add";
      _("Patches", { W: function(r2, t2) {
        return t2.forEach(function(t3) {
          for (var e2 = t3.path, u2 = t3.op, a3 = r2, c2 = 0; c2 < e2.length - 1; c2++) {
            var v2 = i(a3), p2 = "" + e2[c2];
            0 !== v2 && 1 !== v2 || "__proto__" !== p2 && "constructor" !== p2 || n(24), "function" == typeof a3 && "prototype" === p2 && n(24), "object" != typeof (a3 = o(a3, p2)) && n(15, e2.join("/"));
          }
          var l2 = i(a3), d2 = f2(t3.value), h2 = e2[e2.length - 1];
          switch (u2) {
            case "replace":
              switch (l2) {
                case 2:
                  return a3.set(h2, d2);
                case 3:
                  n(16);
                default:
                  return a3[h2] = d2;
              }
            case s2:
              switch (l2) {
                case 1:
                  return "-" === h2 ? a3.push(d2) : a3.splice(h2, 0, d2);
                case 2:
                  return a3.set(h2, d2);
                case 3:
                  return a3.add(d2);
                default:
                  return a3[h2] = d2;
              }
            case "remove":
              switch (l2) {
                case 1:
                  return a3.splice(h2, 1);
                case 2:
                  return a3.delete(h2);
                case 3:
                  return a3.delete(t3.value);
                default:
                  return delete a3[h2];
              }
            default:
              n(17, u2);
          }
        }), r2;
      }, F: function(n2, r2, t2, i2) {
        switch (n2.t) {
          case 0:
          case 4:
          case 2:
            return function(n3, r3, t3, i3) {
              var f3 = n3.u, c2 = n3.i;
              e(n3.N, function(n4, e2) {
                var v2 = o(f3, n4), p2 = o(c2, n4), l2 = e2 ? u(f3, n4) ? "replace" : s2 : "remove";
                if (v2 !== p2 || "replace" !== l2) {
                  var d2 = r3.concat(n4);
                  t3.push("remove" === l2 ? { op: l2, path: d2 } : { op: l2, path: d2, value: p2 }), i3.push(l2 === s2 ? { op: "remove", path: d2 } : "remove" === l2 ? { op: s2, path: d2, value: a2(v2) } : { op: "replace", path: d2, value: a2(v2) });
                }
              });
            }(n2, r2, t2, i2);
          case 5:
          case 1:
            return function(n3, r3, t3, e2) {
              var i3 = n3.u, u2 = n3.N, o2 = n3.i;
              if (o2.length < i3.length) {
                var f3 = [o2, i3];
                i3 = f3[0], o2 = f3[1];
                var c2 = [e2, t3];
                t3 = c2[0], e2 = c2[1];
              }
              for (var v2 = 0; v2 < i3.length; v2++)
                if (u2[v2] && o2[v2] !== i3[v2]) {
                  var p2 = r3.concat([v2]);
                  t3.push({ op: "replace", path: p2, value: a2(o2[v2]) }), e2.push({ op: "replace", path: p2, value: a2(i3[v2]) });
                }
              for (var l2 = i3.length; l2 < o2.length; l2++) {
                var d2 = r3.concat([l2]);
                t3.push({ op: s2, path: d2, value: a2(o2[l2]) });
              }
              i3.length < o2.length && e2.push({ op: "replace", path: r3.concat(["length"]), value: i3.length });
            }(n2, r2, t2, i2);
          case 3:
            return function(n3, r3, t3, e2) {
              var i3 = n3.u, u2 = n3.i, o2 = 0;
              i3.forEach(function(n4) {
                if (!u2.has(n4)) {
                  var i4 = r3.concat([o2]);
                  t3.push({ op: "remove", path: i4, value: n4 }), e2.unshift({ op: s2, path: i4, value: n4 });
                }
                o2++;
              }), o2 = 0, u2.forEach(function(n4) {
                if (!i3.has(n4)) {
                  var u3 = r3.concat([o2]);
                  t3.push({ op: s2, path: u3, value: n4 }), e2.unshift({ op: "remove", path: u3, value: n4 });
                }
                o2++;
              });
            }(n2, r2, t2, i2);
        }
      }, g: function(n2, r2, t2, e2) {
        t2.push({ op: "replace", path: [], value: r2 === B ? void 0 : r2 }), e2.push({ op: "replace", path: [], value: n2 });
      } });
    }
    function $() {
      function r2(n2, r3) {
        function t2() {
          this.constructor = n2;
        }
        f2(n2, r3), n2.prototype = (t2.prototype = r3.prototype, new t2());
      }
      function i2(n2) {
        n2.i || (n2.N = /* @__PURE__ */ new Map(), n2.i = new Map(n2.u));
      }
      function u2(n2) {
        n2.i || (n2.i = /* @__PURE__ */ new Set(), n2.u.forEach(function(r3) {
          if (t(r3)) {
            var e2 = k(n2.A.h, r3, n2);
            n2.p.set(r3, e2), n2.i.add(e2);
          } else
            n2.i.add(r3);
        }));
      }
      function o2(r3) {
        r3.O && n(3, JSON.stringify(s(r3)));
      }
      var f2 = function(n2, r3) {
        return (f2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r4) {
          n3.__proto__ = r4;
        } || function(n3, r4) {
          for (var t2 in r4)
            r4.hasOwnProperty(t2) && (n3[t2] = r4[t2]);
        })(n2, r3);
      }, a2 = function() {
        function n2(n3, r3) {
          return this[H] = { t: 2, l: r3, A: r3 ? r3.A : b(), M: false, R: false, i: void 0, N: void 0, u: n3, k: this, C: false, O: false }, this;
        }
        r2(n2, Map);
        var u3 = n2.prototype;
        return Object.defineProperty(u3, "size", { get: function() {
          return s(this[H]).size;
        } }), u3.has = function(n3) {
          return s(this[H]).has(n3);
        }, u3.set = function(n3, r3) {
          var t2 = this[H];
          return o2(t2), s(t2).has(n3) && s(t2).get(n3) === r3 || (i2(t2), E(t2), t2.N.set(n3, true), t2.i.set(n3, r3), t2.N.set(n3, true)), this;
        }, u3.delete = function(n3) {
          if (!this.has(n3))
            return false;
          var r3 = this[H];
          return o2(r3), i2(r3), E(r3), r3.u.has(n3) ? r3.N.set(n3, false) : r3.N.delete(n3), r3.i.delete(n3), true;
        }, u3.clear = function() {
          var n3 = this[H];
          o2(n3), s(n3).size && (i2(n3), E(n3), n3.N = /* @__PURE__ */ new Map(), e(n3.u, function(r3) {
            n3.N.set(r3, false);
          }), n3.i.clear());
        }, u3.forEach = function(n3, r3) {
          var t2 = this;
          s(this[H]).forEach(function(e2, i3) {
            n3.call(r3, t2.get(i3), i3, t2);
          });
        }, u3.get = function(n3) {
          var r3 = this[H];
          o2(r3);
          var e2 = s(r3).get(n3);
          if (r3.R || !t(e2))
            return e2;
          if (e2 !== r3.u.get(n3))
            return e2;
          var u4 = k(r3.A.h, e2, r3);
          return i2(r3), r3.i.set(n3, u4), u4;
        }, u3.keys = function() {
          return s(this[H]).keys();
        }, u3.values = function() {
          var n3, r3 = this, t2 = this.keys();
          return (n3 = {})[L] = function() {
            return r3.values();
          }, n3.next = function() {
            var n4 = t2.next();
            return n4.done ? n4 : { done: false, value: r3.get(n4.value) };
          }, n3;
        }, u3.entries = function() {
          var n3, r3 = this, t2 = this.keys();
          return (n3 = {})[L] = function() {
            return r3.entries();
          }, n3.next = function() {
            var n4 = t2.next();
            if (n4.done)
              return n4;
            var e2 = r3.get(n4.value);
            return { done: false, value: [n4.value, e2] };
          }, n3;
        }, u3[L] = function() {
          return this.entries();
        }, n2;
      }(), c2 = function() {
        function n2(n3, r3) {
          return this[H] = { t: 3, l: r3, A: r3 ? r3.A : b(), M: false, R: false, i: void 0, u: n3, k: this, p: /* @__PURE__ */ new Map(), O: false, C: false }, this;
        }
        r2(n2, Set);
        var t2 = n2.prototype;
        return Object.defineProperty(t2, "size", { get: function() {
          return s(this[H]).size;
        } }), t2.has = function(n3) {
          var r3 = this[H];
          return o2(r3), r3.i ? !!r3.i.has(n3) || !(!r3.p.has(n3) || !r3.i.has(r3.p.get(n3))) : r3.u.has(n3);
        }, t2.add = function(n3) {
          var r3 = this[H];
          return o2(r3), this.has(n3) || (u2(r3), E(r3), r3.i.add(n3)), this;
        }, t2.delete = function(n3) {
          if (!this.has(n3))
            return false;
          var r3 = this[H];
          return o2(r3), u2(r3), E(r3), r3.i.delete(n3) || !!r3.p.has(n3) && r3.i.delete(r3.p.get(n3));
        }, t2.clear = function() {
          var n3 = this[H];
          o2(n3), s(n3).size && (u2(n3), E(n3), n3.i.clear());
        }, t2.values = function() {
          var n3 = this[H];
          return o2(n3), u2(n3), n3.i.values();
        }, t2.entries = function() {
          var n3 = this[H];
          return o2(n3), u2(n3), n3.i.entries();
        }, t2.keys = function() {
          return this.values();
        }, t2[L] = function() {
          return this.values();
        }, t2.forEach = function(n3, r3) {
          for (var t3 = this.values(), e2 = t3.next(); !e2.done; )
            n3.call(r3, e2.value, e2.value, this), e2 = t3.next();
        }, n2;
      }();
      _("MapSet", { K: function(n2, r3) {
        return new a2(n2, r3);
      }, $: function(n2, r3) {
        return new c2(n2, r3);
      } });
    }
    var C;
    Object.defineProperty(exports2, "__esModule", { value: true });
    var I;
    var J = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
    var W = "undefined" != typeof Map;
    var X = "undefined" != typeof Set;
    var q = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
    var B = J ? Symbol.for("immer-nothing") : ((C = {})["immer-nothing"] = true, C);
    var G = J ? Symbol.for("immer-draftable") : "__$immer_draftable";
    var H = J ? Symbol.for("immer-state") : "__$immer_state";
    var L = "undefined" != typeof Symbol && Symbol.iterator || "@@iterator";
    var Q = "" + Object.prototype.constructor;
    var T = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
      return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
    } : Object.getOwnPropertyNames;
    var U = Object.getOwnPropertyDescriptors || function(n2) {
      var r2 = {};
      return T(n2).forEach(function(t2) {
        r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
      }), r2;
    };
    var V = {};
    var Y = { get: function(n2, r2) {
      if (r2 === H)
        return n2;
      var e2 = s(n2);
      if (!u(e2, r2))
        return function(n3, r3, t2) {
          var e3, i3 = z(r3, t2);
          return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
        }(n2, e2, r2);
      var i2 = e2[r2];
      return n2.R || !t(i2) ? i2 : i2 === A(n2.u, r2) ? (R(n2), n2.i[r2] = k(n2.A.h, i2, n2)) : i2;
    }, has: function(n2, r2) {
      return r2 in s(n2);
    }, ownKeys: function(n2) {
      return Reflect.ownKeys(s(n2));
    }, set: function(n2, r2, t2) {
      var e2 = z(s(n2), r2);
      if (null == e2 ? void 0 : e2.set)
        return e2.set.call(n2.k, t2), true;
      if (!n2.M) {
        var i2 = A(s(n2), r2), o2 = null == i2 ? void 0 : i2[H];
        if (o2 && o2.u === t2)
          return n2.i[r2] = t2, n2.N[r2] = false, true;
        if (a(t2, i2) && (void 0 !== t2 || u(n2.u, r2)))
          return true;
        R(n2), E(n2);
      }
      return n2.i[r2] === t2 && (void 0 !== t2 || r2 in n2.i) || Number.isNaN(t2) && Number.isNaN(n2.i[r2]) || (n2.i[r2] = t2, n2.N[r2] = true), true;
    }, deleteProperty: function(n2, r2) {
      return void 0 !== A(n2.u, r2) || r2 in n2.u ? (n2.N[r2] = false, R(n2), E(n2)) : delete n2.N[r2], n2.i && delete n2.i[r2], true;
    }, getOwnPropertyDescriptor: function(n2, r2) {
      var t2 = s(n2), e2 = Reflect.getOwnPropertyDescriptor(t2, r2);
      return e2 ? { writable: true, configurable: 1 !== n2.t || "length" !== r2, enumerable: e2.enumerable, value: t2[r2] } : e2;
    }, defineProperty: function() {
      n(11);
    }, getPrototypeOf: function(n2) {
      return Object.getPrototypeOf(n2.u);
    }, setPrototypeOf: function() {
      n(12);
    } };
    var Z = {};
    e(Y, function(n2, r2) {
      Z[n2] = function() {
        return arguments[0] = arguments[0][0], r2.apply(this, arguments);
      };
    }), Z.deleteProperty = function(n2, r2) {
      return Z.set.call(this, n2, r2, void 0);
    }, Z.set = function(n2, r2, t2) {
      return Y.set.call(this, n2[0], r2, t2, n2[0]);
    };
    var nn = function() {
      function e2(r2) {
        var e3 = this;
        this.S = q, this.D = true, this.produce = function(r3, i3, u2) {
          if ("function" == typeof r3 && "function" != typeof i3) {
            var o2 = i3;
            i3 = r3;
            var f2 = e3;
            return function(n2) {
              var r4 = this;
              void 0 === n2 && (n2 = o2);
              for (var t2 = arguments.length, e4 = Array(t2 > 1 ? t2 - 1 : 0), u3 = 1; u3 < t2; u3++)
                e4[u3 - 1] = arguments[u3];
              return f2.produce(n2, function(n3) {
                var t3;
                return (t3 = i3).call.apply(t3, [r4, n3].concat(e4));
              });
            };
          }
          var a2;
          if ("function" != typeof i3 && n(6), void 0 !== u2 && "function" != typeof u2 && n(7), t(r3)) {
            var c2 = x(e3), v2 = k(e3, r3, void 0), s2 = true;
            try {
              a2 = i3(v2), s2 = false;
            } finally {
              s2 ? j(c2) : O(c2);
            }
            return "undefined" != typeof Promise && a2 instanceof Promise ? a2.then(function(n2) {
              return m(c2, u2), S(n2, c2);
            }, function(n2) {
              throw j(c2), n2;
            }) : (m(c2, u2), S(a2, c2));
          }
          if (!r3 || "object" != typeof r3) {
            if (void 0 === (a2 = i3(r3)) && (a2 = r3), a2 === B && (a2 = void 0), e3.D && l(a2, true), u2) {
              var p2 = [], d2 = [];
              y("Patches").g(r3, a2, p2, d2), u2(p2, d2);
            }
            return a2;
          }
          n(21, r3);
        }, this.produceWithPatches = function(n2, r3) {
          if ("function" == typeof n2)
            return function(r4) {
              for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), u3 = 1; u3 < t3; u3++)
                i4[u3 - 1] = arguments[u3];
              return e3.produceWithPatches(r4, function(r5) {
                return n2.apply(void 0, [r5].concat(i4));
              });
            };
          var t2, i3, u2 = e3.produce(n2, r3, function(n3, r4) {
            t2 = n3, i3 = r4;
          });
          return "undefined" != typeof Promise && u2 instanceof Promise ? u2.then(function(n3) {
            return [n3, t2, i3];
          }) : [u2, t2, i3];
        }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
      }
      var i2 = e2.prototype;
      return i2.createDraft = function(e3) {
        t(e3) || n(8), r(e3) && (e3 = F(e3));
        var i3 = x(this), u2 = k(this, e3, void 0);
        return u2[H].C = true, O(i3), u2;
      }, i2.finishDraft = function(n2, r2) {
        var t2 = (n2 && n2[H]).A;
        return m(t2, r2), S(void 0, t2);
      }, i2.setAutoFreeze = function(n2) {
        this.D = n2;
      }, i2.setUseProxies = function(r2) {
        r2 && !q && n(20), this.S = r2;
      }, i2.applyPatches = function(n2, t2) {
        var e3;
        for (e3 = t2.length - 1; e3 >= 0; e3--) {
          var i3 = t2[e3];
          if (0 === i3.path.length && "replace" === i3.op) {
            n2 = i3.value;
            break;
          }
        }
        e3 > -1 && (t2 = t2.slice(e3 + 1));
        var u2 = y("Patches").W;
        return r(n2) ? u2(n2, t2) : this.produce(n2, function(n3) {
          return u2(n3, t2);
        });
      }, e2;
    }();
    var rn = new nn();
    var tn = rn.produce;
    var en = rn.produceWithPatches.bind(rn);
    var un = rn.setAutoFreeze.bind(rn);
    var on = rn.setUseProxies.bind(rn);
    var fn = rn.applyPatches.bind(rn);
    var an = rn.createDraft.bind(rn);
    var cn = rn.finishDraft.bind(rn);
    exports2.Immer = nn, exports2.applyPatches = fn, exports2.castDraft = function(n2) {
      return n2;
    }, exports2.castImmutable = function(n2) {
      return n2;
    }, exports2.createDraft = an, exports2.current = F, exports2.default = tn, exports2.enableAllPlugins = function() {
      D(), $(), K();
    }, exports2.enableES5 = D, exports2.enableMapSet = $, exports2.enablePatches = K, exports2.finishDraft = cn, exports2.freeze = l, exports2.immerable = G, exports2.isDraft = r, exports2.isDraftable = t, exports2.nothing = B, exports2.original = function(t2) {
      return r(t2) || n(23, t2), t2[H].u;
    }, exports2.produce = tn, exports2.produceWithPatches = en, exports2.setAutoFreeze = un, exports2.setUseProxies = on;
  }
});

// node_modules/immer/dist/immer.cjs.development.js
var require_immer_cjs_development = __commonJS2({
  "node_modules/immer/dist/immer.cjs.development.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ref;
    var hasSymbol = typeof Symbol !== "undefined" && typeof /* @__PURE__ */ Symbol("x") === "symbol";
    var hasMap = typeof Map !== "undefined";
    var hasSet = typeof Set !== "undefined";
    var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
    var NOTHING = hasSymbol ? /* @__PURE__ */ Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
    var DRAFTABLE = hasSymbol ? /* @__PURE__ */ Symbol.for("immer-draftable") : "__$immer_draftable";
    var DRAFT_STATE = hasSymbol ? /* @__PURE__ */ Symbol.for("immer-state") : "__$immer_state";
    var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
    var errors = {
      0: "Illegal state",
      1: "Immer drafts cannot have computed properties",
      2: "This object has been frozen and should not be mutated",
      3: function _(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
      },
      4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
      5: "Immer forbids circular references",
      6: "The first or second argument to `produce` must be a function",
      7: "The third argument to `produce` must be a function or undefined",
      8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
      9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
      10: "The given draft is already finalized",
      11: "Object.defineProperty() cannot be used on an Immer draft",
      12: "Object.setPrototypeOf() cannot be used on an Immer draft",
      13: "Immer only supports deleting array indices",
      14: "Immer only supports setting array indices and the 'length' property",
      15: function _(path2) {
        return "Cannot apply patch, path doesn't resolve: " + path2;
      },
      16: 'Sets cannot have "replace" patches.',
      17: function _(op) {
        return "Unsupported patch operation: " + op;
      },
      18: function _(plugin) {
        return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
      },
      20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
      21: function _(thing) {
        return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
      },
      22: function _(thing) {
        return "'current' expects a draft, got: " + thing;
      },
      23: function _(thing) {
        return "'original' expects a draft, got: " + thing;
      },
      24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
    };
    function die(error2) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      {
        var e = errors[error2];
        var msg = !e ? "unknown error nr: " + error2 : typeof e === "function" ? e.apply(null, args) : e;
        throw new Error("[Immer] " + msg);
      }
    }
    function isDraft(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable(value) {
      var _value$constructor;
      if (!value)
        return false;
      return isPlainObject4(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
    }
    var objectCtorString2 = /* @__PURE__ */ Object.prototype.constructor.toString();
    function isPlainObject4(value) {
      if (!value || typeof value !== "object")
        return false;
      var proto = Object.getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString2;
    }
    function original(value) {
      if (!isDraft(value))
        die(23, value);
      return value[DRAFT_STATE].base_;
    }
    var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function(obj) {
      return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
    } : (
      /* istanbul ignore next */
      Object.getOwnPropertyNames
    );
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
      var res = {};
      ownKeys(target).forEach(function(key) {
        res[key] = Object.getOwnPropertyDescriptor(target, key);
      });
      return res;
    };
    function each(obj, iter, enumerableOnly) {
      if (enumerableOnly === void 0) {
        enumerableOnly = false;
      }
      if (getArchtype(obj) === 0) {
        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function(key) {
          if (!enumerableOnly || typeof key !== "symbol")
            iter(key, obj[key], obj);
        });
      } else {
        obj.forEach(function(entry, index) {
          return iter(index, entry, obj);
        });
      }
    }
    function getArchtype(thing) {
      var state = thing[DRAFT_STATE];
      return state ? state.type_ > 3 ? state.type_ - 4 : state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop) {
      return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
    }
    function get(thing, prop) {
      return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
    }
    function set(thing, propOrOldValue, value) {
      var t = getArchtype(thing);
      if (t === 2)
        thing.set(propOrOldValue, value);
      else if (t === 3) {
        thing.delete(propOrOldValue);
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is2(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function isMap(target) {
      return hasMap && target instanceof Map;
    }
    function isSet(target) {
      return hasSet && target instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base) {
      if (Array.isArray(base))
        return Array.prototype.slice.call(base);
      var descriptors2 = getOwnPropertyDescriptors(base);
      delete descriptors2[DRAFT_STATE];
      var keys2 = ownKeys(descriptors2);
      for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        var desc = descriptors2[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors2[key] = {
            configurable: true,
            writable: true,
            enumerable: desc.enumerable,
            value: base[key]
          };
      }
      return Object.create(Object.getPrototypeOf(base), descriptors2);
    }
    function freeze(obj, deep) {
      if (deep === void 0) {
        deep = false;
      }
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        each(obj, function(key, value) {
          return freeze(value, true);
        }, true);
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      if (obj == null || typeof obj !== "object")
        return true;
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      var plugin = plugins[pluginKey];
      if (!plugin) {
        die(18, pluginKey);
      }
      return plugin;
    }
    function loadPlugin(pluginKey, implementation) {
      if (!plugins[pluginKey])
        plugins[pluginKey] = implementation;
    }
    var currentScope;
    function getCurrentScope() {
      if (!currentScope)
        die(0);
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope) {
      leaveScope(scope);
      scope.drafts_.forEach(revokeDraft);
      scope.drafts_ = null;
    }
    function leaveScope(scope) {
      if (scope === currentScope) {
        currentScope = scope.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      var state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope) {
      scope.unfinalizedDrafts_ = scope.drafts_.length;
      var baseDraft = scope.drafts_[0];
      var isReplaced = result !== void 0 && result !== baseDraft;
      if (!scope.immer_.useProxies_)
        getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope, result);
          if (!scope.parent_)
            maybeFreeze(scope, result);
        }
        if (scope.patches_) {
          getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
        }
      } else {
        result = finalize(scope, baseDraft, []);
      }
      revokeScope(scope);
      if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path2) {
      if (isFrozen(value))
        return value;
      var state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          function(key, childValue) {
            return finalizeProperty(rootScope, state, value, key, childValue, path2);
          },
          true
          // See #590, don't recurse into non-enumerable of non drafted objects
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        var result = (
          // For ES5, create a good copy from the draft first, with added keys and without deleted keys.
          state.type_ === 4 || state.type_ === 5 ? state.copy_ = shallowCopy(state.draft_) : state.copy_
        );
        each(state.type_ === 3 ? new Set(result) : result, function(key, childValue) {
          return finalizeProperty(rootScope, state, result, key, childValue, path2);
        });
        maybeFreeze(rootScope, result, false);
        if (path2 && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(state, path2, rootScope.patches_, rootScope.inversePatches_);
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath) {
      if (childValue === targetObject)
        die(5);
      if (isDraft(childValue)) {
        var path2 = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        var res = finalize(rootScope, childValue, path2);
        set(targetObject, prop, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      }
      if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if (!parentState || !parentState.scope_.parent_)
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope, value, deep) {
      if (deep === void 0) {
        deep = false;
      }
      if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
      }
    }
    function createProxyProxy(base, parent) {
      var isArray3 = Array.isArray(base);
      var state = {
        type_: isArray3 ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
      };
      var target = state;
      var traps = objectTraps;
      if (isArray3) {
        target = [state];
        traps = arrayTraps;
      }
      var _Proxy$revocable = Proxy.revocable(target, traps), revoke = _Proxy$revocable.revoke, proxy = _Proxy$revocable.proxy;
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get: function get2(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        var source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        var value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);
        }
        return value;
      },
      has: function has2(state, prop) {
        return prop in latest(state);
      },
      ownKeys: function ownKeys2(state) {
        return Reflect.ownKeys(latest(state));
      },
      set: function set2(state, prop, value) {
        var desc = getDescriptorFromProto(latest(state), prop);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          var current2 = peek(latest(state), prop);
          var currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_[prop] = false;
            return true;
          }
          if (is2(value, current2) && (value !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
          return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty: function deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_)
          delete state.copy_[prop];
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
        var owner = latest(state);
        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty: function defineProperty() {
        die(11);
      },
      getPrototypeOf: function getPrototypeOf2(state) {
        return Object.getPrototypeOf(state.base_);
      },
      setPrototypeOf: function setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, function(key, fn) {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      if (isNaN(parseInt(prop)))
        die(13);
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value) {
      if (prop !== "length" && isNaN(parseInt(prop)))
        die(14);
      return objectTraps.set.call(this, state[0], prop, value, state[0]);
    };
    function peek(draft, prop) {
      var state = draft[DRAFT_STATE];
      var source = state ? latest(state) : draft;
      return source[prop];
    }
    function readPropFromProto(state, source, prop) {
      var _desc$get;
      var desc = getDescriptorFromProto(source, prop);
      return desc ? "value" in desc ? desc.value : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto(source, prop) {
      if (!(prop in source))
        return void 0;
      var proto = Object.getPrototypeOf(source);
      while (proto) {
        var desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = Object.getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(state.base_);
      }
    }
    var Immer = /* @__PURE__ */ function() {
      function Immer2(config2) {
        var _this = this;
        this.useProxies_ = hasProxies;
        this.autoFreeze_ = true;
        this.produce = function(base, recipe, patchListener) {
          if (typeof base === "function" && typeof recipe !== "function") {
            var defaultBase = recipe;
            recipe = base;
            var self2 = _this;
            return function curriedProduce(base2) {
              var _this2 = this;
              if (base2 === void 0) {
                base2 = defaultBase;
              }
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return self2.produce(base2, function(draft) {
                var _recipe;
                return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
              });
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          var result;
          if (isDraftable(base)) {
            var scope = enterScope(_this);
            var proxy = createProxy(_this, base, void 0);
            var hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope);
              else
                leaveScope(scope);
            }
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then(function(result2) {
                usePatchesInScope(scope, patchListener);
                return processResult(result2, scope);
              }, function(error2) {
                revokeScope(scope);
                throw error2;
              });
            }
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (_this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              var p = [];
              var ip = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
              patchListener(p, ip);
            }
            return result;
          } else
            die(21, base);
        };
        this.produceWithPatches = function(base, recipe) {
          if (typeof base === "function") {
            return function(state) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              return _this.produceWithPatches(state, function(draft) {
                return base.apply(void 0, [draft].concat(args));
              });
            };
          }
          var patches, inversePatches;
          var result = _this.produce(base, recipe, function(p, ip) {
            patches = p;
            inversePatches = ip;
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then(function(nextState) {
              return [nextState, patches, inversePatches];
            });
          }
          return [result, patches, inversePatches];
        };
        if (typeof (config2 === null || config2 === void 0 ? void 0 : config2.useProxies) === "boolean")
          this.setUseProxies(config2.useProxies);
        if (typeof (config2 === null || config2 === void 0 ? void 0 : config2.autoFreeze) === "boolean")
          this.setAutoFreeze(config2.autoFreeze);
      }
      var _proto = Immer2.prototype;
      _proto.createDraft = function createDraft2(base) {
        if (!isDraftable(base))
          die(8);
        if (isDraft(base))
          base = current(base);
        var scope = enterScope(this);
        var proxy = createProxy(this, base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
      };
      _proto.finishDraft = function finishDraft2(draft, patchListener) {
        var state = draft && draft[DRAFT_STATE];
        {
          if (!state || !state.isManual_)
            die(9);
          if (state.finalized_)
            die(10);
        }
        var scope = state.scope_;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
      };
      _proto.setAutoFreeze = function setAutoFreeze2(value) {
        this.autoFreeze_ = value;
      };
      _proto.setUseProxies = function setUseProxies2(value) {
        if (value && !hasProxies) {
          die(20);
        }
        this.useProxies_ = value;
      };
      _proto.applyPatches = function applyPatches2(base, patches) {
        var i;
        for (i = patches.length - 1; i >= 0; i--) {
          var patch = patches[i];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i > -1) {
          patches = patches.slice(i + 1);
        }
        var applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(base, function(draft) {
          return applyPatchesImpl(draft, patches);
        });
      };
      return Immer2;
    }();
    function createProxy(immer2, value, parent) {
      var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : immer2.useProxies_ ? createProxyProxy(value, parent) : getPlugin("ES5").createES5Proxy_(value, parent);
      var scope = parent ? parent.scope_ : getCurrentScope();
      scope.drafts_.push(draft);
      return draft;
    }
    function current(value) {
      if (!isDraft(value))
        die(22, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable(value))
        return value;
      var state = value[DRAFT_STATE];
      var copy;
      var archType = getArchtype(value);
      if (state) {
        if (!state.modified_ && (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state)))
          return state.base_;
        state.finalized_ = true;
        copy = copyHelper(value, archType);
        state.finalized_ = false;
      } else {
        copy = copyHelper(value, archType);
      }
      each(copy, function(key, childValue) {
        if (state && get(state.base_, key) === childValue)
          return;
        set(copy, key, currentImpl(childValue));
      });
      return archType === 3 ? new Set(copy) : copy;
    }
    function copyHelper(value, archType) {
      switch (archType) {
        case 2:
          return new Map(value);
        case 3:
          return Array.from(value);
      }
      return shallowCopy(value);
    }
    function enableES5() {
      function willFinalizeES5_(scope, result, isReplaced) {
        if (!isReplaced) {
          if (scope.patches_) {
            markChangesRecursively(scope.drafts_[0]);
          }
          markChangesSweep(scope.drafts_);
        } else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {
          markChangesSweep(scope.drafts_);
        }
      }
      function createES5Draft(isArray3, base) {
        if (isArray3) {
          var draft = new Array(base.length);
          for (var i = 0; i < base.length; i++) {
            Object.defineProperty(draft, "" + i, proxyProperty(i, true));
          }
          return draft;
        } else {
          var _descriptors = getOwnPropertyDescriptors(base);
          delete _descriptors[DRAFT_STATE];
          var keys2 = ownKeys(_descriptors);
          for (var _i = 0; _i < keys2.length; _i++) {
            var key = keys2[_i];
            _descriptors[key] = proxyProperty(key, isArray3 || !!_descriptors[key].enumerable);
          }
          return Object.create(Object.getPrototypeOf(base), _descriptors);
        }
      }
      function createES5Proxy_(base, parent) {
        var isArray3 = Array.isArray(base);
        var draft = createES5Draft(isArray3, base);
        var state = {
          type_: isArray3 ? 5 : 4,
          scope_: parent ? parent.scope_ : getCurrentScope(),
          modified_: false,
          finalized_: false,
          assigned_: {},
          parent_: parent,
          // base is the object we are drafting
          base_: base,
          // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)
          draft_: draft,
          copy_: null,
          revoked_: false,
          isManual_: false
        };
        Object.defineProperty(draft, DRAFT_STATE, {
          value: state,
          // enumerable: false <- the default
          writable: true
        });
        return draft;
      }
      var descriptors2 = {};
      function proxyProperty(prop, enumerable) {
        var desc = descriptors2[prop];
        if (desc) {
          desc.enumerable = enumerable;
        } else {
          descriptors2[prop] = desc = {
            configurable: true,
            enumerable,
            get: function get2() {
              var state = this[DRAFT_STATE];
              assertUnrevoked(state);
              return objectTraps.get(state, prop);
            },
            set: function set2(value) {
              var state = this[DRAFT_STATE];
              assertUnrevoked(state);
              objectTraps.set(state, prop, value);
            }
          };
        }
        return desc;
      }
      function markChangesSweep(drafts) {
        for (var i = drafts.length - 1; i >= 0; i--) {
          var state = drafts[i][DRAFT_STATE];
          if (!state.modified_) {
            switch (state.type_) {
              case 5:
                if (hasArrayChanges(state))
                  markChanged(state);
                break;
              case 4:
                if (hasObjectChanges(state))
                  markChanged(state);
                break;
            }
          }
        }
      }
      function markChangesRecursively(object) {
        if (!object || typeof object !== "object")
          return;
        var state = object[DRAFT_STATE];
        if (!state)
          return;
        var base_ = state.base_, draft_ = state.draft_, assigned_ = state.assigned_, type_ = state.type_;
        if (type_ === 4) {
          each(draft_, function(key) {
            if (key === DRAFT_STATE)
              return;
            if (base_[key] === void 0 && !has(base_, key)) {
              assigned_[key] = true;
              markChanged(state);
            } else if (!assigned_[key]) {
              markChangesRecursively(draft_[key]);
            }
          });
          each(base_, function(key) {
            if (draft_[key] === void 0 && !has(draft_, key)) {
              assigned_[key] = false;
              markChanged(state);
            }
          });
        } else if (type_ === 5) {
          if (hasArrayChanges(state)) {
            markChanged(state);
            assigned_.length = true;
          }
          if (draft_.length < base_.length) {
            for (var i = draft_.length; i < base_.length; i++) {
              assigned_[i] = false;
            }
          } else {
            for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {
              assigned_[_i2] = true;
            }
          }
          var min2 = Math.min(draft_.length, base_.length);
          for (var _i3 = 0; _i3 < min2; _i3++) {
            if (!draft_.hasOwnProperty(_i3)) {
              assigned_[_i3] = true;
            }
            if (assigned_[_i3] === void 0)
              markChangesRecursively(draft_[_i3]);
          }
        }
      }
      function hasObjectChanges(state) {
        var base_ = state.base_, draft_ = state.draft_;
        var keys2 = ownKeys(draft_);
        for (var i = keys2.length - 1; i >= 0; i--) {
          var key = keys2[i];
          if (key === DRAFT_STATE)
            continue;
          var baseValue = base_[key];
          if (baseValue === void 0 && !has(base_, key)) {
            return true;
          } else {
            var value = draft_[key];
            var _state = value && value[DRAFT_STATE];
            if (_state ? _state.base_ !== baseValue : !is2(value, baseValue)) {
              return true;
            }
          }
        }
        var baseIsDraft = !!base_[DRAFT_STATE];
        return keys2.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1);
      }
      function hasArrayChanges(state) {
        var draft_ = state.draft_;
        if (draft_.length !== state.base_.length)
          return true;
        var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);
        if (descriptor && !descriptor.get)
          return true;
        for (var i = 0; i < draft_.length; i++) {
          if (!draft_.hasOwnProperty(i))
            return true;
        }
        return false;
      }
      function hasChanges_(state) {
        return state.type_ === 4 ? hasObjectChanges(state) : hasArrayChanges(state);
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("ES5", {
        createES5Proxy_,
        willFinalizeES5_,
        hasChanges_
      });
    }
    function enablePatches() {
      var REPLACE = "replace";
      var ADD = "add";
      var REMOVE = "remove";
      function generatePatches_(state, basePath, patches, inversePatches) {
        switch (state.type_) {
          case 0:
          case 4:
          case 2:
            return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
          case 5:
          case 1:
            return generateArrayPatches(state, basePath, patches, inversePatches);
          case 3:
            return generateSetPatches(state, basePath, patches, inversePatches);
        }
      }
      function generateArrayPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, assigned_ = state.assigned_;
        var copy_ = state.copy_;
        if (copy_.length < base_.length) {
          var _ref2 = [copy_, base_];
          base_ = _ref2[0];
          copy_ = _ref2[1];
          var _ref22 = [inversePatches, patches];
          patches = _ref22[0];
          inversePatches = _ref22[1];
        }
        for (var i = 0; i < base_.length; i++) {
          if (assigned_[i] && copy_[i] !== base_[i]) {
            var path2 = basePath.concat([i]);
            patches.push({
              op: REPLACE,
              path: path2,
              // Need to maybe clone it, as it can in fact be the original value
              // due to the base/copy inversion at the start of this function
              value: clonePatchValueIfNeeded(copy_[i])
            });
            inversePatches.push({
              op: REPLACE,
              path: path2,
              value: clonePatchValueIfNeeded(base_[i])
            });
          }
        }
        for (var _i = base_.length; _i < copy_.length; _i++) {
          var _path = basePath.concat([_i]);
          patches.push({
            op: ADD,
            path: _path,
            // Need to maybe clone it, as it can in fact be the original value
            // due to the base/copy inversion at the start of this function
            value: clonePatchValueIfNeeded(copy_[_i])
          });
        }
        if (base_.length < copy_.length) {
          inversePatches.push({
            op: REPLACE,
            path: basePath.concat(["length"]),
            value: base_.length
          });
        }
      }
      function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        each(state.assigned_, function(key, assignedValue) {
          var origValue = get(base_, key);
          var value = get(copy_, key);
          var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
          if (origValue === value && op === REPLACE)
            return;
          var path2 = basePath.concat(key);
          patches.push(op === REMOVE ? {
            op,
            path: path2
          } : {
            op,
            path: path2,
            value
          });
          inversePatches.push(op === ADD ? {
            op: REMOVE,
            path: path2
          } : op === REMOVE ? {
            op: ADD,
            path: path2,
            value: clonePatchValueIfNeeded(origValue)
          } : {
            op: REPLACE,
            path: path2,
            value: clonePatchValueIfNeeded(origValue)
          });
        });
      }
      function generateSetPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        var i = 0;
        base_.forEach(function(value) {
          if (!copy_.has(value)) {
            var path2 = basePath.concat([i]);
            patches.push({
              op: REMOVE,
              path: path2,
              value
            });
            inversePatches.unshift({
              op: ADD,
              path: path2,
              value
            });
          }
          i++;
        });
        i = 0;
        copy_.forEach(function(value) {
          if (!base_.has(value)) {
            var path2 = basePath.concat([i]);
            patches.push({
              op: ADD,
              path: path2,
              value
            });
            inversePatches.unshift({
              op: REMOVE,
              path: path2,
              value
            });
          }
          i++;
        });
      }
      function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
          op: REPLACE,
          path: [],
          value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
          op: REPLACE,
          path: [],
          value: baseValue
        });
      }
      function applyPatches_(draft, patches) {
        patches.forEach(function(patch) {
          var path2 = patch.path, op = patch.op;
          var base = draft;
          for (var i = 0; i < path2.length - 1; i++) {
            var parentType = getArchtype(base);
            var p = "" + path2[i];
            if ((parentType === 0 || parentType === 1) && (p === "__proto__" || p === "constructor"))
              die(24);
            if (typeof base === "function" && p === "prototype")
              die(24);
            base = get(base, p);
            if (typeof base !== "object")
              die(15, path2.join("/"));
          }
          var type = getArchtype(base);
          var value = deepClonePatchValue(patch.value);
          var key = path2[path2.length - 1];
          switch (op) {
            case REPLACE:
              switch (type) {
                case 2:
                  return base.set(key, value);
                case 3:
                  die(16);
                default:
                  return base[key] = value;
              }
            case ADD:
              switch (type) {
                case 1:
                  return key === "-" ? base.push(value) : base.splice(key, 0, value);
                case 2:
                  return base.set(key, value);
                case 3:
                  return base.add(value);
                default:
                  return base[key] = value;
              }
            case REMOVE:
              switch (type) {
                case 1:
                  return base.splice(key, 1);
                case 2:
                  return base.delete(key);
                case 3:
                  return base.delete(patch.value);
                default:
                  return delete base[key];
              }
            default:
              die(17, op);
          }
        });
        return draft;
      }
      function deepClonePatchValue(obj) {
        if (!isDraftable(obj))
          return obj;
        if (Array.isArray(obj))
          return obj.map(deepClonePatchValue);
        if (isMap(obj))
          return new Map(Array.from(obj.entries()).map(function(_ref3) {
            var k = _ref3[0], v = _ref3[1];
            return [k, deepClonePatchValue(v)];
          }));
        if (isSet(obj))
          return new Set(Array.from(obj).map(deepClonePatchValue));
        var cloned = Object.create(Object.getPrototypeOf(obj));
        for (var key in obj) {
          cloned[key] = deepClonePatchValue(obj[key]);
        }
        if (has(obj, DRAFTABLE))
          cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
      }
      function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
          return deepClonePatchValue(obj);
        } else
          return obj;
      }
      loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
      });
    }
    function enableMapSet() {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
          }
        };
        return _extendStatics(d, b);
      };
      function __extends2(d, b) {
        _extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = // @ts-ignore
        (__.prototype = b.prototype, new __());
      }
      var DraftMap = function(_super) {
        __extends2(DraftMap2, _super);
        function DraftMap2(target, parent) {
          this[DRAFT_STATE] = {
            type_: 2,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            assigned_: void 0,
            base_: target,
            draft_: this,
            isManual_: false,
            revoked_: false
          };
          return this;
        }
        var p = DraftMap2.prototype;
        Object.defineProperty(p, "size", {
          get: function get2() {
            return latest(this[DRAFT_STATE]).size;
          }
          // enumerable: false,
          // configurable: true
        });
        p.has = function(key) {
          return latest(this[DRAFT_STATE]).has(key);
        };
        p.set = function(key, value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!latest(state).has(key) || latest(state).get(key) !== value) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_.set(key, true);
            state.copy_.set(key, value);
            state.assigned_.set(key, true);
          }
          return this;
        };
        p.delete = function(key) {
          if (!this.has(key)) {
            return false;
          }
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareMapCopy(state);
          markChanged(state);
          if (state.base_.has(key)) {
            state.assigned_.set(key, false);
          } else {
            state.assigned_.delete(key);
          }
          state.copy_.delete(key);
          return true;
        };
        p.clear = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_ = /* @__PURE__ */ new Map();
            each(state.base_, function(key) {
              state.assigned_.set(key, false);
            });
            state.copy_.clear();
          }
        };
        p.forEach = function(cb, thisArg) {
          var _this = this;
          var state = this[DRAFT_STATE];
          latest(state).forEach(function(_value, key, _map) {
            cb.call(thisArg, _this.get(key), key, _this);
          });
        };
        p.get = function(key) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          var value = latest(state).get(key);
          if (state.finalized_ || !isDraftable(value)) {
            return value;
          }
          if (value !== state.base_.get(key)) {
            return value;
          }
          var draft = createProxy(state.scope_.immer_, value, state);
          prepareMapCopy(state);
          state.copy_.set(key, draft);
          return draft;
        };
        p.keys = function() {
          return latest(this[DRAFT_STATE]).keys();
        };
        p.values = function() {
          var _this2 = this, _ref2;
          var iterator = this.keys();
          return _ref2 = {}, _ref2[iteratorSymbol] = function() {
            return _this2.values();
          }, _ref2.next = function next() {
            var r = iterator.next();
            if (r.done)
              return r;
            var value = _this2.get(r.value);
            return {
              done: false,
              value
            };
          }, _ref2;
        };
        p.entries = function() {
          var _this3 = this, _ref2;
          var iterator = this.keys();
          return _ref2 = {}, _ref2[iteratorSymbol] = function() {
            return _this3.entries();
          }, _ref2.next = function next() {
            var r = iterator.next();
            if (r.done)
              return r;
            var value = _this3.get(r.value);
            return {
              done: false,
              value: [r.value, value]
            };
          }, _ref2;
        };
        p[iteratorSymbol] = function() {
          return this.entries();
        };
        return DraftMap2;
      }(Map);
      function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
      }
      function prepareMapCopy(state) {
        if (!state.copy_) {
          state.assigned_ = /* @__PURE__ */ new Map();
          state.copy_ = new Map(state.base_);
        }
      }
      var DraftSet = function(_super) {
        __extends2(DraftSet2, _super);
        function DraftSet2(target, parent) {
          this[DRAFT_STATE] = {
            type_: 3,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            base_: target,
            draft_: this,
            drafts_: /* @__PURE__ */ new Map(),
            revoked_: false,
            isManual_: false
          };
          return this;
        }
        var p = DraftSet2.prototype;
        Object.defineProperty(p, "size", {
          get: function get2() {
            return latest(this[DRAFT_STATE]).size;
          }
          // enumerable: true,
        });
        p.has = function(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!state.copy_) {
            return state.base_.has(value);
          }
          if (state.copy_.has(value))
            return true;
          if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
            return true;
          return false;
        };
        p.add = function(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!this.has(value)) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.add(value);
          }
          return this;
        };
        p.delete = function(value) {
          if (!this.has(value)) {
            return false;
          }
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          markChanged(state);
          return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (
            /* istanbul ignore next */
            false
          ));
        };
        p.clear = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.clear();
          }
        };
        p.values = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.values();
        };
        p.entries = function entries2() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.entries();
        };
        p.keys = function() {
          return this.values();
        };
        p[iteratorSymbol] = function() {
          return this.values();
        };
        p.forEach = function forEach2(cb, thisArg) {
          var iterator = this.values();
          var result = iterator.next();
          while (!result.done) {
            cb.call(thisArg, result.value, result.value, this);
            result = iterator.next();
          }
        };
        return DraftSet2;
      }(Set);
      function proxySet_(target, parent) {
        return new DraftSet(target, parent);
      }
      function prepareSetCopy(state) {
        if (!state.copy_) {
          state.copy_ = /* @__PURE__ */ new Set();
          state.base_.forEach(function(value) {
            if (isDraftable(value)) {
              var draft = createProxy(state.scope_.immer_, value, state);
              state.drafts_.set(value, draft);
              state.copy_.add(draft);
            } else {
              state.copy_.add(value);
            }
          });
        }
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("MapSet", {
        proxyMap_,
        proxySet_
      });
    }
    function enableAllPlugins() {
      enableES5();
      enableMapSet();
      enablePatches();
    }
    var immer = /* @__PURE__ */ new Immer();
    var produce = immer.produce;
    var produceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(immer);
    var setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer);
    var setUseProxies = /* @__PURE__ */ immer.setUseProxies.bind(immer);
    var applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer);
    var createDraft = /* @__PURE__ */ immer.createDraft.bind(immer);
    var finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer);
    function castDraft(value) {
      return value;
    }
    function castImmutable(value) {
      return value;
    }
    exports2.Immer = Immer;
    exports2.applyPatches = applyPatches;
    exports2.castDraft = castDraft;
    exports2.castImmutable = castImmutable;
    exports2.createDraft = createDraft;
    exports2.current = current;
    exports2.default = produce;
    exports2.enableAllPlugins = enableAllPlugins;
    exports2.enableES5 = enableES5;
    exports2.enableMapSet = enableMapSet;
    exports2.enablePatches = enablePatches;
    exports2.finishDraft = finishDraft;
    exports2.freeze = freeze;
    exports2.immerable = DRAFTABLE;
    exports2.isDraft = isDraft;
    exports2.isDraftable = isDraftable;
    exports2.nothing = NOTHING;
    exports2.original = original;
    exports2.produce = produce;
    exports2.produceWithPatches = produceWithPatches;
    exports2.setAutoFreeze = setAutoFreeze;
    exports2.setUseProxies = setUseProxies;
  }
});

// node_modules/immer/dist/index.js
var require_dist3 = __commonJS2({
  "node_modules/immer/dist/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_immer_cjs_production_min();
    } else {
      module2.exports = require_immer_cjs_development();
    }
  }
});

// node_modules/object-path/index.js
var require_object_path = __commonJS2({
  "node_modules/object-path/index.js"(exports2, module2) {
    (function(root, factory) {
      "use strict";
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.objectPath = factory();
      }
    })(exports2, function() {
      "use strict";
      var toStr = Object.prototype.toString;
      function hasOwnProperty4(obj, prop) {
        if (obj == null) {
          return false;
        }
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function isEmpty(value) {
        if (!value) {
          return true;
        }
        if (isArray3(value) && value.length === 0) {
          return true;
        } else if (typeof value !== "string") {
          for (var i in value) {
            if (hasOwnProperty4(value, i)) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      function toString4(type) {
        return toStr.call(type);
      }
      function isObject4(obj) {
        return typeof obj === "object" && toString4(obj) === "[object Object]";
      }
      var isArray3 = Array.isArray || function(obj) {
        return toStr.call(obj) === "[object Array]";
      };
      function isBoolean2(obj) {
        return typeof obj === "boolean" || toString4(obj) === "[object Boolean]";
      }
      function getKey(key) {
        var intKey = parseInt(key);
        if (intKey.toString() === key) {
          return intKey;
        }
        return key;
      }
      function factory(options) {
        options = options || {};
        var objectPath = function(obj) {
          return Object.keys(objectPath).reduce(function(proxy, prop) {
            if (prop === "create") {
              return proxy;
            }
            if (typeof objectPath[prop] === "function") {
              proxy[prop] = objectPath[prop].bind(objectPath, obj);
            }
            return proxy;
          }, {});
        };
        var hasShallowProperty;
        if (options.includeInheritedProps) {
          hasShallowProperty = function() {
            return true;
          };
        } else {
          hasShallowProperty = function(obj, prop) {
            return typeof prop === "number" && Array.isArray(obj) || hasOwnProperty4(obj, prop);
          };
        }
        function getShallowProperty(obj, prop) {
          if (hasShallowProperty(obj, prop)) {
            return obj[prop];
          }
        }
        var getShallowPropertySafely;
        if (options.includeInheritedProps) {
          getShallowPropertySafely = function(obj, currentPath) {
            if (typeof currentPath !== "string" && typeof currentPath !== "number") {
              currentPath = String(currentPath);
            }
            var currentValue = getShallowProperty(obj, currentPath);
            if (currentPath === "__proto__" || currentPath === "prototype" || currentPath === "constructor" && typeof currentValue === "function") {
              throw new Error("For security reasons, object's magic properties cannot be set");
            }
            return currentValue;
          };
        } else {
          getShallowPropertySafely = function(obj, currentPath) {
            return getShallowProperty(obj, currentPath);
          };
        }
        function set(obj, path2, value, doNotReplace) {
          if (typeof path2 === "number") {
            path2 = [path2];
          }
          if (!path2 || path2.length === 0) {
            return obj;
          }
          if (typeof path2 === "string") {
            return set(obj, path2.split(".").map(getKey), value, doNotReplace);
          }
          var currentPath = path2[0];
          var currentValue = getShallowPropertySafely(obj, currentPath);
          if (path2.length === 1) {
            if (currentValue === void 0 || !doNotReplace) {
              obj[currentPath] = value;
            }
            return currentValue;
          }
          if (currentValue === void 0) {
            if (typeof path2[1] === "number") {
              obj[currentPath] = [];
            } else {
              obj[currentPath] = {};
            }
          }
          return set(obj[currentPath], path2.slice(1), value, doNotReplace);
        }
        objectPath.has = function(obj, path2) {
          if (typeof path2 === "number") {
            path2 = [path2];
          } else if (typeof path2 === "string") {
            path2 = path2.split(".");
          }
          if (!path2 || path2.length === 0) {
            return !!obj;
          }
          for (var i = 0; i < path2.length; i++) {
            var j = getKey(path2[i]);
            if (typeof j === "number" && isArray3(obj) && j < obj.length || (options.includeInheritedProps ? j in Object(obj) : hasOwnProperty4(obj, j))) {
              obj = obj[j];
            } else {
              return false;
            }
          }
          return true;
        };
        objectPath.ensureExists = function(obj, path2, value) {
          return set(obj, path2, value, true);
        };
        objectPath.set = function(obj, path2, value, doNotReplace) {
          return set(obj, path2, value, doNotReplace);
        };
        objectPath.insert = function(obj, path2, value, at) {
          var arr = objectPath.get(obj, path2);
          at = ~~at;
          if (!isArray3(arr)) {
            arr = [];
            objectPath.set(obj, path2, arr);
          }
          arr.splice(at, 0, value);
        };
        objectPath.empty = function(obj, path2) {
          if (isEmpty(path2)) {
            return void 0;
          }
          if (obj == null) {
            return void 0;
          }
          var value, i;
          if (!(value = objectPath.get(obj, path2))) {
            return void 0;
          }
          if (typeof value === "string") {
            return objectPath.set(obj, path2, "");
          } else if (isBoolean2(value)) {
            return objectPath.set(obj, path2, false);
          } else if (typeof value === "number") {
            return objectPath.set(obj, path2, 0);
          } else if (isArray3(value)) {
            value.length = 0;
          } else if (isObject4(value)) {
            for (i in value) {
              if (hasShallowProperty(value, i)) {
                delete value[i];
              }
            }
          } else {
            return objectPath.set(obj, path2, null);
          }
        };
        objectPath.push = function(obj, path2) {
          var arr = objectPath.get(obj, path2);
          if (!isArray3(arr)) {
            arr = [];
            objectPath.set(obj, path2, arr);
          }
          arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
        };
        objectPath.coalesce = function(obj, paths, defaultValue) {
          var value;
          for (var i = 0, len = paths.length; i < len; i++) {
            if ((value = objectPath.get(obj, paths[i])) !== void 0) {
              return value;
            }
          }
          return defaultValue;
        };
        objectPath.get = function(obj, path2, defaultValue) {
          if (typeof path2 === "number") {
            path2 = [path2];
          }
          if (!path2 || path2.length === 0) {
            return obj;
          }
          if (obj == null) {
            return defaultValue;
          }
          if (typeof path2 === "string") {
            return objectPath.get(obj, path2.split("."), defaultValue);
          }
          var currentPath = getKey(path2[0]);
          var nextObj = getShallowPropertySafely(obj, currentPath);
          if (nextObj === void 0) {
            return defaultValue;
          }
          if (path2.length === 1) {
            return nextObj;
          }
          return objectPath.get(obj[currentPath], path2.slice(1), defaultValue);
        };
        objectPath.del = function del(obj, path2) {
          if (typeof path2 === "number") {
            path2 = [path2];
          }
          if (obj == null) {
            return obj;
          }
          if (isEmpty(path2)) {
            return obj;
          }
          if (typeof path2 === "string") {
            return objectPath.del(obj, path2.split("."));
          }
          var currentPath = getKey(path2[0]);
          getShallowPropertySafely(obj, currentPath);
          if (!hasShallowProperty(obj, currentPath)) {
            return obj;
          }
          if (path2.length === 1) {
            if (isArray3(obj)) {
              obj.splice(currentPath, 1);
            } else {
              delete obj[currentPath];
            }
          } else {
            return objectPath.del(obj[currentPath], path2.slice(1));
          }
          return obj;
        };
        return objectPath;
      }
      var mod2 = factory();
      mod2.create = factory;
      mod2.withInheritedProps = factory({ includeInheritedProps: true });
      return mod2;
    });
  }
});

// node_modules/prisma-field-encryption/dist/hash.js
var require_hash = __commonJS2({
  "node_modules/prisma-field-encryption/dist/hash.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hashString = void 0;
    var codec_1 = require_dist();
    var node_crypto_1 = __importDefault(require("node:crypto"));
    function hashString(input, config2) {
      const decode = codec_1.decoders[config2.inputEncoding];
      const encode3 = codec_1.encoders[config2.outputEncoding];
      const data = decode(input);
      const hash = node_crypto_1.default.createHash(config2.algorithm);
      hash.update(data);
      if (config2.salt) {
        hash.update(decode(config2.salt));
      }
      return encode3(hash.digest());
    }
    exports2.hashString = hashString;
  }
});

// node_modules/prisma-field-encryption/dist/traverseTree.js
var require_traverseTree = __commonJS2({
  "node_modules/prisma-field-encryption/dist/traverseTree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.traverseTree = void 0;
    function traverseTree(input, callback, initialState) {
      const stack = [
        {
          path: [],
          type: typeOf(input),
          node: input,
          state: initialState
        }
      ];
      while (stack.length > 0) {
        const { state, ...item } = stack.shift();
        const newState = callback(state, item);
        if (!isCollection(item.node)) {
          continue;
        }
        const children = Object.entries(item.node).map(([key, child]) => ({
          key,
          node: child,
          type: typeOf(child),
          path: [...item.path, key],
          state: newState
        }));
        stack.unshift(...children);
      }
    }
    exports2.traverseTree = traverseTree;
    function isObject4(item) {
      return typeof item === "object" && Object.prototype.toString.call(item) === "[object Object]";
    }
    function isCollection(item) {
      return Array.isArray(item) || isObject4(item);
    }
    function typeOf(item) {
      if (Array.isArray(item)) {
        return "array";
      }
      if (isObject4(item)) {
        return "object";
      }
      if (item === null) {
        return "null";
      }
      return typeof item;
    }
  }
});

// node_modules/prisma-field-encryption/dist/visitor.js
var require_visitor = __commonJS2({
  "node_modules/prisma-field-encryption/dist/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.visitOutputTargetFields = exports2.visitInputTargetFields = void 0;
    var debugger_1 = require_debugger();
    var traverseTree_1 = require_traverseTree();
    var makeVisitor = (models, visitor, specialSubFields, debug) => function visitNode(state, { key, type, node, path: path2 }) {
      const model = models[state.currentModel];
      if (!model || !key) {
        return state;
      }
      if (type === "string" && key in model.fields) {
        const targetField = {
          field: key,
          model: state.currentModel,
          fieldConfig: model.fields[key],
          path: path2.join("."),
          value: node
        };
        debug("Visiting %O", targetField);
        visitor(targetField);
        return state;
      }
      for (const specialSubField of specialSubFields) {
        if (type === "object" && key in model.fields && typeof (node === null || node === void 0 ? void 0 : node[specialSubField]) === "string") {
          const value = node[specialSubField];
          const targetField = {
            field: key,
            model: state.currentModel,
            fieldConfig: model.fields[key],
            path: [...path2, specialSubField].join("."),
            value
          };
          debug("Visiting %O", targetField);
          visitor(targetField);
          return state;
        }
      }
      if (["object", "array"].includes(type) && key in model.connections) {
        debug(`Changing model: following connection ${state.currentModel}.${key} to model ${model.connections[key].modelName}`);
        return {
          currentModel: model.connections[key].modelName
        };
      }
      return state;
    };
    function visitInputTargetFields(params, models, visitor) {
      (0, traverseTree_1.traverseTree)(params.args, makeVisitor(models, visitor, ["equals", "set"], debugger_1.debug.encryption), {
        currentModel: params.model
      });
    }
    exports2.visitInputTargetFields = visitInputTargetFields;
    function visitOutputTargetFields(params, result, models, visitor) {
      (0, traverseTree_1.traverseTree)(result, makeVisitor(models, visitor, [], debugger_1.debug.decryption), {
        currentModel: params.model
      });
    }
    exports2.visitOutputTargetFields = visitOutputTargetFields;
  }
});

// node_modules/prisma-field-encryption/dist/encryption.js
var require_encryption = __commonJS2({
  "node_modules/prisma-field-encryption/dist/encryption.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decryptOnRead = exports2.encryptOnWrite = exports2.configureKeys = void 0;
    var cloak_1 = require_dist2();
    var immer_1 = __importDefault(require_dist3());
    var object_path_1 = __importDefault(require_object_path());
    var debugger_1 = require_debugger();
    var errors_1 = require_errors3();
    var hash_1 = require_hash();
    var visitor_1 = require_visitor();
    function configureKeys(config2) {
      var _a4, _b3;
      const encryptionKey = config2.encryptionKey || process.env.PRISMA_FIELD_ENCRYPTION_KEY;
      if (!encryptionKey) {
        throw new Error(errors_1.errors.noEncryptionKey);
      }
      const decryptionKeysFromEnv = ((_a4 = process.env.PRISMA_FIELD_DECRYPTION_KEYS) !== null && _a4 !== void 0 ? _a4 : "").split(",").filter(Boolean);
      const decryptionKeys = Array.from(/* @__PURE__ */ new Set([
        encryptionKey,
        ...(_b3 = config2.decryptionKeys) !== null && _b3 !== void 0 ? _b3 : decryptionKeysFromEnv
      ]));
      const keychain = (0, cloak_1.makeKeychainSync)(decryptionKeys);
      return {
        encryptionKey: (0, cloak_1.parseKeySync)(encryptionKey),
        keychain
      };
    }
    exports2.configureKeys = configureKeys;
    function encryptOnWrite(params, keys2, models, operation) {
      debugger_1.debug.encryption("Clear-text input: %O", params);
      const encryptionErrors = [];
      const mutatedParams = (0, immer_1.default)(params, (draft) => {
        (0, visitor_1.visitInputTargetFields)(draft, models, function encryptFieldValue({ fieldConfig, value: clearText, path: path2, model, field }) {
          var _a4, _b3;
          if (!fieldConfig.encrypt) {
            return;
          }
          const wherePath = rewriteWhereClausePath(path2, field, (_b3 = (_a4 = fieldConfig.hash) === null || _a4 === void 0 ? void 0 : _a4.targetField) !== null && _b3 !== void 0 ? _b3 : field + "Hash");
          if (wherePath) {
            if (!fieldConfig.hash) {
              console.warn(errors_1.warnings.whereClauseNoHash(operation, path2));
            } else {
              const hash = (0, hash_1.hashString)(clearText, fieldConfig.hash);
              debugger_1.debug.encryption(`Swapping encrypted search of ${model}.${field} with hash search under ${fieldConfig.hash.targetField} (hash: ${hash})`);
              object_path_1.default.del(draft.args, path2);
              object_path_1.default.set(draft.args, wherePath, hash);
              return;
            }
          }
          try {
            const cipherText = (0, cloak_1.encryptStringSync)(clearText, keys2.encryptionKey);
            object_path_1.default.set(draft.args, path2, cipherText);
            debugger_1.debug.encryption(`Encrypted ${model}.${field} at path \`${path2}\``);
            if (fieldConfig.hash) {
              const hash = (0, hash_1.hashString)(clearText, fieldConfig.hash);
              const hashPath = rewriteWritePath(path2, field, fieldConfig.hash.targetField);
              object_path_1.default.set(draft.args, hashPath, hash);
              debugger_1.debug.encryption(`Added hash ${hash} of ${model}.${field} under ${fieldConfig.hash.targetField}`);
            }
          } catch (error2) {
            encryptionErrors.push(errors_1.errors.fieldEncryptionError(model, field, path2, error2));
          }
        });
      });
      if (encryptionErrors.length > 0) {
        throw new Error(errors_1.errors.encryptionErrorReport(operation, encryptionErrors));
      }
      debugger_1.debug.encryption("Encrypted input: %O", mutatedParams);
      return mutatedParams;
    }
    exports2.encryptOnWrite = encryptOnWrite;
    function decryptOnRead(params, result, keys2, models, operation) {
      var _a4, _b3;
      const model = models[params.model];
      if (Object.keys(model.fields).length === 0 && !((_a4 = params.args) === null || _a4 === void 0 ? void 0 : _a4.include) && !((_b3 = params.args) === null || _b3 === void 0 ? void 0 : _b3.select)) {
        debugger_1.debug.decryption(`Skipping decryption: ${params.model} has no encrypted field and no connection was included`);
        return;
      }
      debugger_1.debug.decryption("Raw result from database: %O", result);
      const decryptionErrors = [];
      const fatalDecryptionErrors = [];
      (0, visitor_1.visitOutputTargetFields)(params, result, models, function decryptFieldValue({ fieldConfig, value: cipherText, path: path2, model: model2, field }) {
        try {
          if (!cloak_1.cloakedStringRegex.test(cipherText)) {
            return;
          }
          const decryptionKey = (0, cloak_1.findKeyForMessage)(cipherText, keys2.keychain);
          const clearText = (0, cloak_1.decryptStringSync)(cipherText, decryptionKey);
          object_path_1.default.set(result, path2, clearText);
          debugger_1.debug.decryption(`Decrypted ${model2}.${field} at path \`${path2}\` using key fingerprint ${decryptionKey.fingerprint}`);
        } catch (error2) {
          const message = errors_1.errors.fieldDecryptionError(model2, field, path2, error2);
          if (fieldConfig.strictDecryption) {
            fatalDecryptionErrors.push(message);
          } else {
            decryptionErrors.push(message);
          }
        }
      });
      if (decryptionErrors.length > 0) {
        console.error(errors_1.errors.decryptionErrorReport(operation, decryptionErrors));
      }
      if (fatalDecryptionErrors.length > 0) {
        throw new Error(errors_1.errors.decryptionErrorReport(operation, fatalDecryptionErrors));
      }
      debugger_1.debug.decryption("Decrypted result: %O", result);
    }
    exports2.decryptOnRead = decryptOnRead;
    function rewriteWhereClausePath(path2, field, hashField) {
      const items = path2.split(".").reverse();
      if (!items.includes("where")) {
        return null;
      }
      if (items[0] === field) {
        items[0] = hashField;
        return items.reverse().join(".");
      }
      if (items[0] === "equals" && items[1] === field) {
        items[1] = hashField;
        return items.reverse().join(".");
      }
      return null;
    }
    function rewriteWritePath(path2, field, hashField) {
      const items = path2.split(".").reverse();
      if (items[0] === field) {
        items[0] = hashField;
      } else if (items[0] === "set" && items[1] === field) {
        items[1] = hashField;
      }
      return items.reverse().join(".");
    }
  }
});

// node_modules/prisma-field-encryption/dist/index.js
var require_dist4 = __commonJS2({
  "node_modules/prisma-field-encryption/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fieldEncryptionMiddleware = void 0;
    var debugger_1 = require_debugger();
    var dmmf_1 = require_dmmf();
    var encryption_1 = require_encryption();
    function fieldEncryptionMiddleware2(config2 = {}) {
      var _a4;
      const keys2 = (0, encryption_1.configureKeys)(config2);
      debugger_1.debug.setup("Keys: %O", keys2);
      const models = (0, dmmf_1.analyseDMMF)((_a4 = config2.dmmf) !== null && _a4 !== void 0 ? _a4 : require_client3().Prisma.dmmf);
      debugger_1.debug.setup("Models: %O", models);
      return async function fieldEncryptionMiddleware3(params, next) {
        if (!params.model) {
          debugger_1.debug.runtime("Unsupported operation (missing model): %O", params);
          return await next(params);
        }
        const operation = `${params.model}.${params.action}`;
        const encryptedParams = (0, encryption_1.encryptOnWrite)(params, keys2, models, operation);
        let result = await next(encryptedParams);
        (0, encryption_1.decryptOnRead)(encryptedParams, result, keys2, models, operation);
        return result;
      };
    }
    exports2.fieldEncryptionMiddleware = fieldEncryptionMiddleware2;
  }
});

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray: isArray2 } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction2 = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject3 = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject2 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate2 = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject3(val) && isFunction2(val.pipe);
var isFormData = (thing) => {
  const pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction2(thing.toString) && thing.toString() === pattern);
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray2(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i = keys2.length;
  let _key;
  while (i-- > 0) {
    _key = keys2[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global2 = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context3) => !isUndefined(context3) && context3 !== _global2;
function merge2() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
      result[targetKey] = merge2(result[targetKey], val);
    } else if (isPlainObject2(val)) {
      result[targetKey] = merge2({}, val);
    } else if (isArray2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction2(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray2(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[_-\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty3 = (({ hasOwnProperty: hasOwnProperty4 }) => (obj, prop) => hasOwnProperty4.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction2(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray2(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject3(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray2(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var utils_default = {
  isArray: isArray2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject3,
  isPlainObject: isPlainObject2,
  isUndefined,
  isDate: isDate2,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction2,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge2,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty3,
  hasOwnProp: hasOwnProperty3,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global2,
  isContextDefined,
  toJSONObject
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config2, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error2, code, config2, request2, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error2, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code, config2, request2, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/env/classes/FormData.js
var import_form_data = __toESM2(require_form_data(), 1);
var FormData_default = import_form_data.default;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function isSpecCompliant(thing) {
  return thing && utils_default.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
}
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && isSpecCompliant(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]") && (arr = utils_default.toArray(value)))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
var import_url2 = __toESM2(require("url"), 1);
var URLSearchParams_default = import_url2.default.URLSearchParams;

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data2 = __toESM2(require_form_data(), 1);
var FormData_default2 = import_form_data2.default;

// node_modules/axios/lib/platform/node/index.js
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default2,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  protocols: ["http", "https", "file", "data"]
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new node_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (node_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i;
  const len = keys2.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys2[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData4 = utils_default.isFormData(data);
    if (isFormData4) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: node_default.classes.FormData,
    Blob: node_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils_default.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils_default.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim());
}
function matchHeaderValue(context3, value, header, filter2) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear() {
    return Object.keys(this).forEach(this.delete.bind(this));
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
utils_default.freezeMethods(AxiosHeaders.prototype);
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context3 = response || config2;
  const headers = AxiosHeaders_default.from(context3.headers);
  let data = context3.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config2, request2) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request2);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM2(require_proxy_from_env(), 1);
var import_http = __toESM2(require("http"), 1);
var import_https = __toESM2(require("https"), 1);
var import_follow_redirects = __toESM2(require_follow_redirects(), 1);
var import_zlib = __toESM2(require("zlib"), 1);

// node_modules/axios/lib/env/data.js
var VERSION4 = "1.2.2";

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || node_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// node_modules/axios/lib/adapters/http.js
var import_stream3 = __toESM2(require("stream"), 1);

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var import_stream2 = __toESM2(require("stream"), 1);

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  const threshold = 1e3 / freq;
  let timer2 = null;
  return function throttled(force, args) {
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      timestamp = now;
      return fn.apply(null, args);
    }
    if (!timer2) {
      timer2 = setTimeout(() => {
        timer2 = null;
        timestamp = Date.now();
        return fn.apply(null, args);
      }, threshold - (now - timestamp));
    }
  };
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var kInternals = Symbol("internals");
var AxiosTransformStream = class extends import_stream2.default.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const self2 = this;
    const internals = this[kInternals] = {
      length: options.length,
      timeWindow: options.timeWindow,
      ticksRate: options.ticksRate,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    const _speedometer = speedometer_default(internals.ticksRate * options.samplesCount, internals.timeWindow);
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
    let bytesNotified = 0;
    internals.updateProgress = throttle_default(function throttledHandler() {
      const totalBytes = internals.length;
      const bytesTransferred = internals.bytesSeen;
      const progressBytes = bytesTransferred - bytesNotified;
      if (!progressBytes || self2.destroyed)
        return;
      const rate = _speedometer(progressBytes);
      bytesNotified = bytesTransferred;
      process.nextTick(() => {
        self2.emit("progress", {
          "loaded": bytesTransferred,
          "total": totalBytes,
          "progress": totalBytes ? bytesTransferred / totalBytes : void 0,
          "bytes": progressBytes,
          "rate": rate ? rate : void 0,
          "estimated": rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : void 0
        });
      });
    }, internals.ticksRate);
    const onFinish = () => {
      internals.updateProgress(true);
    };
    this.once("end", onFinish);
    this.once("error", onFinish);
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const self2 = this;
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    function pushChunk(_chunk, _callback) {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      if (internals.isCaptured) {
        internals.updateProgress();
      }
      if (self2.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
  setLength(length) {
    this[kInternals].length = +length;
    return this;
  }
};
var AxiosTransformStream_default = AxiosTransformStream;

// node_modules/axios/lib/adapters/http.js
var import_events2 = __toESM2(require("events"), 1);
var zlibOptions = {
  flush: import_zlib.default.constants.Z_SYNC_FLUSH,
  finishFlush: import_zlib.default.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(import_zlib.default.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = node_default.protocols.map((protocol) => {
  return protocol + ":";
});
function dispatchBeforeRedirect(options) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = (0, import_proxy_from_env.getProxyForUrl)(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var http_default = isHttpAdapterSupported && function httpAdapter(config2) {
  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
    let data = config2.data;
    const responseType = config2.responseType;
    const responseEncoding = config2.responseEncoding;
    const method = config2.method.toUpperCase();
    let isFinished;
    let isDone;
    let rejected = false;
    let req;
    const emitter = new import_events2.default();
    function onFinished() {
      if (isFinished)
        return;
      isFinished = true;
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(abort);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    }
    function done(value, isRejected) {
      if (isDone)
        return;
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
      isRejected ? rejectPromise(value) : resolvePromise(value);
    }
    const resolve = function resolve2(value) {
      done(value);
    };
    const reject = function reject2(value) {
      done(value, true);
    };
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config2, req) : reason);
    }
    emitter.once("abort", reject);
    if (config2.cancelToken || config2.signal) {
      config2.cancelToken && config2.cancelToken.subscribe(abort);
      if (config2.signal) {
        config2.signal.aborted ? abort() : config2.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    const parsed = new URL(fullPath);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config: config2
        });
      }
      try {
        convertedData = fromDataURI(config2.url, responseType === "blob", {
          Blob: config2.env && config2.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config2);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          data = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = import_stream3.default.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default(),
        config: config2
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default(
        "Unsupported protocol " + protocol,
        AxiosError_default.ERR_BAD_REQUEST,
        config2
      ));
    }
    const headers = AxiosHeaders_default.from(config2.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION4, false);
    const onDownloadProgress = config2.onDownloadProgress;
    const onUploadProgress = config2.onUploadProgress;
    const maxRate = config2.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) {
      } else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError_default.ERR_BAD_REQUEST,
          config2
        ));
      }
      headers.set("Content-Length", data.length, false);
      if (config2.maxBodyLength > -1 && data.length > config2.maxBodyLength) {
        return reject(new AxiosError_default(
          "Request body larger than maxBodyLength limit",
          AxiosError_default.ERR_BAD_REQUEST,
          config2
        ));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = import_stream3.default.Readable.from(data, { objectMode: false });
      }
      data = import_stream3.default.pipeline([data, new AxiosTransformStream_default({
        length: contentLength,
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", (progress) => {
        onUploadProgress(Object.assign(progress, {
          upload: true
        }));
      });
    }
    let auth = void 0;
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path2;
    try {
      path2 = buildURL(
        parsed.pathname + parsed.search,
        config2.params,
        config2.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config2;
      customErr.url = config2.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path2,
      method,
      headers: headers.toJSON(),
      agents: { http: config2.httpAgent, https: config2.httpsAgent },
      auth,
      protocol,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    if (config2.socketPath) {
      options.socketPath = config2.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config2.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config2.httpsAgent : config2.httpAgent;
    if (config2.transport) {
      transport = config2.transport;
    } else if (config2.maxRedirects === 0) {
      transport = isHttpsRequest ? import_https.default : import_http.default;
    } else {
      if (config2.maxRedirects) {
        options.maxRedirects = config2.maxRedirects;
      }
      if (config2.beforeRedirect) {
        options.beforeRedirects.config = config2.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config2.maxBodyLength > -1) {
      options.maxBodyLength = config2.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config2.insecureHTTPParser) {
      options.insecureHTTPParser = config2.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed)
        return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress) {
        const transformStream = new AxiosTransformStream_default({
          length: utils_default.toFiniteNumber(responseLength),
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", (progress) => {
          onDownloadProgress(Object.assign(progress, {
            download: true
          }));
        });
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config2.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch (res.headers["content-encoding"]) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
          case "deflate":
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(import_zlib.default.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? import_stream3.default.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = import_stream3.default.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config: config2,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config2.maxContentLength > -1 && totalResponseBytes > config2.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default(
              "maxContentLength size of " + config2.maxContentLength + " exceeded",
              AxiosError_default.ERR_BAD_RESPONSE,
              config2,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default(
            "maxContentLength size of " + config2.maxContentLength + " exceeded",
            AxiosError_default.ERR_BAD_RESPONSE,
            config2,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed)
            return;
          reject(AxiosError_default.from(err, null, config2, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            reject(AxiosError_default.from(err, null, config2, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config2, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config2.timeout) {
      const timeout = parseInt(config2.timeout, 10);
      if (isNaN(timeout)) {
        reject(new AxiosError_default(
          "error trying to parse `config.timeout` to int",
          AxiosError_default.ERR_BAD_OPTION_VALUE,
          config2,
          req
        ));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config2.transitional || transitional_default;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config2,
          req
        ));
        abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config2, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = node_default.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path2, domain, secure) {
        const cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils_default.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils_default.isString(path2)) {
          cookie.push("path=" + path2);
        }
        if (utils_default.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = node_default.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config2.data;
    const requestHeaders = AxiosHeaders_default.from(config2.headers).normalize();
    const responseType = config2.responseType;
    let onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils_default.isFormData(requestData) && (node_default.isStandardBrowserEnv || node_default.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false);
    }
    let request2 = new XMLHttpRequest();
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config2.transitional || transitional_default;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config2,
        request2
      ));
      request2 = null;
    };
    if (node_default.isStandardBrowserEnv) {
      const xsrfValue = (config2.withCredentials || isURLSameOrigin_default(fullPath)) && config2.xsrfCookieName && cookies_default.read(config2.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && node_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request2.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if (adapter = utils_default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError_default(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils_default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils_default.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config2.adapter || defaults_default.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}

// node_modules/axios/lib/helpers/validator.js
var validators2 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators2[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators2.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION4 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i = keys2.length;
  while (i-- > 0) {
    const opt = keys2[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators: validators2
};

// node_modules/axios/lib/core/Axios.js
var validators3 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig2(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators3.transitional(validators3.boolean),
        forcedJSONParsing: validators3.transitional(validators3.boolean),
        clarifyTimeoutError: validators3.transitional(validators3.boolean)
      }, false);
    }
    if (paramsSerializer !== void 0) {
      validator_default.assertOptions(paramsSerializer, {
        encode: validators3.function,
        serialize: validators3.function
      }, true);
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    contextHeaders && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig2(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig2(config2 || {}, {
      method,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config2) {
      return this.request(mergeConfig2(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config2, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context3 = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context3);
  utils_default.extend(instance, Axios_default.prototype, context3, { allOwnKeys: true });
  utils_default.extend(instance, context3, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig2(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION4;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig2;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION5,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  mergeConfig: mergeConfig3
} = axios_default;

// node_modules/@sindresorhus/is/dist/index.js
var typedArrayTypeNames = [
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function isTypedArrayName(name) {
  return typedArrayTypeNames.includes(name);
}
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Blob",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "WeakRef",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "FormData",
  "URLSearchParams",
  "HTMLElement",
  "NaN",
  ...typedArrayTypeNames
];
function isObjectTypeName(name) {
  return objectTypeNames.includes(name);
}
var primitiveTypeNames = [
  "null",
  "undefined",
  "string",
  "number",
  "bigint",
  "boolean",
  "symbol"
];
function isPrimitiveTypeName(name) {
  return primitiveTypeNames.includes(name);
}
function isOfType(type) {
  return (value) => typeof value === type;
}
var { toString: toString3 } = Object.prototype;
var getObjectType = (value) => {
  const objectTypeName = toString3.call(value).slice(8, -1);
  if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
    return "HTMLElement";
  }
  if (isObjectTypeName(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
};
var isObjectOfType = (type) => (value) => getObjectType(value) === type;
function is(value) {
  if (value === null) {
    return "null";
  }
  switch (typeof value) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(value) ? "NaN" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "Function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    default:
  }
  if (is.observable(value)) {
    return "Observable";
  }
  if (is.array(value)) {
    return "Array";
  }
  if (is.buffer(value)) {
    return "Buffer";
  }
  const tagType = getObjectType(value);
  if (tagType) {
    return tagType;
  }
  if (value instanceof String || value instanceof Boolean || value instanceof Number) {
    throw new TypeError("Please don't use object wrappers for primitive types");
  }
  return "Object";
}
is.undefined = isOfType("undefined");
is.string = isOfType("string");
var isNumberType = isOfType("number");
is.number = (value) => isNumberType(value) && !is.nan(value);
is.bigint = isOfType("bigint");
is.function_ = isOfType("function");
is.null_ = (value) => value === null;
is.class_ = (value) => is.function_(value) && value.toString().startsWith("class ");
is.boolean = (value) => value === true || value === false;
is.symbol = isOfType("symbol");
is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
is.array = (value, assertion) => {
  if (!Array.isArray(value)) {
    return false;
  }
  if (!is.function_(assertion)) {
    return true;
  }
  return value.every((element) => assertion(element));
};
is.buffer = (value) => value?.constructor?.isBuffer?.(value) ?? false;
is.blob = (value) => isObjectOfType("Blob")(value);
is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
is.object = (value) => !is.null_(value) && (typeof value === "object" || is.function_(value));
is.iterable = (value) => is.function_(value?.[Symbol.iterator]);
is.asyncIterable = (value) => is.function_(value?.[Symbol.asyncIterator]);
is.generator = (value) => is.iterable(value) && is.function_(value?.next) && is.function_(value?.throw);
is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
is.nativePromise = (value) => isObjectOfType("Promise")(value);
var hasPromiseApi = (value) => is.function_(value?.then) && is.function_(value?.catch);
is.promise = (value) => is.nativePromise(value) || hasPromiseApi(value);
is.generatorFunction = isObjectOfType("GeneratorFunction");
is.asyncGeneratorFunction = (value) => getObjectType(value) === "AsyncGeneratorFunction";
is.asyncFunction = (value) => getObjectType(value) === "AsyncFunction";
is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty("prototype");
is.regExp = isObjectOfType("RegExp");
is.date = isObjectOfType("Date");
is.error = isObjectOfType("Error");
is.map = (value) => isObjectOfType("Map")(value);
is.set = (value) => isObjectOfType("Set")(value);
is.weakMap = (value) => isObjectOfType("WeakMap")(value);
is.weakSet = (value) => isObjectOfType("WeakSet")(value);
is.weakRef = (value) => isObjectOfType("WeakRef")(value);
is.int8Array = isObjectOfType("Int8Array");
is.uint8Array = isObjectOfType("Uint8Array");
is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
is.int16Array = isObjectOfType("Int16Array");
is.uint16Array = isObjectOfType("Uint16Array");
is.int32Array = isObjectOfType("Int32Array");
is.uint32Array = isObjectOfType("Uint32Array");
is.float32Array = isObjectOfType("Float32Array");
is.float64Array = isObjectOfType("Float64Array");
is.bigInt64Array = isObjectOfType("BigInt64Array");
is.bigUint64Array = isObjectOfType("BigUint64Array");
is.arrayBuffer = isObjectOfType("ArrayBuffer");
is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
is.dataView = isObjectOfType("DataView");
is.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);
is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
is.urlInstance = (value) => isObjectOfType("URL")(value);
is.urlString = (value) => {
  if (!is.string(value)) {
    return false;
  }
  try {
    new URL(value);
    return true;
  } catch {
    return false;
  }
};
is.truthy = (value) => Boolean(value);
is.falsy = (value) => !value;
is.nan = (value) => Number.isNaN(value);
is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
is.integer = (value) => Number.isInteger(value);
is.safeInteger = (value) => Number.isSafeInteger(value);
is.plainObject = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype3 = Object.getPrototypeOf(value);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
is.typedArray = (value) => isTypedArrayName(getObjectType(value));
var isValidLength = (value) => is.safeInteger(value) && value >= 0;
is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
is.inRange = (value, range) => {
  if (is.number(range)) {
    return value >= Math.min(0, range) && value <= Math.max(range, 0);
  }
  if (is.array(range) && range.length === 2) {
    return value >= Math.min(...range) && value <= Math.max(...range);
  }
  throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
};
var NODE_TYPE_ELEMENT = 1;
var DOM_PROPERTIES_TO_CHECK = [
  "innerHTML",
  "ownerDocument",
  "style",
  "attributes",
  "nodeValue"
];
is.domElement = (value) => is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
is.observable = (value) => {
  if (!value) {
    return false;
  }
  if (value === value[Symbol.observable]?.()) {
    return true;
  }
  if (value === value["@@observable"]?.()) {
    return true;
  }
  return false;
};
is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
is.infinite = (value) => value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY;
var isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
is.evenInteger = isAbsoluteMod2(0);
is.oddInteger = isAbsoluteMod2(1);
is.emptyArray = (value) => is.array(value) && value.length === 0;
is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
is.emptyString = (value) => is.string(value) && value.length === 0;
var isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
is.nonEmptyString = (value) => is.string(value) && value.length > 0;
is.nonEmptyStringAndNotWhitespace = (value) => is.string(value) && !is.emptyStringOrWhitespace(value);
is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
is.emptySet = (value) => is.set(value) && value.size === 0;
is.nonEmptySet = (value) => is.set(value) && value.size > 0;
is.emptyMap = (value) => is.map(value) && value.size === 0;
is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
is.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);
is.formData = (value) => isObjectOfType("FormData")(value);
is.urlSearchParams = (value) => isObjectOfType("URLSearchParams")(value);
var predicateOnArray = (method, predicate, values) => {
  if (!is.function_(predicate)) {
    throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
  }
  if (values.length === 0) {
    throw new TypeError("Invalid number of values");
  }
  return method.call(values, predicate);
};
is.any = (predicate, ...values) => {
  const predicates2 = is.array(predicate) ? predicate : [predicate];
  return predicates2.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values));
};
is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
var assertType = (condition, description, value, options = {}) => {
  if (!condition) {
    const { multipleValues } = options;
    const valuesMessage = multipleValues ? `received values of types ${[
      ...new Set(value.map((singleValue) => `\`${is(singleValue)}\``))
    ].join(", ")}` : `received value of type \`${is(value)}\``;
    throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
  }
};
var assert = {
  // Unknowns.
  undefined: (value) => assertType(is.undefined(value), "undefined", value),
  string: (value) => assertType(is.string(value), "string", value),
  number: (value) => assertType(is.number(value), "number", value),
  bigint: (value) => assertType(is.bigint(value), "bigint", value),
  // eslint-disable-next-line @typescript-eslint/ban-types
  function_: (value) => assertType(is.function_(value), "Function", value),
  null_: (value) => assertType(is.null_(value), "null", value),
  class_: (value) => assertType(is.class_(value), "Class", value),
  boolean: (value) => assertType(is.boolean(value), "boolean", value),
  symbol: (value) => assertType(is.symbol(value), "symbol", value),
  numericString: (value) => assertType(is.numericString(value), "string with a number", value),
  array: (value, assertion) => {
    const assert2 = assertType;
    assert2(is.array(value), "Array", value);
    if (assertion) {
      value.forEach(assertion);
    }
  },
  buffer: (value) => assertType(is.buffer(value), "Buffer", value),
  blob: (value) => assertType(is.blob(value), "Blob", value),
  nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined", value),
  object: (value) => assertType(is.object(value), "Object", value),
  iterable: (value) => assertType(is.iterable(value), "Iterable", value),
  asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable", value),
  generator: (value) => assertType(is.generator(value), "Generator", value),
  asyncGenerator: (value) => assertType(is.asyncGenerator(value), "AsyncGenerator", value),
  nativePromise: (value) => assertType(is.nativePromise(value), "native Promise", value),
  promise: (value) => assertType(is.promise(value), "Promise", value),
  generatorFunction: (value) => assertType(is.generatorFunction(value), "GeneratorFunction", value),
  asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
  // eslint-disable-next-line @typescript-eslint/ban-types
  asyncFunction: (value) => assertType(is.asyncFunction(value), "AsyncFunction", value),
  // eslint-disable-next-line @typescript-eslint/ban-types
  boundFunction: (value) => assertType(is.boundFunction(value), "Function", value),
  regExp: (value) => assertType(is.regExp(value), "RegExp", value),
  date: (value) => assertType(is.date(value), "Date", value),
  error: (value) => assertType(is.error(value), "Error", value),
  map: (value) => assertType(is.map(value), "Map", value),
  set: (value) => assertType(is.set(value), "Set", value),
  weakMap: (value) => assertType(is.weakMap(value), "WeakMap", value),
  weakSet: (value) => assertType(is.weakSet(value), "WeakSet", value),
  weakRef: (value) => assertType(is.weakRef(value), "WeakRef", value),
  int8Array: (value) => assertType(is.int8Array(value), "Int8Array", value),
  uint8Array: (value) => assertType(is.uint8Array(value), "Uint8Array", value),
  uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), "Uint8ClampedArray", value),
  int16Array: (value) => assertType(is.int16Array(value), "Int16Array", value),
  uint16Array: (value) => assertType(is.uint16Array(value), "Uint16Array", value),
  int32Array: (value) => assertType(is.int32Array(value), "Int32Array", value),
  uint32Array: (value) => assertType(is.uint32Array(value), "Uint32Array", value),
  float32Array: (value) => assertType(is.float32Array(value), "Float32Array", value),
  float64Array: (value) => assertType(is.float64Array(value), "Float64Array", value),
  bigInt64Array: (value) => assertType(is.bigInt64Array(value), "BigInt64Array", value),
  bigUint64Array: (value) => assertType(is.bigUint64Array(value), "BigUint64Array", value),
  arrayBuffer: (value) => assertType(is.arrayBuffer(value), "ArrayBuffer", value),
  sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), "SharedArrayBuffer", value),
  dataView: (value) => assertType(is.dataView(value), "DataView", value),
  enumCase: (value, targetEnum) => assertType(is.enumCase(value, targetEnum), "EnumCase", value),
  urlInstance: (value) => assertType(is.urlInstance(value), "URL", value),
  urlString: (value) => assertType(is.urlString(value), "string with a URL", value),
  truthy: (value) => assertType(is.truthy(value), "truthy", value),
  falsy: (value) => assertType(is.falsy(value), "falsy", value),
  nan: (value) => assertType(is.nan(value), "NaN", value),
  primitive: (value) => assertType(is.primitive(value), "primitive", value),
  integer: (value) => assertType(is.integer(value), "integer", value),
  safeInteger: (value) => assertType(is.safeInteger(value), "integer", value),
  plainObject: (value) => assertType(is.plainObject(value), "plain object", value),
  typedArray: (value) => assertType(is.typedArray(value), "TypedArray", value),
  arrayLike: (value) => assertType(is.arrayLike(value), "array-like", value),
  domElement: (value) => assertType(is.domElement(value), "HTMLElement", value),
  observable: (value) => assertType(is.observable(value), "Observable", value),
  nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream", value),
  infinite: (value) => assertType(is.infinite(value), "infinite number", value),
  emptyArray: (value) => assertType(is.emptyArray(value), "empty array", value),
  nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array", value),
  emptyString: (value) => assertType(is.emptyString(value), "empty string", value),
  emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace", value),
  nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string", value),
  nonEmptyStringAndNotWhitespace: (value) => assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace", value),
  emptyObject: (value) => assertType(is.emptyObject(value), "empty object", value),
  nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object", value),
  emptySet: (value) => assertType(is.emptySet(value), "empty set", value),
  nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set", value),
  emptyMap: (value) => assertType(is.emptyMap(value), "empty map", value),
  nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map", value),
  propertyKey: (value) => assertType(is.propertyKey(value), "PropertyKey", value),
  formData: (value) => assertType(is.formData(value), "FormData", value),
  urlSearchParams: (value) => assertType(is.urlSearchParams(value), "URLSearchParams", value),
  // Numbers.
  evenInteger: (value) => assertType(is.evenInteger(value), "even integer", value),
  oddInteger: (value) => assertType(is.oddInteger(value), "odd integer", value),
  // Two arguments.
  directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T", instance),
  inRange: (value, range) => assertType(is.inRange(value, range), "in range", value),
  // Variadic functions.
  any: (predicate, ...values) => assertType(is.any(predicate, ...values), "predicate returns truthy for any value", values, { multipleValues: true }),
  all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values", values, { multipleValues: true })
};
Object.defineProperties(is, {
  class: {
    value: is.class_
  },
  function: {
    value: is.function_
  },
  null: {
    value: is.null_
  }
});
Object.defineProperties(assert, {
  class: {
    value: assert.class_
  },
  function: {
    value: assert.function_
  },
  null: {
    value: assert.null_
  }
});
var dist_default = is;

// node_modules/got/dist/source/as-promise/index.js
var import_node_events2 = require("node:events");

// node_modules/p-cancelable/index.js
var CancelError = class extends Error {
  constructor(reason) {
    super(reason || "Promise was canceled");
    this.name = "CancelError";
  }
  get isCanceled() {
    return true;
  }
};
var PCancelable = class {
  static fn(userFunction) {
    return (...arguments_) => {
      return new PCancelable((resolve, reject, onCancel) => {
        arguments_.push(onCancel);
        userFunction(...arguments_).then(resolve, reject);
      });
    };
  }
  constructor(executor) {
    this._cancelHandlers = [];
    this._isPending = true;
    this._isCanceled = false;
    this._rejectOnCancel = true;
    this._promise = new Promise((resolve, reject) => {
      this._reject = reject;
      const onResolve = (value) => {
        if (!this._isCanceled || !onCancel.shouldReject) {
          this._isPending = false;
          resolve(value);
        }
      };
      const onReject = (error2) => {
        this._isPending = false;
        reject(error2);
      };
      const onCancel = (handler) => {
        if (!this._isPending) {
          throw new Error("The `onCancel` handler was attached after the promise settled.");
        }
        this._cancelHandlers.push(handler);
      };
      Object.defineProperties(onCancel, {
        shouldReject: {
          get: () => this._rejectOnCancel,
          set: (boolean) => {
            this._rejectOnCancel = boolean;
          }
        }
      });
      executor(onResolve, onReject, onCancel);
    });
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this._promise.catch(onRejected);
  }
  finally(onFinally) {
    return this._promise.finally(onFinally);
  }
  cancel(reason) {
    if (!this._isPending || this._isCanceled) {
      return;
    }
    this._isCanceled = true;
    if (this._cancelHandlers.length > 0) {
      try {
        for (const handler of this._cancelHandlers) {
          handler();
        }
      } catch (error2) {
        this._reject(error2);
        return;
      }
    }
    if (this._rejectOnCancel) {
      this._reject(new CancelError(reason));
    }
  }
  get isCanceled() {
    return this._isCanceled;
  }
};
Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

// node_modules/got/dist/source/core/errors.js
function isRequest(x) {
  return dist_default.object(x) && "_onResponse" in x;
}
var RequestError2 = class extends Error {
  constructor(message, error2, self2) {
    super(message);
    Object.defineProperty(this, "input", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "stack", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "response", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "request", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "timings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Error.captureStackTrace(this, this.constructor);
    this.name = "RequestError";
    this.code = error2.code ?? "ERR_GOT_REQUEST_ERROR";
    this.input = error2.input;
    if (isRequest(self2)) {
      Object.defineProperty(this, "request", {
        enumerable: false,
        value: self2
      });
      Object.defineProperty(this, "response", {
        enumerable: false,
        value: self2.response
      });
      this.options = self2.options;
    } else {
      this.options = self2;
    }
    this.timings = this.request?.timings;
    if (dist_default.string(error2.stack) && dist_default.string(this.stack)) {
      const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
      const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
      const errorStackTrace = error2.stack.slice(error2.stack.indexOf(error2.message) + error2.message.length).split("\n").reverse();
      while (errorStackTrace.length > 0 && errorStackTrace[0] === thisStackTrace[0]) {
        thisStackTrace.shift();
      }
      this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
    }
  }
};
var MaxRedirectsError = class extends RequestError2 {
  constructor(request2) {
    super(`Redirected ${request2.options.maxRedirects} times. Aborting.`, {}, request2);
    this.name = "MaxRedirectsError";
    this.code = "ERR_TOO_MANY_REDIRECTS";
  }
};
var HTTPError = class extends RequestError2 {
  constructor(response) {
    super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
    this.name = "HTTPError";
    this.code = "ERR_NON_2XX_3XX_RESPONSE";
  }
};
var CacheError = class extends RequestError2 {
  constructor(error2, request2) {
    super(error2.message, error2, request2);
    this.name = "CacheError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
  }
};
var UploadError = class extends RequestError2 {
  constructor(error2, request2) {
    super(error2.message, error2, request2);
    this.name = "UploadError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
  }
};
var TimeoutError = class extends RequestError2 {
  constructor(error2, timings, request2) {
    super(error2.message, error2, request2);
    Object.defineProperty(this, "timings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = "TimeoutError";
    this.event = error2.event;
    this.timings = timings;
  }
};
var ReadError = class extends RequestError2 {
  constructor(error2, request2) {
    super(error2.message, error2, request2);
    this.name = "ReadError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
  }
};
var RetryError = class extends RequestError2 {
  constructor(request2) {
    super("Retrying", {}, request2);
    this.name = "RetryError";
    this.code = "ERR_RETRYING";
  }
};
var AbortError = class extends RequestError2 {
  constructor(request2) {
    super("This operation was aborted.", {}, request2);
    this.code = "ERR_ABORTED";
    this.name = "AbortError";
  }
};

// node_modules/got/dist/source/core/index.js
var import_node_process2 = __toESM2(require("node:process"), 1);
var import_node_buffer2 = require("node:buffer");
var import_node_stream3 = require("node:stream");
var import_node_url3 = require("node:url");
var import_node_http2 = __toESM2(require("node:http"), 1);

// node_modules/@szmarczak/http-timer/dist/source/index.js
var import_events3 = require("events");
var import_util2 = require("util");
var import_defer_to_connect = __toESM2(require_source2(), 1);
var timer = (request2) => {
  if (request2.timings) {
    return request2.timings;
  }
  const timings = {
    start: Date.now(),
    socket: void 0,
    lookup: void 0,
    connect: void 0,
    secureConnect: void 0,
    upload: void 0,
    response: void 0,
    end: void 0,
    error: void 0,
    abort: void 0,
    phases: {
      wait: void 0,
      dns: void 0,
      tcp: void 0,
      tls: void 0,
      request: void 0,
      firstByte: void 0,
      download: void 0,
      total: void 0
    }
  };
  request2.timings = timings;
  const handleError = (origin) => {
    origin.once(import_events3.errorMonitor, () => {
      timings.error = Date.now();
      timings.phases.total = timings.error - timings.start;
    });
  };
  handleError(request2);
  const onAbort = () => {
    timings.abort = Date.now();
    timings.phases.total = timings.abort - timings.start;
  };
  request2.prependOnceListener("abort", onAbort);
  const onSocket = (socket) => {
    timings.socket = Date.now();
    timings.phases.wait = timings.socket - timings.start;
    if (import_util2.types.isProxy(socket)) {
      return;
    }
    const lookupListener = () => {
      timings.lookup = Date.now();
      timings.phases.dns = timings.lookup - timings.socket;
    };
    socket.prependOnceListener("lookup", lookupListener);
    (0, import_defer_to_connect.default)(socket, {
      connect: () => {
        timings.connect = Date.now();
        if (timings.lookup === void 0) {
          socket.removeListener("lookup", lookupListener);
          timings.lookup = timings.connect;
          timings.phases.dns = timings.lookup - timings.socket;
        }
        timings.phases.tcp = timings.connect - timings.lookup;
      },
      secureConnect: () => {
        timings.secureConnect = Date.now();
        timings.phases.tls = timings.secureConnect - timings.connect;
      }
    });
  };
  if (request2.socket) {
    onSocket(request2.socket);
  } else {
    request2.prependOnceListener("socket", onSocket);
  }
  const onUpload = () => {
    timings.upload = Date.now();
    timings.phases.request = timings.upload - (timings.secureConnect ?? timings.connect);
  };
  if (request2.writableFinished) {
    onUpload();
  } else {
    request2.prependOnceListener("finish", onUpload);
  }
  request2.prependOnceListener("response", (response) => {
    timings.response = Date.now();
    timings.phases.firstByte = timings.response - timings.upload;
    response.timings = timings;
    handleError(response);
    response.prependOnceListener("end", () => {
      request2.off("abort", onAbort);
      response.off("aborted", onAbort);
      if (timings.phases.total) {
        return;
      }
      timings.end = Date.now();
      timings.phases.download = timings.end - timings.response;
      timings.phases.total = timings.end - timings.start;
    });
    response.prependOnceListener("aborted", onAbort);
  });
  return timings;
};
var source_default = timer;

// node_modules/cacheable-request/dist/index.js
var import_node_events = __toESM2(require("node:events"), 1);
var import_node_url = __toESM2(require("node:url"), 1);
var import_node_crypto = __toESM2(require("node:crypto"), 1);
var import_node_stream2 = __toESM2(require("node:stream"), 1);

// node_modules/normalize-url/index.js
var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
var DATA_URL_DEFAULT_CHARSET = "us-ascii";
var testParameter = (name, filters) => filters.some((filter2) => filter2 instanceof RegExp ? filter2.test(name) : filter2 === name);
var supportedProtocols2 = /* @__PURE__ */ new Set([
  "https:",
  "http:",
  "file:"
]);
var hasCustomProtocol = (urlString) => {
  try {
    const { protocol } = new URL(urlString);
    return protocol.endsWith(":") && !supportedProtocols2.has(protocol);
  } catch {
    return false;
  }
};
var normalizeDataURL = (urlString, { stripHash }) => {
  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
  if (!match) {
    throw new Error(`Invalid URL: ${urlString}`);
  }
  let { type, data, hash } = match.groups;
  const mediaType = type.split(";");
  hash = stripHash ? "" : hash;
  let isBase64 = false;
  if (mediaType[mediaType.length - 1] === "base64") {
    mediaType.pop();
    isBase64 = true;
  }
  const mimeType = mediaType.shift()?.toLowerCase() ?? "";
  const attributes = mediaType.map((attribute) => {
    let [key, value = ""] = attribute.split("=").map((string) => string.trim());
    if (key === "charset") {
      value = value.toLowerCase();
      if (value === DATA_URL_DEFAULT_CHARSET) {
        return "";
      }
    }
    return `${key}${value ? `=${value}` : ""}`;
  }).filter(Boolean);
  const normalizedMediaType = [
    ...attributes
  ];
  if (isBase64) {
    normalizedMediaType.push("base64");
  }
  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
    normalizedMediaType.unshift(mimeType);
  }
  return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
};
function normalizeUrl(urlString, options) {
  options = {
    defaultProtocol: "http",
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripTextFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeSingleSlash: true,
    removeDirectoryIndex: false,
    removeExplicitPort: false,
    sortQueryParameters: true,
    ...options
  };
  if (typeof options.defaultProtocol === "string" && !options.defaultProtocol.endsWith(":")) {
    options.defaultProtocol = `${options.defaultProtocol}:`;
  }
  urlString = urlString.trim();
  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options);
  }
  if (hasCustomProtocol(urlString)) {
    return urlString;
  }
  const hasRelativeProtocol = urlString.startsWith("//");
  const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  }
  const urlObject = new URL(urlString);
  if (options.forceHttp && options.forceHttps) {
    throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
  }
  if (options.forceHttp && urlObject.protocol === "https:") {
    urlObject.protocol = "http:";
  }
  if (options.forceHttps && urlObject.protocol === "http:") {
    urlObject.protocol = "https:";
  }
  if (options.stripAuthentication) {
    urlObject.username = "";
    urlObject.password = "";
  }
  if (options.stripHash) {
    urlObject.hash = "";
  } else if (options.stripTextFragment) {
    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "");
  }
  if (urlObject.pathname) {
    const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;
    let lastIndex = 0;
    let result = "";
    for (; ; ) {
      const match = protocolRegex.exec(urlObject.pathname);
      if (!match) {
        break;
      }
      const protocol = match[0];
      const protocolAtIndex = match.index;
      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
      result += intermediate.replace(/\/{2,}/g, "/");
      result += protocol;
      lastIndex = protocolAtIndex + protocol.length;
    }
    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
    result += remnant.replace(/\/{2,}/g, "/");
    urlObject.pathname = result;
  }
  if (urlObject.pathname) {
    try {
      urlObject.pathname = decodeURI(urlObject.pathname);
    } catch {
    }
  }
  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }
  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    let pathComponents = urlObject.pathname.split("/");
    const lastComponent = pathComponents[pathComponents.length - 1];
    if (testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, -1);
      urlObject.pathname = pathComponents.slice(1).join("/") + "/";
    }
  }
  if (urlObject.hostname) {
    urlObject.hostname = urlObject.hostname.replace(/\.$/, "");
    if (options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)) {
      urlObject.hostname = urlObject.hostname.replace(/^www\./, "");
    }
  }
  if (Array.isArray(options.removeQueryParameters)) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (testParameter(key, options.removeQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {
    urlObject.search = "";
  }
  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (!testParameter(key, options.keepQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (options.sortQueryParameters) {
    urlObject.searchParams.sort();
    try {
      urlObject.search = decodeURIComponent(urlObject.search);
    } catch {
    }
  }
  if (options.removeTrailingSlash) {
    urlObject.pathname = urlObject.pathname.replace(/\/$/, "");
  }
  if (options.removeExplicitPort && urlObject.port) {
    urlObject.port = "";
  }
  const oldUrlString = urlString;
  urlString = urlObject.toString();
  if (!options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "") {
    urlString = urlString.replace(/\/$/, "");
  }
  if ((options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash) {
    urlString = urlString.replace(/\/$/, "");
  }
  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, "//");
  }
  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, "");
  }
  return urlString;
}

// node_modules/cacheable-request/dist/index.js
var import_get_stream2 = __toESM2(require_get_stream2(), 1);
var import_http_cache_semantics = __toESM2(require_http_cache_semantics(), 1);

// node_modules/responselike/index.js
var import_node_stream = require("node:stream");

// node_modules/lowercase-keys/index.js
function lowercaseKeys(object) {
  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key.toLowerCase(), value]));
}

// node_modules/responselike/index.js
var Response = class extends import_node_stream.Readable {
  statusCode;
  headers;
  body;
  url;
  constructor({ statusCode, headers, body, url: url2 }) {
    if (typeof statusCode !== "number") {
      throw new TypeError("Argument `statusCode` should be a number");
    }
    if (typeof headers !== "object") {
      throw new TypeError("Argument `headers` should be an object");
    }
    if (!(body instanceof Uint8Array)) {
      throw new TypeError("Argument `body` should be a buffer");
    }
    if (typeof url2 !== "string") {
      throw new TypeError("Argument `url` should be a string");
    }
    super({
      read() {
        this.push(body);
        this.push(null);
      }
    });
    this.statusCode = statusCode;
    this.headers = lowercaseKeys(headers);
    this.body = body;
    this.url = url2;
  }
};

// node_modules/cacheable-request/dist/index.js
var import_keyv = __toESM2(require_src3(), 1);

// node_modules/cacheable-request/node_modules/mimic-response/index.js
var knownProperties2 = [
  "aborted",
  "complete",
  "headers",
  "httpVersion",
  "httpVersionMinor",
  "httpVersionMajor",
  "method",
  "rawHeaders",
  "rawTrailers",
  "setTimeout",
  "socket",
  "statusCode",
  "statusMessage",
  "trailers",
  "url"
];
function mimicResponse(fromStream, toStream) {
  if (toStream._readableState.autoDestroy) {
    throw new Error("The second stream must have the `autoDestroy` option set to `false`");
  }
  const fromProperties = /* @__PURE__ */ new Set([...Object.keys(fromStream), ...knownProperties2]);
  const properties = {};
  for (const property of fromProperties) {
    if (property in toStream) {
      continue;
    }
    properties[property] = {
      get() {
        const value = fromStream[property];
        const isFunction4 = typeof value === "function";
        return isFunction4 ? value.bind(fromStream) : value;
      },
      set(value) {
        fromStream[property] = value;
      },
      enumerable: true,
      configurable: false
    };
  }
  Object.defineProperties(toStream, properties);
  fromStream.once("aborted", () => {
    toStream.destroy();
    toStream.emit("aborted");
  });
  fromStream.once("close", () => {
    if (fromStream.complete) {
      if (toStream.readable) {
        toStream.once("end", () => {
          toStream.emit("close");
        });
      } else {
        toStream.emit("close");
      }
    } else {
      toStream.emit("close");
    }
  });
  return toStream;
}

// node_modules/cacheable-request/dist/types.js
var RequestError3 = class extends Error {
  constructor(error2) {
    super(error2.message);
    Object.assign(this, error2);
  }
};
var CacheError2 = class extends Error {
  constructor(error2) {
    super(error2.message);
    Object.assign(this, error2);
  }
};

// node_modules/cacheable-request/dist/index.js
var CacheableRequest = class {
  constructor(cacheRequest, cacheAdapter) {
    this.hooks = /* @__PURE__ */ new Map();
    this.request = () => (options, cb) => {
      let url2;
      if (typeof options === "string") {
        url2 = normalizeUrlObject(import_node_url.default.parse(options));
        options = {};
      } else if (options instanceof import_node_url.default.URL) {
        url2 = normalizeUrlObject(import_node_url.default.parse(options.toString()));
        options = {};
      } else {
        const [pathname, ...searchParts] = (options.path ?? "").split("?");
        const search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
        url2 = normalizeUrlObject({ ...options, pathname, search });
      }
      options = {
        headers: {},
        method: "GET",
        cache: true,
        strictTtl: false,
        automaticFailover: false,
        ...options,
        ...urlObjectToRequestOptions(url2)
      };
      options.headers = Object.fromEntries(entries(options.headers).map(([key2, value]) => [key2.toLowerCase(), value]));
      const ee = new import_node_events.default();
      const normalizedUrlString = normalizeUrl(import_node_url.default.format(url2), {
        stripWWW: false,
        removeTrailingSlash: false,
        stripAuthentication: false
      });
      let key = `${options.method}:${normalizedUrlString}`;
      if (options.body && options.method !== void 0 && ["POST", "PATCH", "PUT"].includes(options.method)) {
        if (options.body instanceof import_node_stream2.default.Readable) {
          options.cache = false;
        } else {
          key += `:${import_node_crypto.default.createHash("md5").update(options.body).digest("hex")}`;
        }
      }
      let revalidate = false;
      let madeRequest = false;
      const makeRequest = (options_) => {
        madeRequest = true;
        let requestErrored = false;
        let requestErrorCallback = () => {
        };
        const requestErrorPromise = new Promise((resolve) => {
          requestErrorCallback = () => {
            if (!requestErrored) {
              requestErrored = true;
              resolve();
            }
          };
        });
        const handler = async (response) => {
          if (revalidate) {
            response.status = response.statusCode;
            const revalidatedPolicy = import_http_cache_semantics.default.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);
            if (!revalidatedPolicy.modified) {
              response.resume();
              await new Promise((resolve) => {
                response.once("end", resolve);
              });
              const headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());
              response = new Response({ statusCode: revalidate.statusCode, headers, body: revalidate.body, url: revalidate.url });
              response.cachePolicy = revalidatedPolicy.policy;
              response.fromCache = true;
            }
          }
          if (!response.fromCache) {
            response.cachePolicy = new import_http_cache_semantics.default(options_, response, options_);
            response.fromCache = false;
          }
          let clonedResponse;
          if (options_.cache && response.cachePolicy.storable()) {
            clonedResponse = cloneResponse(response);
            (async () => {
              try {
                const bodyPromise = import_get_stream2.default.buffer(response);
                await Promise.race([
                  requestErrorPromise,
                  new Promise((resolve) => response.once("end", resolve)),
                  new Promise((resolve) => response.once("close", resolve))
                  // eslint-disable-line no-promise-executor-return
                ]);
                const body = await bodyPromise;
                let value = {
                  url: response.url,
                  statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                  body,
                  cachePolicy: response.cachePolicy.toObject()
                };
                let ttl2 = options_.strictTtl ? response.cachePolicy.timeToLive() : void 0;
                if (options_.maxTtl) {
                  ttl2 = ttl2 ? Math.min(ttl2, options_.maxTtl) : options_.maxTtl;
                }
                if (this.hooks.size > 0) {
                  for (const key_ of this.hooks.keys()) {
                    value = await this.runHook(key_, value, response);
                  }
                }
                await this.cache.set(key, value, ttl2);
              } catch (error2) {
                ee.emit("error", new CacheError2(error2));
              }
            })();
          } else if (options_.cache && revalidate) {
            (async () => {
              try {
                await this.cache.delete(key);
              } catch (error2) {
                ee.emit("error", new CacheError2(error2));
              }
            })();
          }
          ee.emit("response", clonedResponse ?? response);
          if (typeof cb === "function") {
            cb(clonedResponse ?? response);
          }
        };
        try {
          const request_ = this.cacheRequest(options_, handler);
          request_.once("error", requestErrorCallback);
          request_.once("abort", requestErrorCallback);
          request_.once("destroy", requestErrorCallback);
          ee.emit("request", request_);
        } catch (error2) {
          ee.emit("error", new RequestError3(error2));
        }
      };
      (async () => {
        const get = async (options_) => {
          await Promise.resolve();
          const cacheEntry = options_.cache ? await this.cache.get(key) : void 0;
          if (typeof cacheEntry === "undefined" && !options_.forceRefresh) {
            makeRequest(options_);
            return;
          }
          const policy = import_http_cache_semantics.default.fromObject(cacheEntry.cachePolicy);
          if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {
            const headers = convertHeaders(policy.responseHeaders());
            const response = new Response({ statusCode: cacheEntry.statusCode, headers, body: cacheEntry.body, url: cacheEntry.url });
            response.cachePolicy = policy;
            response.fromCache = true;
            ee.emit("response", response);
            if (typeof cb === "function") {
              cb(response);
            }
          } else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {
            await this.cache.delete(key);
            options_.headers = policy.revalidationHeaders(options_);
            makeRequest(options_);
          } else {
            revalidate = cacheEntry;
            options_.headers = policy.revalidationHeaders(options_);
            makeRequest(options_);
          }
        };
        const errorHandler = (error2) => ee.emit("error", new CacheError2(error2));
        if (this.cache instanceof import_keyv.default) {
          const cachek = this.cache;
          cachek.once("error", errorHandler);
          ee.on("error", () => cachek.removeListener("error", errorHandler));
        }
        try {
          await get(options);
        } catch (error2) {
          if (options.automaticFailover && !madeRequest) {
            makeRequest(options);
          }
          ee.emit("error", new CacheError2(error2));
        }
      })();
      return ee;
    };
    this.addHook = (name, fn) => {
      if (!this.hooks.has(name)) {
        this.hooks.set(name, fn);
      }
    };
    this.removeHook = (name) => this.hooks.delete(name);
    this.getHook = (name) => this.hooks.get(name);
    this.runHook = async (name, ...args) => this.hooks.get(name)?.(...args);
    if (cacheAdapter instanceof import_keyv.default) {
      this.cache = cacheAdapter;
    } else if (typeof cacheAdapter === "string") {
      this.cache = new import_keyv.default({
        uri: cacheAdapter,
        namespace: "cacheable-request"
      });
    } else {
      this.cache = new import_keyv.default({
        store: cacheAdapter,
        namespace: "cacheable-request"
      });
    }
    this.request = this.request.bind(this);
    this.cacheRequest = cacheRequest;
  }
};
var entries = Object.entries;
var cloneResponse = (response) => {
  const clone2 = new import_node_stream2.PassThrough({ autoDestroy: false });
  mimicResponse(response, clone2);
  return response.pipe(clone2);
};
var urlObjectToRequestOptions = (url2) => {
  const options = { ...url2 };
  options.path = `${url2.pathname || "/"}${url2.search || ""}`;
  delete options.pathname;
  delete options.search;
  return options;
};
var normalizeUrlObject = (url2) => (
  // If url was parsed by url.parse or new URL:
  // - hostname will be set
  // - host will be hostname[:port]
  // - port will be set if it was explicit in the parsed string
  // Otherwise, url was from request options:
  // - hostname or host may be set
  // - host shall not have port encoded
  {
    protocol: url2.protocol,
    auth: url2.auth,
    hostname: url2.hostname || url2.host || "localhost",
    port: url2.port,
    pathname: url2.pathname,
    search: url2.search
  }
);
var convertHeaders = (headers) => {
  const result = [];
  for (const name of Object.keys(headers)) {
    result[name.toLowerCase()] = headers[name];
  }
  return result;
};
var dist_default2 = CacheableRequest;

// node_modules/got/dist/source/core/index.js
var import_decompress_response = __toESM2(require_decompress_response(), 1);
var import_get_stream3 = __toESM2(require_get_stream2(), 1);

// node_modules/got/node_modules/form-data-encoder/lib/util/isFunction.js
var isFunction3 = (value) => typeof value === "function";

// node_modules/got/node_modules/form-data-encoder/lib/util/getStreamIterator.js
var isAsyncIterable = (value) => isFunction3(value[Symbol.asyncIterator]);
async function* readStream(readable) {
  const reader = readable.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    yield value;
  }
}
var getStreamIterator = (source) => {
  if (isAsyncIterable(source)) {
    return source;
  }
  if (isFunction3(source.getReader)) {
    return readStream(source);
  }
  throw new TypeError("Unsupported data source: Expected either ReadableStream or async iterable.");
};

// node_modules/got/node_modules/form-data-encoder/lib/util/createBoundary.js
var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
  let size = 16;
  let res = "";
  while (size--) {
    res += alphabet[Math.random() * alphabet.length << 0];
  }
  return res;
}

// node_modules/got/node_modules/form-data-encoder/lib/util/normalizeValue.js
var normalizeValue2 = (value) => String(value).replace(/\r|\n/g, (match, i, str) => {
  if (match === "\r" && str[i + 1] !== "\n" || match === "\n" && str[i - 1] !== "\r") {
    return "\r\n";
  }
  return match;
});

// node_modules/got/node_modules/form-data-encoder/lib/util/isPlainObject.js
var getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
function isPlainObject3(value) {
  if (getType(value) !== "object") {
    return false;
  }
  const pp = Object.getPrototypeOf(value);
  if (pp === null || pp === void 0) {
    return true;
  }
  const Ctor = pp.constructor && pp.constructor.toString();
  return Ctor === Object.toString();
}

// node_modules/got/node_modules/form-data-encoder/lib/util/proxyHeaders.js
function getProperty(target, prop) {
  if (typeof prop === "string") {
    for (const [name, value] of Object.entries(target)) {
      if (prop.toLowerCase() === name.toLowerCase()) {
        return value;
      }
    }
  }
  return void 0;
}
var proxyHeaders = (object) => new Proxy(object, {
  get: (target, prop) => getProperty(target, prop),
  has: (target, prop) => getProperty(target, prop) !== void 0
});

// node_modules/got/node_modules/form-data-encoder/lib/util/isFormData.js
var isFormData2 = (value) => Boolean(value && isFunction3(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction3(value.append) && isFunction3(value.getAll) && isFunction3(value.entries) && isFunction3(value[Symbol.iterator]));

// node_modules/got/node_modules/form-data-encoder/lib/util/escapeName.js
var escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");

// node_modules/got/node_modules/form-data-encoder/lib/util/isFile.js
var isFile2 = (value) => Boolean(value && typeof value === "object" && isFunction3(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction3(value.stream) && value.name != null);

// node_modules/got/node_modules/form-data-encoder/lib/FormDataEncoder.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FormDataEncoder_instances;
var _FormDataEncoder_CRLF;
var _FormDataEncoder_CRLF_BYTES;
var _FormDataEncoder_CRLF_BYTES_LENGTH;
var _FormDataEncoder_DASHES;
var _FormDataEncoder_encoder;
var _FormDataEncoder_footer;
var _FormDataEncoder_form;
var _FormDataEncoder_options;
var _FormDataEncoder_getFieldHeader;
var _FormDataEncoder_getContentLength;
var defaultOptions = {
  enableAdditionalHeaders: false
};
var readonlyProp = { writable: false, configurable: false };
var FormDataEncoder = class {
  constructor(form, boundaryOrOptions, options) {
    _FormDataEncoder_instances.add(this);
    _FormDataEncoder_CRLF.set(this, "\r\n");
    _FormDataEncoder_CRLF_BYTES.set(this, void 0);
    _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
    _FormDataEncoder_DASHES.set(this, "-".repeat(2));
    _FormDataEncoder_encoder.set(this, new TextEncoder());
    _FormDataEncoder_footer.set(this, void 0);
    _FormDataEncoder_form.set(this, void 0);
    _FormDataEncoder_options.set(this, void 0);
    if (!isFormData2(form)) {
      throw new TypeError("Expected first argument to be a FormData instance.");
    }
    let boundary;
    if (isPlainObject3(boundaryOrOptions)) {
      options = boundaryOrOptions;
    } else {
      boundary = boundaryOrOptions;
    }
    if (!boundary) {
      boundary = createBoundary();
    }
    if (typeof boundary !== "string") {
      throw new TypeError("Expected boundary argument to be a string.");
    }
    if (options && !isPlainObject3(options)) {
      throw new TypeError("Expected options argument to be an object.");
    }
    __classPrivateFieldSet(this, _FormDataEncoder_form, Array.from(form.entries()), "f");
    __classPrivateFieldSet(this, _FormDataEncoder_options, { ...defaultOptions, ...options }, "f");
    __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")), "f");
    __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
    this.boundary = `form-data-boundary-${boundary}`;
    this.contentType = `multipart/form-data; boundary=${this.boundary}`;
    __classPrivateFieldSet(this, _FormDataEncoder_footer, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
    const headers = {
      "Content-Type": this.contentType
    };
    const contentLength = __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getContentLength).call(this);
    if (contentLength) {
      this.contentLength = contentLength;
      headers["Content-Length"] = contentLength;
    }
    this.headers = proxyHeaders(Object.freeze(headers));
    Object.defineProperties(this, {
      boundary: readonlyProp,
      contentType: readonlyProp,
      contentLength: readonlyProp,
      headers: readonlyProp
    });
  }
  getContentLength() {
    return this.contentLength == null ? void 0 : Number(this.contentLength);
  }
  *values() {
    for (const [name, raw2] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
      const value = isFile2(raw2) ? raw2 : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(normalizeValue2(raw2));
      yield __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
      yield value;
      yield __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f");
    }
    yield __classPrivateFieldGet(this, _FormDataEncoder_footer, "f");
  }
  async *encode() {
    for (const part of this.values()) {
      if (isFile2(part)) {
        yield* getStreamIterator(part.stream());
      } else {
        yield part;
      }
    }
  }
  [(_FormDataEncoder_CRLF = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_DASHES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_encoder = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_footer = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_form = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_options = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_instances = /* @__PURE__ */ new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader2(name, value) {
    let header = "";
    header += `${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
    header += `Content-Disposition: form-data; name="${escapeName(name)}"`;
    if (isFile2(value)) {
      header += `; filename="${escapeName(value.name)}"${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
      header += `Content-Type: ${value.type || "application/octet-stream"}`;
    }
    const size = isFile2(value) ? value.size : value.byteLength;
    if (__classPrivateFieldGet(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true && size != null && !isNaN(size)) {
      header += `${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${isFile2(value) ? value.size : value.byteLength}`;
    }
    return __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
  }, _FormDataEncoder_getContentLength = function _FormDataEncoder_getContentLength2() {
    let length = 0;
    for (const [name, raw2] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
      const value = isFile2(raw2) ? raw2 : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(normalizeValue2(raw2));
      const size = isFile2(value) ? value.size : value.byteLength;
      if (size == null || isNaN(size)) {
        return void 0;
      }
      length += __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
      length += size;
      length += __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
    }
    return String(length + __classPrivateFieldGet(this, _FormDataEncoder_footer, "f").byteLength);
  }, Symbol.iterator)]() {
    return this.values();
  }
  [Symbol.asyncIterator]() {
    return this.encode();
  }
};

// node_modules/got/dist/source/core/utils/get-body-size.js
var import_node_buffer = require("node:buffer");
var import_node_util = require("node:util");

// node_modules/got/dist/source/core/utils/is-form-data.js
function isFormData3(body) {
  return dist_default.nodeStream(body) && dist_default.function_(body.getBoundary);
}

// node_modules/got/dist/source/core/utils/get-body-size.js
async function getBodySize(body, headers) {
  if (headers && "content-length" in headers) {
    return Number(headers["content-length"]);
  }
  if (!body) {
    return 0;
  }
  if (dist_default.string(body)) {
    return import_node_buffer.Buffer.byteLength(body);
  }
  if (dist_default.buffer(body)) {
    return body.length;
  }
  if (isFormData3(body)) {
    return (0, import_node_util.promisify)(body.getLength.bind(body))();
  }
  return void 0;
}

// node_modules/got/dist/source/core/utils/proxy-events.js
function proxyEvents(from, to, events) {
  const eventFunctions = {};
  for (const event of events) {
    const eventFunction = (...args) => {
      to.emit(event, ...args);
    };
    eventFunctions[event] = eventFunction;
    from.on(event, eventFunction);
  }
  return () => {
    for (const [event, eventFunction] of Object.entries(eventFunctions)) {
      from.off(event, eventFunction);
    }
  };
}

// node_modules/got/dist/source/core/timed-out.js
var import_node_net = __toESM2(require("node:net"), 1);

// node_modules/got/dist/source/core/utils/unhandle.js
function unhandle() {
  const handlers = [];
  return {
    once(origin, event, fn) {
      origin.once(event, fn);
      handlers.push({ origin, event, fn });
    },
    unhandleAll() {
      for (const handler of handlers) {
        const { origin, event, fn } = handler;
        origin.removeListener(event, fn);
      }
      handlers.length = 0;
    }
  };
}

// node_modules/got/dist/source/core/timed-out.js
var reentry = Symbol("reentry");
var noop2 = () => {
};
var TimeoutError2 = class extends Error {
  constructor(threshold, event) {
    super(`Timeout awaiting '${event}' for ${threshold}ms`);
    Object.defineProperty(this, "event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: event
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = "TimeoutError";
    this.code = "ETIMEDOUT";
  }
};
function timedOut(request2, delays, options) {
  if (reentry in request2) {
    return noop2;
  }
  request2[reentry] = true;
  const cancelers = [];
  const { once, unhandleAll } = unhandle();
  const addTimeout = (delay2, callback, event) => {
    const timeout = setTimeout(callback, delay2, delay2, event);
    timeout.unref?.();
    const cancel = () => {
      clearTimeout(timeout);
    };
    cancelers.push(cancel);
    return cancel;
  };
  const { host, hostname } = options;
  const timeoutHandler = (delay2, event) => {
    request2.destroy(new TimeoutError2(delay2, event));
  };
  const cancelTimeouts = () => {
    for (const cancel of cancelers) {
      cancel();
    }
    unhandleAll();
  };
  request2.once("error", (error2) => {
    cancelTimeouts();
    if (request2.listenerCount("error") === 0) {
      throw error2;
    }
  });
  if (typeof delays.request !== "undefined") {
    const cancelTimeout = addTimeout(delays.request, timeoutHandler, "request");
    once(request2, "response", (response) => {
      once(response, "end", cancelTimeout);
    });
  }
  if (typeof delays.socket !== "undefined") {
    const { socket } = delays;
    const socketTimeoutHandler = () => {
      timeoutHandler(socket, "socket");
    };
    request2.setTimeout(socket, socketTimeoutHandler);
    cancelers.push(() => {
      request2.removeListener("timeout", socketTimeoutHandler);
    });
  }
  const hasLookup = typeof delays.lookup !== "undefined";
  const hasConnect = typeof delays.connect !== "undefined";
  const hasSecureConnect = typeof delays.secureConnect !== "undefined";
  const hasSend = typeof delays.send !== "undefined";
  if (hasLookup || hasConnect || hasSecureConnect || hasSend) {
    once(request2, "socket", (socket) => {
      const { socketPath } = request2;
      if (socket.connecting) {
        const hasPath = Boolean(socketPath ?? import_node_net.default.isIP(hostname ?? host ?? "") !== 0);
        if (hasLookup && !hasPath && typeof socket.address().address === "undefined") {
          const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
          once(socket, "lookup", cancelTimeout);
        }
        if (hasConnect) {
          const timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
          if (hasPath) {
            once(socket, "connect", timeConnect());
          } else {
            once(socket, "lookup", (error2) => {
              if (error2 === null) {
                once(socket, "connect", timeConnect());
              }
            });
          }
        }
        if (hasSecureConnect && options.protocol === "https:") {
          once(socket, "connect", () => {
            const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
            once(socket, "secureConnect", cancelTimeout);
          });
        }
      }
      if (hasSend) {
        const timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
        if (socket.connecting) {
          once(socket, "connect", () => {
            once(request2, "upload-complete", timeRequest());
          });
        } else {
          once(request2, "upload-complete", timeRequest());
        }
      }
    });
  }
  if (typeof delays.response !== "undefined") {
    once(request2, "upload-complete", () => {
      const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
      once(request2, "response", cancelTimeout);
    });
  }
  if (typeof delays.read !== "undefined") {
    once(request2, "response", (response) => {
      const cancelTimeout = addTimeout(delays.read, timeoutHandler, "read");
      once(response, "end", cancelTimeout);
    });
  }
  return cancelTimeouts;
}

// node_modules/got/dist/source/core/utils/url-to-options.js
function urlToOptions(url2) {
  url2 = url2;
  const options = {
    protocol: url2.protocol,
    hostname: dist_default.string(url2.hostname) && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname,
    host: url2.host,
    hash: url2.hash,
    search: url2.search,
    pathname: url2.pathname,
    href: url2.href,
    path: `${url2.pathname || ""}${url2.search || ""}`
  };
  if (dist_default.string(url2.port) && url2.port.length > 0) {
    options.port = Number(url2.port);
  }
  if (url2.username || url2.password) {
    options.auth = `${url2.username || ""}:${url2.password || ""}`;
  }
  return options;
}

// node_modules/got/dist/source/core/utils/weakable-map.js
var WeakableMap = class {
  constructor() {
    Object.defineProperty(this, "weakMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "map", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.weakMap = /* @__PURE__ */ new WeakMap();
    this.map = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    if (typeof key === "object") {
      this.weakMap.set(key, value);
    } else {
      this.map.set(key, value);
    }
  }
  get(key) {
    if (typeof key === "object") {
      return this.weakMap.get(key);
    }
    return this.map.get(key);
  }
  has(key) {
    if (typeof key === "object") {
      return this.weakMap.has(key);
    }
    return this.map.has(key);
  }
};

// node_modules/got/dist/source/core/calculate-retry-delay.js
var calculateRetryDelay = ({ attemptCount, retryOptions, error: error2, retryAfter, computedValue }) => {
  if (error2.name === "RetryError") {
    return 1;
  }
  if (attemptCount > retryOptions.limit) {
    return 0;
  }
  const hasMethod = retryOptions.methods.includes(error2.options.method);
  const hasErrorCode = retryOptions.errorCodes.includes(error2.code);
  const hasStatusCode = error2.response && retryOptions.statusCodes.includes(error2.response.statusCode);
  if (!hasMethod || !hasErrorCode && !hasStatusCode) {
    return 0;
  }
  if (error2.response) {
    if (retryAfter) {
      if (retryAfter > computedValue) {
        return 0;
      }
      return retryAfter;
    }
    if (error2.response.statusCode === 413) {
      return 0;
    }
  }
  const noise = Math.random() * retryOptions.noise;
  return Math.min(2 ** (attemptCount - 1) * 1e3, retryOptions.backoffLimit) + noise;
};
var calculate_retry_delay_default = calculateRetryDelay;

// node_modules/got/dist/source/core/options.js
var import_node_process = __toESM2(require("node:process"), 1);
var import_node_util3 = require("node:util");
var import_node_url2 = require("node:url");
var import_node_tls = require("node:tls");
var import_node_http = __toESM2(require("node:http"), 1);
var import_node_https = __toESM2(require("node:https"), 1);

// node_modules/cacheable-lookup/source/index.js
var import_node_dns = require("node:dns");
var import_node_util2 = require("node:util");
var import_node_os = __toESM2(require("node:os"), 1);
var { Resolver: AsyncResolver } = import_node_dns.promises;
var kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection");
var kCacheableLookupInstance = Symbol("cacheableLookupInstance");
var kExpires = Symbol("expires");
var supportsALL = typeof import_node_dns.ALL === "number";
var verifyAgent = (agent) => {
  if (!(agent && typeof agent.createConnection === "function")) {
    throw new Error("Expected an Agent instance as the first argument");
  }
};
var map4to6 = (entries2) => {
  for (const entry of entries2) {
    if (entry.family === 6) {
      continue;
    }
    entry.address = `::ffff:${entry.address}`;
    entry.family = 6;
  }
};
var getIfaceInfo = () => {
  let has4 = false;
  let has6 = false;
  for (const device of Object.values(import_node_os.default.networkInterfaces())) {
    for (const iface of device) {
      if (iface.internal) {
        continue;
      }
      if (iface.family === "IPv6") {
        has6 = true;
      } else {
        has4 = true;
      }
      if (has4 && has6) {
        return { has4, has6 };
      }
    }
  }
  return { has4, has6 };
};
var isIterable = (map) => {
  return Symbol.iterator in map;
};
var ignoreNoResultErrors = (dnsPromise) => {
  return dnsPromise.catch((error2) => {
    if (error2.code === "ENODATA" || error2.code === "ENOTFOUND" || error2.code === "ENOENT") {
      return [];
    }
    throw error2;
  });
};
var ttl = { ttl: true };
var all3 = { all: true };
var all4 = { all: true, family: 4 };
var all6 = { all: true, family: 6 };
var CacheableLookup = class {
  constructor({
    cache = /* @__PURE__ */ new Map(),
    maxTtl = Infinity,
    fallbackDuration = 3600,
    errorTtl = 0.15,
    resolver = new AsyncResolver(),
    lookup = import_node_dns.lookup
  } = {}) {
    this.maxTtl = maxTtl;
    this.errorTtl = errorTtl;
    this._cache = cache;
    this._resolver = resolver;
    this._dnsLookup = lookup && (0, import_node_util2.promisify)(lookup);
    this.stats = {
      cache: 0,
      query: 0
    };
    if (this._resolver instanceof AsyncResolver) {
      this._resolve4 = this._resolver.resolve4.bind(this._resolver);
      this._resolve6 = this._resolver.resolve6.bind(this._resolver);
    } else {
      this._resolve4 = (0, import_node_util2.promisify)(this._resolver.resolve4.bind(this._resolver));
      this._resolve6 = (0, import_node_util2.promisify)(this._resolver.resolve6.bind(this._resolver));
    }
    this._iface = getIfaceInfo();
    this._pending = {};
    this._nextRemovalTime = false;
    this._hostnamesToFallback = /* @__PURE__ */ new Set();
    this.fallbackDuration = fallbackDuration;
    if (fallbackDuration > 0) {
      const interval = setInterval(() => {
        this._hostnamesToFallback.clear();
      }, fallbackDuration * 1e3);
      if (interval.unref) {
        interval.unref();
      }
      this._fallbackInterval = interval;
    }
    this.lookup = this.lookup.bind(this);
    this.lookupAsync = this.lookupAsync.bind(this);
  }
  set servers(servers) {
    this.clear();
    this._resolver.setServers(servers);
  }
  get servers() {
    return this._resolver.getServers();
  }
  lookup(hostname, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (typeof options === "number") {
      options = {
        family: options
      };
    }
    if (!callback) {
      throw new Error("Callback must be a function.");
    }
    this.lookupAsync(hostname, options).then((result) => {
      if (options.all) {
        callback(null, result);
      } else {
        callback(null, result.address, result.family, result.expires, result.ttl, result.source);
      }
    }, callback);
  }
  async lookupAsync(hostname, options = {}) {
    if (typeof options === "number") {
      options = {
        family: options
      };
    }
    let cached = await this.query(hostname);
    if (options.family === 6) {
      const filtered = cached.filter((entry) => entry.family === 6);
      if (options.hints & import_node_dns.V4MAPPED) {
        if (supportsALL && options.hints & import_node_dns.ALL || filtered.length === 0) {
          map4to6(cached);
        } else {
          cached = filtered;
        }
      } else {
        cached = filtered;
      }
    } else if (options.family === 4) {
      cached = cached.filter((entry) => entry.family === 4);
    }
    if (options.hints & import_node_dns.ADDRCONFIG) {
      const { _iface } = this;
      cached = cached.filter((entry) => entry.family === 6 ? _iface.has6 : _iface.has4);
    }
    if (cached.length === 0) {
      const error2 = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
      error2.code = "ENOTFOUND";
      error2.hostname = hostname;
      throw error2;
    }
    if (options.all) {
      return cached;
    }
    return cached[0];
  }
  async query(hostname) {
    let source = "cache";
    let cached = await this._cache.get(hostname);
    if (cached) {
      this.stats.cache++;
    }
    if (!cached) {
      const pending = this._pending[hostname];
      if (pending) {
        this.stats.cache++;
        cached = await pending;
      } else {
        source = "query";
        const newPromise = this.queryAndCache(hostname);
        this._pending[hostname] = newPromise;
        this.stats.query++;
        try {
          cached = await newPromise;
        } finally {
          delete this._pending[hostname];
        }
      }
    }
    cached = cached.map((entry) => {
      return { ...entry, source };
    });
    return cached;
  }
  async _resolve(hostname) {
    const [A, AAAA] = await Promise.all([
      ignoreNoResultErrors(this._resolve4(hostname, ttl)),
      ignoreNoResultErrors(this._resolve6(hostname, ttl))
    ]);
    let aTtl = 0;
    let aaaaTtl = 0;
    let cacheTtl = 0;
    const now = Date.now();
    for (const entry of A) {
      entry.family = 4;
      entry.expires = now + entry.ttl * 1e3;
      aTtl = Math.max(aTtl, entry.ttl);
    }
    for (const entry of AAAA) {
      entry.family = 6;
      entry.expires = now + entry.ttl * 1e3;
      aaaaTtl = Math.max(aaaaTtl, entry.ttl);
    }
    if (A.length > 0) {
      if (AAAA.length > 0) {
        cacheTtl = Math.min(aTtl, aaaaTtl);
      } else {
        cacheTtl = aTtl;
      }
    } else {
      cacheTtl = aaaaTtl;
    }
    return {
      entries: [
        ...A,
        ...AAAA
      ],
      cacheTtl
    };
  }
  async _lookup(hostname) {
    try {
      const [A, AAAA] = await Promise.all([
        // Passing {all: true} doesn't return all IPv4 and IPv6 entries.
        // See https://github.com/szmarczak/cacheable-lookup/issues/42
        ignoreNoResultErrors(this._dnsLookup(hostname, all4)),
        ignoreNoResultErrors(this._dnsLookup(hostname, all6))
      ]);
      return {
        entries: [
          ...A,
          ...AAAA
        ],
        cacheTtl: 0
      };
    } catch {
      return {
        entries: [],
        cacheTtl: 0
      };
    }
  }
  async _set(hostname, data, cacheTtl) {
    if (this.maxTtl > 0 && cacheTtl > 0) {
      cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1e3;
      data[kExpires] = Date.now() + cacheTtl;
      try {
        await this._cache.set(hostname, data, cacheTtl);
      } catch (error2) {
        this.lookupAsync = async () => {
          const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
          cacheError.cause = error2;
          throw cacheError;
        };
      }
      if (isIterable(this._cache)) {
        this._tick(cacheTtl);
      }
    }
  }
  async queryAndCache(hostname) {
    if (this._hostnamesToFallback.has(hostname)) {
      return this._dnsLookup(hostname, all3);
    }
    let query2 = await this._resolve(hostname);
    if (query2.entries.length === 0 && this._dnsLookup) {
      query2 = await this._lookup(hostname);
      if (query2.entries.length !== 0 && this.fallbackDuration > 0) {
        this._hostnamesToFallback.add(hostname);
      }
    }
    const cacheTtl = query2.entries.length === 0 ? this.errorTtl : query2.cacheTtl;
    await this._set(hostname, query2.entries, cacheTtl);
    return query2.entries;
  }
  _tick(ms) {
    const nextRemovalTime = this._nextRemovalTime;
    if (!nextRemovalTime || ms < nextRemovalTime) {
      clearTimeout(this._removalTimeout);
      this._nextRemovalTime = ms;
      this._removalTimeout = setTimeout(() => {
        this._nextRemovalTime = false;
        let nextExpiry = Infinity;
        const now = Date.now();
        for (const [hostname, entries2] of this._cache) {
          const expires = entries2[kExpires];
          if (now >= expires) {
            this._cache.delete(hostname);
          } else if (expires < nextExpiry) {
            nextExpiry = expires;
          }
        }
        if (nextExpiry !== Infinity) {
          this._tick(nextExpiry - now);
        }
      }, ms);
      if (this._removalTimeout.unref) {
        this._removalTimeout.unref();
      }
    }
  }
  install(agent) {
    verifyAgent(agent);
    if (kCacheableLookupCreateConnection in agent) {
      throw new Error("CacheableLookup has been already installed");
    }
    agent[kCacheableLookupCreateConnection] = agent.createConnection;
    agent[kCacheableLookupInstance] = this;
    agent.createConnection = (options, callback) => {
      if (!("lookup" in options)) {
        options.lookup = this.lookup;
      }
      return agent[kCacheableLookupCreateConnection](options, callback);
    };
  }
  uninstall(agent) {
    verifyAgent(agent);
    if (agent[kCacheableLookupCreateConnection]) {
      if (agent[kCacheableLookupInstance] !== this) {
        throw new Error("The agent is not owned by this CacheableLookup instance");
      }
      agent.createConnection = agent[kCacheableLookupCreateConnection];
      delete agent[kCacheableLookupCreateConnection];
      delete agent[kCacheableLookupInstance];
    }
  }
  updateInterfaceInfo() {
    const { _iface } = this;
    this._iface = getIfaceInfo();
    if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
      this._cache.clear();
    }
  }
  clear(hostname) {
    if (hostname) {
      this._cache.delete(hostname);
      return;
    }
    this._cache.clear();
  }
};

// node_modules/got/dist/source/core/options.js
var import_http2_wrapper = __toESM2(require_source3(), 1);

// node_modules/got/dist/source/core/parse-link-header.js
function parseLinkHeader(link) {
  const parsed = [];
  const items = link.split(",");
  for (const item of items) {
    const [rawUriReference, ...rawLinkParameters] = item.split(";");
    const trimmedUriReference = rawUriReference.trim();
    if (trimmedUriReference[0] !== "<" || trimmedUriReference[trimmedUriReference.length - 1] !== ">") {
      throw new Error(`Invalid format of the Link header reference: ${trimmedUriReference}`);
    }
    const reference = trimmedUriReference.slice(1, -1);
    const parameters = {};
    if (rawLinkParameters.length === 0) {
      throw new Error(`Unexpected end of Link header parameters: ${rawLinkParameters.join(";")}`);
    }
    for (const rawParameter of rawLinkParameters) {
      const trimmedRawParameter = rawParameter.trim();
      const center = trimmedRawParameter.indexOf("=");
      if (center === -1) {
        throw new Error(`Failed to parse Link header: ${link}`);
      }
      const name = trimmedRawParameter.slice(0, center).trim();
      const value = trimmedRawParameter.slice(center + 1).trim();
      parameters[name] = value;
    }
    parsed.push({
      reference,
      parameters
    });
  }
  return parsed;
}

// node_modules/got/dist/source/core/options.js
var [major2, minor] = import_node_process.default.versions.node.split(".").map(Number);
function validateSearchParameters(searchParameters) {
  for (const key in searchParameters) {
    const value = searchParameters[key];
    assert.any([dist_default.string, dist_default.number, dist_default.boolean, dist_default.null_, dist_default.undefined], value);
  }
}
var globalCache = /* @__PURE__ */ new Map();
var globalDnsCache;
var getGlobalDnsCache = () => {
  if (globalDnsCache) {
    return globalDnsCache;
  }
  globalDnsCache = new CacheableLookup();
  return globalDnsCache;
};
var defaultInternals = {
  request: void 0,
  agent: {
    http: void 0,
    https: void 0,
    http2: void 0
  },
  h2session: void 0,
  decompress: true,
  timeout: {
    connect: void 0,
    lookup: void 0,
    read: void 0,
    request: void 0,
    response: void 0,
    secureConnect: void 0,
    send: void 0,
    socket: void 0
  },
  prefixUrl: "",
  body: void 0,
  form: void 0,
  json: void 0,
  cookieJar: void 0,
  ignoreInvalidCookies: false,
  searchParams: void 0,
  dnsLookup: void 0,
  dnsCache: void 0,
  context: {},
  hooks: {
    init: [],
    beforeRequest: [],
    beforeError: [],
    beforeRedirect: [],
    beforeRetry: [],
    afterResponse: []
  },
  followRedirect: true,
  maxRedirects: 10,
  cache: void 0,
  throwHttpErrors: true,
  username: "",
  password: "",
  http2: false,
  allowGetBody: false,
  headers: {
    "user-agent": "got (https://github.com/sindresorhus/got)"
  },
  methodRewriting: false,
  dnsLookupIpVersion: void 0,
  parseJson: JSON.parse,
  stringifyJson: JSON.stringify,
  retry: {
    limit: 2,
    methods: [
      "GET",
      "PUT",
      "HEAD",
      "DELETE",
      "OPTIONS",
      "TRACE"
    ],
    statusCodes: [
      408,
      413,
      429,
      500,
      502,
      503,
      504,
      521,
      522,
      524
    ],
    errorCodes: [
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ECONNREFUSED",
      "EPIPE",
      "ENOTFOUND",
      "ENETUNREACH",
      "EAI_AGAIN"
    ],
    maxRetryAfter: void 0,
    calculateDelay: ({ computedValue }) => computedValue,
    backoffLimit: Number.POSITIVE_INFINITY,
    noise: 100
  },
  localAddress: void 0,
  method: "GET",
  createConnection: void 0,
  cacheOptions: {
    shared: void 0,
    cacheHeuristic: void 0,
    immutableMinTimeToLive: void 0,
    ignoreCargoCult: void 0
  },
  https: {
    alpnProtocols: void 0,
    rejectUnauthorized: void 0,
    checkServerIdentity: void 0,
    certificateAuthority: void 0,
    key: void 0,
    certificate: void 0,
    passphrase: void 0,
    pfx: void 0,
    ciphers: void 0,
    honorCipherOrder: void 0,
    minVersion: void 0,
    maxVersion: void 0,
    signatureAlgorithms: void 0,
    tlsSessionLifetime: void 0,
    dhparam: void 0,
    ecdhCurve: void 0,
    certificateRevocationLists: void 0
  },
  encoding: void 0,
  resolveBodyOnly: false,
  isStream: false,
  responseType: "text",
  url: void 0,
  pagination: {
    transform(response) {
      if (response.request.options.responseType === "json") {
        return response.body;
      }
      return JSON.parse(response.body);
    },
    paginate({ response }) {
      const rawLinkHeader = response.headers.link;
      if (typeof rawLinkHeader !== "string" || rawLinkHeader.trim() === "") {
        return false;
      }
      const parsed = parseLinkHeader(rawLinkHeader);
      const next = parsed.find((entry) => entry.parameters.rel === "next" || entry.parameters.rel === '"next"');
      if (next) {
        return {
          url: new import_node_url2.URL(next.reference, response.url)
        };
      }
      return false;
    },
    filter: () => true,
    shouldContinue: () => true,
    countLimit: Number.POSITIVE_INFINITY,
    backoff: 0,
    requestLimit: 1e4,
    stackAllItems: false
  },
  setHost: true,
  maxHeaderSize: void 0,
  signal: void 0,
  enableUnixSockets: true
};
var cloneInternals = (internals) => {
  const { hooks, retry } = internals;
  const result = {
    ...internals,
    context: { ...internals.context },
    cacheOptions: { ...internals.cacheOptions },
    https: { ...internals.https },
    agent: { ...internals.agent },
    headers: { ...internals.headers },
    retry: {
      ...retry,
      errorCodes: [...retry.errorCodes],
      methods: [...retry.methods],
      statusCodes: [...retry.statusCodes]
    },
    timeout: { ...internals.timeout },
    hooks: {
      init: [...hooks.init],
      beforeRequest: [...hooks.beforeRequest],
      beforeError: [...hooks.beforeError],
      beforeRedirect: [...hooks.beforeRedirect],
      beforeRetry: [...hooks.beforeRetry],
      afterResponse: [...hooks.afterResponse]
    },
    searchParams: internals.searchParams ? new import_node_url2.URLSearchParams(internals.searchParams) : void 0,
    pagination: { ...internals.pagination }
  };
  if (result.url !== void 0) {
    result.prefixUrl = "";
  }
  return result;
};
var cloneRaw = (raw2) => {
  const { hooks, retry } = raw2;
  const result = { ...raw2 };
  if (dist_default.object(raw2.context)) {
    result.context = { ...raw2.context };
  }
  if (dist_default.object(raw2.cacheOptions)) {
    result.cacheOptions = { ...raw2.cacheOptions };
  }
  if (dist_default.object(raw2.https)) {
    result.https = { ...raw2.https };
  }
  if (dist_default.object(raw2.cacheOptions)) {
    result.cacheOptions = { ...result.cacheOptions };
  }
  if (dist_default.object(raw2.agent)) {
    result.agent = { ...raw2.agent };
  }
  if (dist_default.object(raw2.headers)) {
    result.headers = { ...raw2.headers };
  }
  if (dist_default.object(retry)) {
    result.retry = { ...retry };
    if (dist_default.array(retry.errorCodes)) {
      result.retry.errorCodes = [...retry.errorCodes];
    }
    if (dist_default.array(retry.methods)) {
      result.retry.methods = [...retry.methods];
    }
    if (dist_default.array(retry.statusCodes)) {
      result.retry.statusCodes = [...retry.statusCodes];
    }
  }
  if (dist_default.object(raw2.timeout)) {
    result.timeout = { ...raw2.timeout };
  }
  if (dist_default.object(hooks)) {
    result.hooks = {
      ...hooks
    };
    if (dist_default.array(hooks.init)) {
      result.hooks.init = [...hooks.init];
    }
    if (dist_default.array(hooks.beforeRequest)) {
      result.hooks.beforeRequest = [...hooks.beforeRequest];
    }
    if (dist_default.array(hooks.beforeError)) {
      result.hooks.beforeError = [...hooks.beforeError];
    }
    if (dist_default.array(hooks.beforeRedirect)) {
      result.hooks.beforeRedirect = [...hooks.beforeRedirect];
    }
    if (dist_default.array(hooks.beforeRetry)) {
      result.hooks.beforeRetry = [...hooks.beforeRetry];
    }
    if (dist_default.array(hooks.afterResponse)) {
      result.hooks.afterResponse = [...hooks.afterResponse];
    }
  }
  if (dist_default.object(raw2.pagination)) {
    result.pagination = { ...raw2.pagination };
  }
  return result;
};
var getHttp2TimeoutOption = (internals) => {
  const delays = [internals.timeout.socket, internals.timeout.connect, internals.timeout.lookup, internals.timeout.request, internals.timeout.secureConnect].filter((delay2) => typeof delay2 === "number");
  if (delays.length > 0) {
    return Math.min(...delays);
  }
  return void 0;
};
var init = (options, withOptions, self2) => {
  const initHooks2 = options.hooks?.init;
  if (initHooks2) {
    for (const hook of initHooks2) {
      hook(withOptions, self2);
    }
  }
};
var Options = class {
  constructor(input, options, defaults3) {
    Object.defineProperty(this, "_unixOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_internals", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_merging", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_init", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    assert.any([dist_default.string, dist_default.urlInstance, dist_default.object, dist_default.undefined], input);
    assert.any([dist_default.object, dist_default.undefined], options);
    assert.any([dist_default.object, dist_default.undefined], defaults3);
    if (input instanceof Options || options instanceof Options) {
      throw new TypeError("The defaults must be passed as the third argument");
    }
    this._internals = cloneInternals(defaults3?._internals ?? defaults3 ?? defaultInternals);
    this._init = [...defaults3?._init ?? []];
    this._merging = false;
    this._unixOptions = void 0;
    try {
      if (dist_default.plainObject(input)) {
        try {
          this.merge(input);
          this.merge(options);
        } finally {
          this.url = input.url;
        }
      } else {
        try {
          this.merge(options);
        } finally {
          if (options?.url !== void 0) {
            if (input === void 0) {
              this.url = options.url;
            } else {
              throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
            }
          } else if (input !== void 0) {
            this.url = input;
          }
        }
      }
    } catch (error2) {
      error2.options = this;
      throw error2;
    }
  }
  merge(options) {
    if (!options) {
      return;
    }
    if (options instanceof Options) {
      for (const init2 of options._init) {
        this.merge(init2);
      }
      return;
    }
    options = cloneRaw(options);
    init(this, options, this);
    init(options, options, this);
    this._merging = true;
    if ("isStream" in options) {
      this.isStream = options.isStream;
    }
    try {
      let push = false;
      for (const key in options) {
        if (key === "mutableDefaults" || key === "handlers") {
          continue;
        }
        if (key === "url") {
          continue;
        }
        if (!(key in this)) {
          throw new Error(`Unexpected option: ${key}`);
        }
        this[key] = options[key];
        push = true;
      }
      if (push) {
        this._init.push(options);
      }
    } finally {
      this._merging = false;
    }
  }
  /**
      Custom request function.
      The main purpose of this is to [support HTTP2 using a wrapper](https://github.com/szmarczak/http2-wrapper).
  
      @default http.request | https.request
      */
  get request() {
    return this._internals.request;
  }
  set request(value) {
    assert.any([dist_default.function_, dist_default.undefined], value);
    this._internals.request = value;
  }
  /**
      An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
      This is necessary because a request to one protocol might redirect to another.
      In such a scenario, Got will switch over to the right protocol agent for you.
  
      If a key is not present, it will default to a global agent.
  
      @example
      ```
      import got from 'got';
      import HttpAgent from 'agentkeepalive';
  
      const {HttpsAgent} = HttpAgent;
  
      await got('https://sindresorhus.com', {
          agent: {
              http: new HttpAgent(),
              https: new HttpsAgent()
          }
      });
      ```
      */
  get agent() {
    return this._internals.agent;
  }
  set agent(value) {
    assert.plainObject(value);
    for (const key in value) {
      if (!(key in this._internals.agent)) {
        throw new TypeError(`Unexpected agent option: ${key}`);
      }
      assert.any([dist_default.object, dist_default.undefined], value[key]);
    }
    if (this._merging) {
      Object.assign(this._internals.agent, value);
    } else {
      this._internals.agent = { ...value };
    }
  }
  get h2session() {
    return this._internals.h2session;
  }
  set h2session(value) {
    this._internals.h2session = value;
  }
  /**
      Decompress the response automatically.
  
      This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.
  
      If this is disabled, a compressed response is returned as a `Buffer`.
      This may be useful if you want to handle decompression yourself or stream the raw compressed data.
  
      @default true
      */
  get decompress() {
    return this._internals.decompress;
  }
  set decompress(value) {
    assert.boolean(value);
    this._internals.decompress = value;
  }
  /**
      Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
      By default, there's no timeout.
  
      This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:
  
      - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
          Does not apply when using a Unix domain socket.
      - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
      - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
      - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
      - `response` starts when the request has been written to the socket and ends when the response headers are received.
      - `send` starts when the socket is connected and ends with the request has been written to the socket.
      - `request` starts when the request is initiated and ends when the response's end event fires.
      */
  get timeout() {
    return this._internals.timeout;
  }
  set timeout(value) {
    assert.plainObject(value);
    for (const key in value) {
      if (!(key in this._internals.timeout)) {
        throw new Error(`Unexpected timeout option: ${key}`);
      }
      assert.any([dist_default.number, dist_default.undefined], value[key]);
    }
    if (this._merging) {
      Object.assign(this._internals.timeout, value);
    } else {
      this._internals.timeout = { ...value };
    }
  }
  /**
      When specified, `prefixUrl` will be prepended to `url`.
      The prefix can be any valid URL, either relative or absolute.
      A trailing slash `/` is optional - one will be added automatically.
  
      __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.
  
      __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
      For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
      The latter is used by browsers.
  
      __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.
  
      __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
      If the URL doesn't include it anymore, it will throw.
  
      @example
      ```
      import got from 'got';
  
      await got('unicorn', {prefixUrl: 'https://cats.com'});
      //=> 'https://cats.com/unicorn'
  
      const instance = got.extend({
          prefixUrl: 'https://google.com'
      });
  
      await instance('unicorn', {
          hooks: {
              beforeRequest: [
                  options => {
                      options.prefixUrl = 'https://cats.com';
                  }
              ]
          }
      });
      //=> 'https://cats.com/unicorn'
      ```
      */
  get prefixUrl() {
    return this._internals.prefixUrl;
  }
  set prefixUrl(value) {
    assert.any([dist_default.string, dist_default.urlInstance], value);
    if (value === "") {
      this._internals.prefixUrl = "";
      return;
    }
    value = value.toString();
    if (!value.endsWith("/")) {
      value += "/";
    }
    if (this._internals.prefixUrl && this._internals.url) {
      const { href } = this._internals.url;
      this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
    }
    this._internals.prefixUrl = value;
  }
  /**
      __Note #1__: The `body` option cannot be used with the `json` or `form` option.
  
      __Note #2__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #3__: If you provide a payload with the `GET` or `HEAD` method, it will throw a `TypeError` unless the method is `GET` and the `allowGetBody` option is set to `true`.
  
      __Note #4__: This option is not enumerable and will not be merged with the instance defaults.
  
      The `content-length` header will be automatically set if `body` is a `string` / `Buffer` / [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) / [`form-data` instance](https://github.com/form-data/form-data), and `content-length` and `transfer-encoding` are not manually set in `options.headers`.
  
      Since Got 12, the `content-length` is not automatically set when `body` is a `fs.createReadStream`.
      */
  get body() {
    return this._internals.body;
  }
  set body(value) {
    assert.any([dist_default.string, dist_default.buffer, dist_default.nodeStream, dist_default.generator, dist_default.asyncGenerator, isFormData2, dist_default.undefined], value);
    if (dist_default.nodeStream(value)) {
      assert.truthy(value.readable);
    }
    if (value !== void 0) {
      assert.undefined(this._internals.form);
      assert.undefined(this._internals.json);
    }
    this._internals.body = value;
  }
  /**
      The form body is converted to a query string using [`(new URLSearchParams(object)).toString()`](https://nodejs.org/api/url.html#url_constructor_new_urlsearchparams_obj).
  
      If the `Content-Type` header is not present, it will be set to `application/x-www-form-urlencoded`.
  
      __Note #1__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
      */
  get form() {
    return this._internals.form;
  }
  set form(value) {
    assert.any([dist_default.plainObject, dist_default.undefined], value);
    if (value !== void 0) {
      assert.undefined(this._internals.body);
      assert.undefined(this._internals.json);
    }
    this._internals.form = value;
  }
  /**
      JSON body. If the `Content-Type` header is not set, it will be set to `application/json`.
  
      __Note #1__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
      */
  get json() {
    return this._internals.json;
  }
  set json(value) {
    if (value !== void 0) {
      assert.undefined(this._internals.body);
      assert.undefined(this._internals.form);
    }
    this._internals.json = value;
  }
  /**
      The URL to request, as a string, a [`https.request` options object](https://nodejs.org/api/https.html#https_https_request_options_callback), or a [WHATWG `URL`](https://nodejs.org/api/url.html#url_class_url).
  
      Properties from `options` will override properties in the parsed `url`.
  
      If no protocol is specified, it will throw a `TypeError`.
  
      __Note__: The query string is **not** parsed as search params.
  
      @example
      ```
      await got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b
      await got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
  
      // The query string is overridden by `searchParams`
      await got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
      ```
      */
  get url() {
    return this._internals.url;
  }
  set url(value) {
    assert.any([dist_default.string, dist_default.urlInstance, dist_default.undefined], value);
    if (value === void 0) {
      this._internals.url = void 0;
      return;
    }
    if (dist_default.string(value) && value.startsWith("/")) {
      throw new Error("`url` must not start with a slash");
    }
    const urlString = `${this.prefixUrl}${value.toString()}`;
    const url2 = new import_node_url2.URL(urlString);
    this._internals.url = url2;
    decodeURI(urlString);
    if (url2.protocol === "unix:") {
      url2.href = `http://unix${url2.pathname}${url2.search}`;
    }
    if (url2.protocol !== "http:" && url2.protocol !== "https:") {
      const error2 = new Error(`Unsupported protocol: ${url2.protocol}`);
      error2.code = "ERR_UNSUPPORTED_PROTOCOL";
      throw error2;
    }
    if (this._internals.username) {
      url2.username = this._internals.username;
      this._internals.username = "";
    }
    if (this._internals.password) {
      url2.password = this._internals.password;
      this._internals.password = "";
    }
    if (this._internals.searchParams) {
      url2.search = this._internals.searchParams.toString();
      this._internals.searchParams = void 0;
    }
    if (url2.hostname === "unix") {
      if (!this._internals.enableUnixSockets) {
        throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled");
      }
      const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url2.pathname}${url2.search}`);
      if (matches?.groups) {
        const { socketPath, path: path2 } = matches.groups;
        this._unixOptions = {
          socketPath,
          path: path2,
          host: ""
        };
      } else {
        this._unixOptions = void 0;
      }
      return;
    }
    this._unixOptions = void 0;
  }
  /**
      Cookie support. You don't have to care about parsing or how to store them.
  
      __Note__: If you provide this option, `options.headers.cookie` will be overridden.
      */
  get cookieJar() {
    return this._internals.cookieJar;
  }
  set cookieJar(value) {
    assert.any([dist_default.object, dist_default.undefined], value);
    if (value === void 0) {
      this._internals.cookieJar = void 0;
      return;
    }
    let { setCookie, getCookieString } = value;
    assert.function_(setCookie);
    assert.function_(getCookieString);
    if (setCookie.length === 4 && getCookieString.length === 0) {
      setCookie = (0, import_node_util3.promisify)(setCookie.bind(value));
      getCookieString = (0, import_node_util3.promisify)(getCookieString.bind(value));
      this._internals.cookieJar = {
        setCookie,
        getCookieString
      };
    } else {
      this._internals.cookieJar = value;
    }
  }
  /**
      You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
  
      *Requires Node.js 16 or later.*
  
      @example
      ```
      import got from 'got';
  
      const abortController = new AbortController();
  
      const request = got('https://httpbin.org/anything', {
          signal: abortController.signal
      });
  
      setTimeout(() => {
          abortController.abort();
      }, 100);
      ```
      */
  // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
  get signal() {
    return this._internals.signal;
  }
  // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
  set signal(value) {
    assert.object(value);
    this._internals.signal = value;
  }
  /**
      Ignore invalid cookies instead of throwing an error.
      Only useful when the `cookieJar` option has been set. Not recommended.
  
      @default false
      */
  get ignoreInvalidCookies() {
    return this._internals.ignoreInvalidCookies;
  }
  set ignoreInvalidCookies(value) {
    assert.boolean(value);
    this._internals.ignoreInvalidCookies = value;
  }
  /**
      Query string that will be added to the request URL.
      This will override the query string in `url`.
  
      If you need to pass in an array, you can do it using a `URLSearchParams` instance.
  
      @example
      ```
      import got from 'got';
  
      const searchParams = new URLSearchParams([['key', 'a'], ['key', 'b']]);
  
      await got('https://example.com', {searchParams});
  
      console.log(searchParams.toString());
      //=> 'key=a&key=b'
      ```
      */
  get searchParams() {
    if (this._internals.url) {
      return this._internals.url.searchParams;
    }
    if (this._internals.searchParams === void 0) {
      this._internals.searchParams = new import_node_url2.URLSearchParams();
    }
    return this._internals.searchParams;
  }
  set searchParams(value) {
    assert.any([dist_default.string, dist_default.object, dist_default.undefined], value);
    const url2 = this._internals.url;
    if (value === void 0) {
      this._internals.searchParams = void 0;
      if (url2) {
        url2.search = "";
      }
      return;
    }
    const searchParameters = this.searchParams;
    let updated;
    if (dist_default.string(value)) {
      updated = new import_node_url2.URLSearchParams(value);
    } else if (value instanceof import_node_url2.URLSearchParams) {
      updated = value;
    } else {
      validateSearchParameters(value);
      updated = new import_node_url2.URLSearchParams();
      for (const key in value) {
        const entry = value[key];
        if (entry === null) {
          updated.append(key, "");
        } else if (entry === void 0) {
          searchParameters.delete(key);
        } else {
          updated.append(key, entry);
        }
      }
    }
    if (this._merging) {
      for (const key of updated.keys()) {
        searchParameters.delete(key);
      }
      for (const [key, value2] of updated) {
        searchParameters.append(key, value2);
      }
    } else if (url2) {
      url2.search = searchParameters.toString();
    } else {
      this._internals.searchParams = searchParameters;
    }
  }
  get searchParameters() {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  set searchParameters(_value) {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  get dnsLookup() {
    return this._internals.dnsLookup;
  }
  set dnsLookup(value) {
    assert.any([dist_default.function_, dist_default.undefined], value);
    this._internals.dnsLookup = value;
  }
  /**
      An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
      Useful when making lots of requests to different *public* hostnames.
  
      `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.
  
      __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.
  
      @default false
      */
  get dnsCache() {
    return this._internals.dnsCache;
  }
  set dnsCache(value) {
    assert.any([dist_default.object, dist_default.boolean, dist_default.undefined], value);
    if (value === true) {
      this._internals.dnsCache = getGlobalDnsCache();
    } else if (value === false) {
      this._internals.dnsCache = void 0;
    } else {
      this._internals.dnsCache = value;
    }
  }
  /**
      User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.
  
      @example
      ```
      import got from 'got';
  
      const instance = got.extend({
          hooks: {
              beforeRequest: [
                  options => {
                      if (!options.context || !options.context.token) {
                          throw new Error('Token required');
                      }
  
                      options.headers.token = options.context.token;
                  }
              ]
          }
      });
  
      const context = {
          token: 'secret'
      };
  
      const response = await instance('https://httpbin.org/headers', {context});
  
      // Let's see the headers
      console.log(response.body);
      ```
      */
  get context() {
    return this._internals.context;
  }
  set context(value) {
    assert.object(value);
    if (this._merging) {
      Object.assign(this._internals.context, value);
    } else {
      this._internals.context = { ...value };
    }
  }
  /**
  Hooks allow modifications during the request lifecycle.
  Hook functions may be async and are run serially.
  */
  get hooks() {
    return this._internals.hooks;
  }
  set hooks(value) {
    assert.object(value);
    for (const knownHookEvent in value) {
      if (!(knownHookEvent in this._internals.hooks)) {
        throw new Error(`Unexpected hook event: ${knownHookEvent}`);
      }
      const typedKnownHookEvent = knownHookEvent;
      const hooks = value[typedKnownHookEvent];
      assert.any([dist_default.array, dist_default.undefined], hooks);
      if (hooks) {
        for (const hook of hooks) {
          assert.function_(hook);
        }
      }
      if (this._merging) {
        if (hooks) {
          this._internals.hooks[typedKnownHookEvent].push(...hooks);
        }
      } else {
        if (!hooks) {
          throw new Error(`Missing hook event: ${knownHookEvent}`);
        }
        this._internals.hooks[knownHookEvent] = [...hooks];
      }
    }
  }
  /**
      Defines if redirect responses should be followed automatically.
  
      Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
      This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.
  
      @default true
      */
  get followRedirect() {
    return this._internals.followRedirect;
  }
  set followRedirect(value) {
    assert.boolean(value);
    this._internals.followRedirect = value;
  }
  get followRedirects() {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  set followRedirects(_value) {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  /**
      If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.
  
      @default 10
      */
  get maxRedirects() {
    return this._internals.maxRedirects;
  }
  set maxRedirects(value) {
    assert.number(value);
    this._internals.maxRedirects = value;
  }
  /**
      A cache adapter instance for storing cached response data.
  
      @default false
      */
  get cache() {
    return this._internals.cache;
  }
  set cache(value) {
    assert.any([dist_default.object, dist_default.string, dist_default.boolean, dist_default.undefined], value);
    if (value === true) {
      this._internals.cache = globalCache;
    } else if (value === false) {
      this._internals.cache = void 0;
    } else {
      this._internals.cache = value;
    }
  }
  /**
      Determines if a `got.HTTPError` is thrown for unsuccessful responses.
  
      If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
      This may be useful if you are checking for resource availability and are expecting error responses.
  
      @default true
      */
  get throwHttpErrors() {
    return this._internals.throwHttpErrors;
  }
  set throwHttpErrors(value) {
    assert.boolean(value);
    this._internals.throwHttpErrors = value;
  }
  get username() {
    const url2 = this._internals.url;
    const value = url2 ? url2.username : this._internals.username;
    return decodeURIComponent(value);
  }
  set username(value) {
    assert.string(value);
    const url2 = this._internals.url;
    const fixedValue = encodeURIComponent(value);
    if (url2) {
      url2.username = fixedValue;
    } else {
      this._internals.username = fixedValue;
    }
  }
  get password() {
    const url2 = this._internals.url;
    const value = url2 ? url2.password : this._internals.password;
    return decodeURIComponent(value);
  }
  set password(value) {
    assert.string(value);
    const url2 = this._internals.url;
    const fixedValue = encodeURIComponent(value);
    if (url2) {
      url2.password = fixedValue;
    } else {
      this._internals.password = fixedValue;
    }
  }
  /**
      If set to `true`, Got will additionally accept HTTP2 requests.
  
      It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.
  
      __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.
  
      __Note__: Overriding `options.request` will disable HTTP2 support.
  
      @default false
  
      @example
      ```
      import got from 'got';
  
      const {headers} = await got('https://nghttp2.org/httpbin/anything', {http2: true});
  
      console.log(headers.via);
      //=> '2 nghttpx'
      ```
      */
  get http2() {
    return this._internals.http2;
  }
  set http2(value) {
    assert.boolean(value);
    this._internals.http2 = value;
  }
  /**
      Set this to `true` to allow sending body for the `GET` method.
      However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
      This option is only meant to interact with non-compliant servers when you have no other choice.
  
      __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.
  
      @default false
      */
  get allowGetBody() {
    return this._internals.allowGetBody;
  }
  set allowGetBody(value) {
    assert.boolean(value);
    this._internals.allowGetBody = value;
  }
  /**
      Request headers.
  
      Existing headers will be overwritten. Headers set to `undefined` will be omitted.
  
      @default {}
      */
  get headers() {
    return this._internals.headers;
  }
  set headers(value) {
    assert.plainObject(value);
    if (this._merging) {
      Object.assign(this._internals.headers, lowercaseKeys(value));
    } else {
      this._internals.headers = lowercaseKeys(value);
    }
  }
  /**
      Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.
  
      As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
      Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.
  
      __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).
  
      @default false
      */
  get methodRewriting() {
    return this._internals.methodRewriting;
  }
  set methodRewriting(value) {
    assert.boolean(value);
    this._internals.methodRewriting = value;
  }
  /**
      Indicates which DNS record family to use.
  
      Values:
      - `undefined`: IPv4 (if present) or IPv6
      - `4`: Only IPv4
      - `6`: Only IPv6
  
      @default undefined
      */
  get dnsLookupIpVersion() {
    return this._internals.dnsLookupIpVersion;
  }
  set dnsLookupIpVersion(value) {
    if (value !== void 0 && value !== 4 && value !== 6) {
      throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
    }
    this._internals.dnsLookupIpVersion = value;
  }
  /**
      A function used to parse JSON responses.
  
      @example
      ```
      import got from 'got';
      import Bourne from '@hapi/bourne';
  
      const parsed = await got('https://example.com', {
          parseJson: text => Bourne.parse(text)
      }).json();
  
      console.log(parsed);
      ```
      */
  get parseJson() {
    return this._internals.parseJson;
  }
  set parseJson(value) {
    assert.function_(value);
    this._internals.parseJson = value;
  }
  /**
      A function used to stringify the body of JSON requests.
  
      @example
      ```
      import got from 'got';
  
      await got.post('https://example.com', {
          stringifyJson: object => JSON.stringify(object, (key, value) => {
              if (key.startsWith('_')) {
                  return;
              }
  
              return value;
          }),
          json: {
              some: 'payload',
              _ignoreMe: 1234
          }
      });
      ```
  
      @example
      ```
      import got from 'got';
  
      await got.post('https://example.com', {
          stringifyJson: object => JSON.stringify(object, (key, value) => {
              if (typeof value === 'number') {
                  return value.toString();
              }
  
              return value;
          }),
          json: {
              some: 'payload',
              number: 1
          }
      });
      ```
      */
  get stringifyJson() {
    return this._internals.stringifyJson;
  }
  set stringifyJson(value) {
    assert.function_(value);
    this._internals.stringifyJson = value;
  }
  /**
      An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.
  
      Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).
  
      The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
      The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).
  
      By default, it retries *only* on the specified methods, status codes, and on these network errors:
  
      - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
      - `ECONNRESET`: Connection was forcibly closed by a peer.
      - `EADDRINUSE`: Could not bind to any free port.
      - `ECONNREFUSED`: Connection was refused by the server.
      - `EPIPE`: The remote side of the stream being written has been closed.
      - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
      - `ENETUNREACH`: No internet connection.
      - `EAI_AGAIN`: DNS lookup timed out.
  
      __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
      __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
      */
  get retry() {
    return this._internals.retry;
  }
  set retry(value) {
    assert.plainObject(value);
    assert.any([dist_default.function_, dist_default.undefined], value.calculateDelay);
    assert.any([dist_default.number, dist_default.undefined], value.maxRetryAfter);
    assert.any([dist_default.number, dist_default.undefined], value.limit);
    assert.any([dist_default.array, dist_default.undefined], value.methods);
    assert.any([dist_default.array, dist_default.undefined], value.statusCodes);
    assert.any([dist_default.array, dist_default.undefined], value.errorCodes);
    assert.any([dist_default.number, dist_default.undefined], value.noise);
    if (value.noise && Math.abs(value.noise) > 100) {
      throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${value.noise}`);
    }
    for (const key in value) {
      if (!(key in this._internals.retry)) {
        throw new Error(`Unexpected retry option: ${key}`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.retry, value);
    } else {
      this._internals.retry = { ...value };
    }
    const { retry } = this._internals;
    retry.methods = [...new Set(retry.methods.map((method) => method.toUpperCase()))];
    retry.statusCodes = [...new Set(retry.statusCodes)];
    retry.errorCodes = [...new Set(retry.errorCodes)];
  }
  /**
      From `http.RequestOptions`.
  
      The IP address used to send the request from.
      */
  get localAddress() {
    return this._internals.localAddress;
  }
  set localAddress(value) {
    assert.any([dist_default.string, dist_default.undefined], value);
    this._internals.localAddress = value;
  }
  /**
      The HTTP method used to make the request.
  
      @default 'GET'
      */
  get method() {
    return this._internals.method;
  }
  set method(value) {
    assert.string(value);
    this._internals.method = value.toUpperCase();
  }
  get createConnection() {
    return this._internals.createConnection;
  }
  set createConnection(value) {
    assert.any([dist_default.function_, dist_default.undefined], value);
    this._internals.createConnection = value;
  }
  /**
      From `http-cache-semantics`
  
      @default {}
      */
  get cacheOptions() {
    return this._internals.cacheOptions;
  }
  set cacheOptions(value) {
    assert.plainObject(value);
    assert.any([dist_default.boolean, dist_default.undefined], value.shared);
    assert.any([dist_default.number, dist_default.undefined], value.cacheHeuristic);
    assert.any([dist_default.number, dist_default.undefined], value.immutableMinTimeToLive);
    assert.any([dist_default.boolean, dist_default.undefined], value.ignoreCargoCult);
    for (const key in value) {
      if (!(key in this._internals.cacheOptions)) {
        throw new Error(`Cache option \`${key}\` does not exist`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.cacheOptions, value);
    } else {
      this._internals.cacheOptions = { ...value };
    }
  }
  /**
  Options for the advanced HTTPS API.
  */
  get https() {
    return this._internals.https;
  }
  set https(value) {
    assert.plainObject(value);
    assert.any([dist_default.boolean, dist_default.undefined], value.rejectUnauthorized);
    assert.any([dist_default.function_, dist_default.undefined], value.checkServerIdentity);
    assert.any([dist_default.string, dist_default.object, dist_default.array, dist_default.undefined], value.certificateAuthority);
    assert.any([dist_default.string, dist_default.object, dist_default.array, dist_default.undefined], value.key);
    assert.any([dist_default.string, dist_default.object, dist_default.array, dist_default.undefined], value.certificate);
    assert.any([dist_default.string, dist_default.undefined], value.passphrase);
    assert.any([dist_default.string, dist_default.buffer, dist_default.array, dist_default.undefined], value.pfx);
    assert.any([dist_default.array, dist_default.undefined], value.alpnProtocols);
    assert.any([dist_default.string, dist_default.undefined], value.ciphers);
    assert.any([dist_default.string, dist_default.buffer, dist_default.undefined], value.dhparam);
    assert.any([dist_default.string, dist_default.undefined], value.signatureAlgorithms);
    assert.any([dist_default.string, dist_default.undefined], value.minVersion);
    assert.any([dist_default.string, dist_default.undefined], value.maxVersion);
    assert.any([dist_default.boolean, dist_default.undefined], value.honorCipherOrder);
    assert.any([dist_default.number, dist_default.undefined], value.tlsSessionLifetime);
    assert.any([dist_default.string, dist_default.undefined], value.ecdhCurve);
    assert.any([dist_default.string, dist_default.buffer, dist_default.array, dist_default.undefined], value.certificateRevocationLists);
    for (const key in value) {
      if (!(key in this._internals.https)) {
        throw new Error(`HTTPS option \`${key}\` does not exist`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.https, value);
    } else {
      this._internals.https = { ...value };
    }
  }
  /**
      [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.
  
      To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
      Don't set this option to `null`.
  
      __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.
  
      @default 'utf-8'
      */
  get encoding() {
    return this._internals.encoding;
  }
  set encoding(value) {
    if (value === null) {
      throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
    }
    assert.any([dist_default.string, dist_default.undefined], value);
    this._internals.encoding = value;
  }
  /**
      When set to `true` the promise will return the Response body instead of the Response object.
  
      @default false
      */
  get resolveBodyOnly() {
    return this._internals.resolveBodyOnly;
  }
  set resolveBodyOnly(value) {
    assert.boolean(value);
    this._internals.resolveBodyOnly = value;
  }
  /**
      Returns a `Stream` instead of a `Promise`.
      This is equivalent to calling `got.stream(url, options?)`.
  
      @default false
      */
  get isStream() {
    return this._internals.isStream;
  }
  set isStream(value) {
    assert.boolean(value);
    this._internals.isStream = value;
  }
  /**
      The parsing method.
  
      The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.
  
      It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.
  
      __Note__: When using streams, this option is ignored.
  
      @example
      ```
      const responsePromise = got(url);
      const bufferPromise = responsePromise.buffer();
      const jsonPromise = responsePromise.json();
  
      const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
      // `response` is an instance of Got Response
      // `buffer` is an instance of Buffer
      // `json` is an object
      ```
  
      @example
      ```
      // This
      const body = await got(url).json();
  
      // is semantically the same as this
      const body = await got(url, {responseType: 'json', resolveBodyOnly: true});
      ```
      */
  get responseType() {
    return this._internals.responseType;
  }
  set responseType(value) {
    if (value === void 0) {
      this._internals.responseType = "text";
      return;
    }
    if (value !== "text" && value !== "buffer" && value !== "json") {
      throw new Error(`Invalid \`responseType\` option: ${value}`);
    }
    this._internals.responseType = value;
  }
  get pagination() {
    return this._internals.pagination;
  }
  set pagination(value) {
    assert.object(value);
    if (this._merging) {
      Object.assign(this._internals.pagination, value);
    } else {
      this._internals.pagination = value;
    }
  }
  get auth() {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  set auth(_value) {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  get setHost() {
    return this._internals.setHost;
  }
  set setHost(value) {
    assert.boolean(value);
    this._internals.setHost = value;
  }
  get maxHeaderSize() {
    return this._internals.maxHeaderSize;
  }
  set maxHeaderSize(value) {
    assert.any([dist_default.number, dist_default.undefined], value);
    this._internals.maxHeaderSize = value;
  }
  get enableUnixSockets() {
    return this._internals.enableUnixSockets;
  }
  set enableUnixSockets(value) {
    assert.boolean(value);
    this._internals.enableUnixSockets = value;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  toJSON() {
    return { ...this._internals };
  }
  [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
    return (0, import_node_util3.inspect)(this._internals, options);
  }
  createNativeRequestOptions() {
    const internals = this._internals;
    const url2 = internals.url;
    let agent;
    if (url2.protocol === "https:") {
      agent = internals.http2 ? internals.agent : internals.agent.https;
    } else {
      agent = internals.agent.http;
    }
    const { https: https3 } = internals;
    let { pfx } = https3;
    if (dist_default.array(pfx) && dist_default.plainObject(pfx[0])) {
      pfx = pfx.map((object) => ({
        buf: object.buffer,
        passphrase: object.passphrase
      }));
    }
    return {
      ...internals.cacheOptions,
      ...this._unixOptions,
      // HTTPS options
      // eslint-disable-next-line @typescript-eslint/naming-convention
      ALPNProtocols: https3.alpnProtocols,
      ca: https3.certificateAuthority,
      cert: https3.certificate,
      key: https3.key,
      passphrase: https3.passphrase,
      pfx: https3.pfx,
      rejectUnauthorized: https3.rejectUnauthorized,
      checkServerIdentity: https3.checkServerIdentity ?? import_node_tls.checkServerIdentity,
      ciphers: https3.ciphers,
      honorCipherOrder: https3.honorCipherOrder,
      minVersion: https3.minVersion,
      maxVersion: https3.maxVersion,
      sigalgs: https3.signatureAlgorithms,
      sessionTimeout: https3.tlsSessionLifetime,
      dhparam: https3.dhparam,
      ecdhCurve: https3.ecdhCurve,
      crl: https3.certificateRevocationLists,
      // HTTP options
      lookup: internals.dnsLookup ?? internals.dnsCache?.lookup,
      family: internals.dnsLookupIpVersion,
      agent,
      setHost: internals.setHost,
      method: internals.method,
      maxHeaderSize: internals.maxHeaderSize,
      localAddress: internals.localAddress,
      headers: internals.headers,
      createConnection: internals.createConnection,
      timeout: internals.http2 ? getHttp2TimeoutOption(internals) : void 0,
      // HTTP/2 options
      h2session: internals.h2session
    };
  }
  getRequestFunction() {
    const url2 = this._internals.url;
    const { request: request2 } = this._internals;
    if (!request2 && url2) {
      return this.getFallbackRequestFunction();
    }
    return request2;
  }
  getFallbackRequestFunction() {
    const url2 = this._internals.url;
    if (!url2) {
      return;
    }
    if (url2.protocol === "https:") {
      if (this._internals.http2) {
        if (major2 < 15 || major2 === 15 && minor < 10) {
          const error2 = new Error("To use the `http2` option, install Node.js 15.10.0 or above");
          error2.code = "EUNSUPPORTED";
          throw error2;
        }
        return import_http2_wrapper.default.auto;
      }
      return import_node_https.default.request;
    }
    return import_node_http.default.request;
  }
  freeze() {
    const options = this._internals;
    Object.freeze(options);
    Object.freeze(options.hooks);
    Object.freeze(options.hooks.afterResponse);
    Object.freeze(options.hooks.beforeError);
    Object.freeze(options.hooks.beforeRedirect);
    Object.freeze(options.hooks.beforeRequest);
    Object.freeze(options.hooks.beforeRetry);
    Object.freeze(options.hooks.init);
    Object.freeze(options.https);
    Object.freeze(options.cacheOptions);
    Object.freeze(options.agent);
    Object.freeze(options.headers);
    Object.freeze(options.timeout);
    Object.freeze(options.retry);
    Object.freeze(options.retry.errorCodes);
    Object.freeze(options.retry.methods);
    Object.freeze(options.retry.statusCodes);
  }
};

// node_modules/got/dist/source/core/response.js
var isResponseOk = (response) => {
  const { statusCode } = response;
  const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
  return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
};
var ParseError = class extends RequestError2 {
  constructor(error2, response) {
    const { options } = response.request;
    super(`${error2.message} in "${options.url.toString()}"`, error2, response.request);
    this.name = "ParseError";
    this.code = "ERR_BODY_PARSE_FAILURE";
  }
};
var parseBody = (response, responseType, parseJson, encoding) => {
  const { rawBody } = response;
  try {
    if (responseType === "text") {
      return rawBody.toString(encoding);
    }
    if (responseType === "json") {
      return rawBody.length === 0 ? "" : parseJson(rawBody.toString(encoding));
    }
    if (responseType === "buffer") {
      return rawBody;
    }
  } catch (error2) {
    throw new ParseError(error2, response);
  }
  throw new ParseError({
    message: `Unknown body type '${responseType}'`,
    name: "Error"
  }, response);
};

// node_modules/got/dist/source/core/utils/is-client-request.js
function isClientRequest(clientRequest) {
  return clientRequest.writable && !clientRequest.writableEnded;
}
var is_client_request_default = isClientRequest;

// node_modules/got/dist/source/core/utils/is-unix-socket-url.js
function isUnixSocketURL(url2) {
  return url2.protocol === "unix:" || url2.hostname === "unix";
}

// node_modules/got/dist/source/core/index.js
var supportsBrotli = dist_default.string(import_node_process2.default.versions.brotli);
var methodsWithoutBody = /* @__PURE__ */ new Set(["GET", "HEAD"]);
var cacheableStore = new WeakableMap();
var redirectCodes = /* @__PURE__ */ new Set([300, 301, 302, 303, 304, 307, 308]);
var proxiedRequestEvents = [
  "socket",
  "connect",
  "continue",
  "information",
  "upgrade"
];
var noop3 = () => {
};
var Request = class extends import_node_stream3.Duplex {
  constructor(url2, options, defaults3) {
    super({
      // Don't destroy immediately, as the error may be emitted on unsuccessful retry
      autoDestroy: false,
      // It needs to be zero because we're just proxying the data to another stream
      highWaterMark: 0
    });
    Object.defineProperty(this, "constructor", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_noPipe", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "response", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "requestUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "redirectUrls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "retryCount", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_stopRetry", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_downloadedSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_uploadedSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_stopReading", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_pipedServerResponses", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_request", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_responseSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_bodySize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_unproxyEvents", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_isFromCache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_cannotHaveBody", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_triggerRead", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_cancelTimeouts", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_removeListeners", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_nativeResponse", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_flushed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_aborted", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_requestInitialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this._downloadedSize = 0;
    this._uploadedSize = 0;
    this._stopReading = false;
    this._pipedServerResponses = /* @__PURE__ */ new Set();
    this._cannotHaveBody = false;
    this._unproxyEvents = noop3;
    this._triggerRead = false;
    this._cancelTimeouts = noop3;
    this._removeListeners = noop3;
    this._jobs = [];
    this._flushed = false;
    this._requestInitialized = false;
    this._aborted = false;
    this.redirectUrls = [];
    this.retryCount = 0;
    this._stopRetry = noop3;
    this.on("pipe", (source) => {
      if (source.headers) {
        Object.assign(this.options.headers, source.headers);
      }
    });
    this.on("newListener", (event) => {
      if (event === "retry" && this.listenerCount("retry") > 0) {
        throw new Error("A retry listener has been attached already.");
      }
    });
    try {
      this.options = new Options(url2, options, defaults3);
      if (!this.options.url) {
        if (this.options.prefixUrl === "") {
          throw new TypeError("Missing `url` property");
        }
        this.options.url = "";
      }
      this.requestUrl = this.options.url;
    } catch (error2) {
      const { options: options2 } = error2;
      if (options2) {
        this.options = options2;
      }
      this.flush = async () => {
        this.flush = async () => {
        };
        this.destroy(error2);
      };
      return;
    }
    const { body } = this.options;
    if (dist_default.nodeStream(body)) {
      body.once("error", (error2) => {
        if (this._flushed) {
          this._beforeError(new UploadError(error2, this));
        } else {
          this.flush = async () => {
            this.flush = async () => {
            };
            this._beforeError(new UploadError(error2, this));
          };
        }
      });
    }
    if (this.options.signal) {
      const abort = () => {
        this.destroy(new AbortError(this));
      };
      if (this.options.signal.aborted) {
        abort();
      } else {
        this.options.signal.addEventListener("abort", abort);
        this._removeListeners = () => {
          this.options.signal.removeEventListener("abort", abort);
        };
      }
    }
  }
  async flush() {
    if (this._flushed) {
      return;
    }
    this._flushed = true;
    try {
      await this._finalizeBody();
      if (this.destroyed) {
        return;
      }
      await this._makeRequest();
      if (this.destroyed) {
        this._request?.destroy();
        return;
      }
      for (const job of this._jobs) {
        job();
      }
      this._jobs.length = 0;
      this._requestInitialized = true;
    } catch (error2) {
      this._beforeError(error2);
    }
  }
  _beforeError(error2) {
    if (this._stopReading) {
      return;
    }
    const { response, options } = this;
    const attemptCount = this.retryCount + (error2.name === "RetryError" ? 0 : 1);
    this._stopReading = true;
    if (!(error2 instanceof RequestError2)) {
      error2 = new RequestError2(error2.message, error2, this);
    }
    const typedError = error2;
    void (async () => {
      if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {
        response.setEncoding(this.readableEncoding);
        const success = await this._setRawBody(response);
        if (success) {
          response.body = response.rawBody.toString();
        }
      }
      if (this.listenerCount("retry") !== 0) {
        let backoff;
        try {
          let retryAfter;
          if (response && "retry-after" in response.headers) {
            retryAfter = Number(response.headers["retry-after"]);
            if (Number.isNaN(retryAfter)) {
              retryAfter = Date.parse(response.headers["retry-after"]) - Date.now();
              if (retryAfter <= 0) {
                retryAfter = 1;
              }
            } else {
              retryAfter *= 1e3;
            }
          }
          const retryOptions = options.retry;
          backoff = await retryOptions.calculateDelay({
            attemptCount,
            retryOptions,
            error: typedError,
            retryAfter,
            computedValue: calculate_retry_delay_default({
              attemptCount,
              retryOptions,
              error: typedError,
              retryAfter,
              computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY
            })
          });
        } catch (error_) {
          void this._error(new RequestError2(error_.message, error_, this));
          return;
        }
        if (backoff) {
          await new Promise((resolve) => {
            const timeout = setTimeout(resolve, backoff);
            this._stopRetry = () => {
              clearTimeout(timeout);
              resolve();
            };
          });
          if (this.destroyed) {
            return;
          }
          try {
            for (const hook of this.options.hooks.beforeRetry) {
              await hook(typedError, this.retryCount + 1);
            }
          } catch (error_) {
            void this._error(new RequestError2(error_.message, error2, this));
            return;
          }
          if (this.destroyed) {
            return;
          }
          this.destroy();
          this.emit("retry", this.retryCount + 1, error2, (updatedOptions) => {
            const request2 = new Request(options.url, updatedOptions, options);
            request2.retryCount = this.retryCount + 1;
            import_node_process2.default.nextTick(() => {
              void request2.flush();
            });
            return request2;
          });
          return;
        }
      }
      void this._error(typedError);
    })();
  }
  _read() {
    this._triggerRead = true;
    const { response } = this;
    if (response && !this._stopReading) {
      if (response.readableLength) {
        this._triggerRead = false;
      }
      let data;
      while ((data = response.read()) !== null) {
        this._downloadedSize += data.length;
        const progress = this.downloadProgress;
        if (progress.percent < 1) {
          this.emit("downloadProgress", progress);
        }
        this.push(data);
      }
    }
  }
  _write(chunk, encoding, callback) {
    const write = () => {
      this._writeRequest(chunk, encoding, callback);
    };
    if (this._requestInitialized) {
      write();
    } else {
      this._jobs.push(write);
    }
  }
  _final(callback) {
    const endRequest = () => {
      if (!this._request || this._request.destroyed) {
        callback();
        return;
      }
      this._request.end((error2) => {
        if (this._request._writableState?.errored) {
          return;
        }
        if (!error2) {
          this._bodySize = this._uploadedSize;
          this.emit("uploadProgress", this.uploadProgress);
          this._request.emit("upload-complete");
        }
        callback(error2);
      });
    };
    if (this._requestInitialized) {
      endRequest();
    } else {
      this._jobs.push(endRequest);
    }
  }
  _destroy(error2, callback) {
    this._stopReading = true;
    this.flush = async () => {
    };
    this._stopRetry();
    this._cancelTimeouts();
    this._removeListeners();
    if (this.options) {
      const { body } = this.options;
      if (dist_default.nodeStream(body)) {
        body.destroy();
      }
    }
    if (this._request) {
      this._request.destroy();
    }
    if (error2 !== null && !dist_default.undefined(error2) && !(error2 instanceof RequestError2)) {
      error2 = new RequestError2(error2.message, error2, this);
    }
    callback(error2);
  }
  pipe(destination, options) {
    if (destination instanceof import_node_http2.ServerResponse) {
      this._pipedServerResponses.add(destination);
    }
    return super.pipe(destination, options);
  }
  unpipe(destination) {
    if (destination instanceof import_node_http2.ServerResponse) {
      this._pipedServerResponses.delete(destination);
    }
    super.unpipe(destination);
    return this;
  }
  async _finalizeBody() {
    const { options } = this;
    const { headers } = options;
    const isForm = !dist_default.undefined(options.form);
    const isJSON = !dist_default.undefined(options.json);
    const isBody = !dist_default.undefined(options.body);
    const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
    this._cannotHaveBody = cannotHaveBody;
    if (isForm || isJSON || isBody) {
      if (cannotHaveBody) {
        throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
      }
      const noContentType = !dist_default.string(headers["content-type"]);
      if (isBody) {
        if (isFormData2(options.body)) {
          const encoder = new FormDataEncoder(options.body);
          if (noContentType) {
            headers["content-type"] = encoder.headers["Content-Type"];
          }
          if ("Content-Length" in encoder.headers) {
            headers["content-length"] = encoder.headers["Content-Length"];
          }
          options.body = encoder.encode();
        }
        if (isFormData3(options.body) && noContentType) {
          headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
        }
      } else if (isForm) {
        if (noContentType) {
          headers["content-type"] = "application/x-www-form-urlencoded";
        }
        const { form } = options;
        options.form = void 0;
        options.body = new import_node_url3.URLSearchParams(form).toString();
      } else {
        if (noContentType) {
          headers["content-type"] = "application/json";
        }
        const { json } = options;
        options.json = void 0;
        options.body = options.stringifyJson(json);
      }
      const uploadBodySize = await getBodySize(options.body, options.headers);
      if (dist_default.undefined(headers["content-length"]) && dist_default.undefined(headers["transfer-encoding"]) && !cannotHaveBody && !dist_default.undefined(uploadBodySize)) {
        headers["content-length"] = String(uploadBodySize);
      }
    }
    if (options.responseType === "json" && !("accept" in options.headers)) {
      options.headers.accept = "application/json";
    }
    this._bodySize = Number(headers["content-length"]) || void 0;
  }
  async _onResponseBase(response) {
    if (this.isAborted) {
      return;
    }
    const { options } = this;
    const { url: url2 } = options;
    this._nativeResponse = response;
    if (options.decompress) {
      response = (0, import_decompress_response.default)(response);
    }
    const statusCode = response.statusCode;
    const typedResponse = response;
    typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : import_node_http2.default.STATUS_CODES[statusCode];
    typedResponse.url = options.url.toString();
    typedResponse.requestUrl = this.requestUrl;
    typedResponse.redirectUrls = this.redirectUrls;
    typedResponse.request = this;
    typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;
    typedResponse.ip = this.ip;
    typedResponse.retryCount = this.retryCount;
    typedResponse.ok = isResponseOk(typedResponse);
    this._isFromCache = typedResponse.isFromCache;
    this._responseSize = Number(response.headers["content-length"]) || void 0;
    this.response = typedResponse;
    response.once("end", () => {
      this._responseSize = this._downloadedSize;
      this.emit("downloadProgress", this.downloadProgress);
    });
    response.once("error", (error2) => {
      this._aborted = true;
      response.destroy();
      this._beforeError(new ReadError(error2, this));
    });
    response.once("aborted", () => {
      this._aborted = true;
      this._beforeError(new ReadError({
        name: "Error",
        message: "The server aborted pending request",
        code: "ECONNRESET"
      }, this));
    });
    this.emit("downloadProgress", this.downloadProgress);
    const rawCookies = response.headers["set-cookie"];
    if (dist_default.object(options.cookieJar) && rawCookies) {
      let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url2.toString()));
      if (options.ignoreInvalidCookies) {
        promises = promises.map(async (promise) => {
          try {
            await promise;
          } catch {
          }
        });
      }
      try {
        await Promise.all(promises);
      } catch (error2) {
        this._beforeError(error2);
        return;
      }
    }
    if (this.isAborted) {
      return;
    }
    if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
      response.resume();
      this._cancelTimeouts();
      this._unproxyEvents();
      if (this.redirectUrls.length >= options.maxRedirects) {
        this._beforeError(new MaxRedirectsError(this));
        return;
      }
      this._request = void 0;
      const updatedOptions = new Options(void 0, void 0, this.options);
      const serverRequestedGet = statusCode === 303 && updatedOptions.method !== "GET" && updatedOptions.method !== "HEAD";
      const canRewrite = statusCode !== 307 && statusCode !== 308;
      const userRequestedGet = updatedOptions.methodRewriting && canRewrite;
      if (serverRequestedGet || userRequestedGet) {
        updatedOptions.method = "GET";
        updatedOptions.body = void 0;
        updatedOptions.json = void 0;
        updatedOptions.form = void 0;
        delete updatedOptions.headers["content-length"];
      }
      try {
        const redirectBuffer = import_node_buffer2.Buffer.from(response.headers.location, "binary").toString();
        const redirectUrl = new import_node_url3.URL(redirectBuffer, url2);
        if (!isUnixSocketURL(url2) && isUnixSocketURL(redirectUrl)) {
          this._beforeError(new RequestError2("Cannot redirect to UNIX socket", {}, this));
          return;
        }
        if (redirectUrl.hostname !== url2.hostname || redirectUrl.port !== url2.port) {
          if ("host" in updatedOptions.headers) {
            delete updatedOptions.headers.host;
          }
          if ("cookie" in updatedOptions.headers) {
            delete updatedOptions.headers.cookie;
          }
          if ("authorization" in updatedOptions.headers) {
            delete updatedOptions.headers.authorization;
          }
          if (updatedOptions.username || updatedOptions.password) {
            updatedOptions.username = "";
            updatedOptions.password = "";
          }
        } else {
          redirectUrl.username = updatedOptions.username;
          redirectUrl.password = updatedOptions.password;
        }
        this.redirectUrls.push(redirectUrl);
        updatedOptions.prefixUrl = "";
        updatedOptions.url = redirectUrl;
        for (const hook of updatedOptions.hooks.beforeRedirect) {
          await hook(updatedOptions, typedResponse);
        }
        this.emit("redirect", updatedOptions, typedResponse);
        this.options = updatedOptions;
        await this._makeRequest();
      } catch (error2) {
        this._beforeError(error2);
        return;
      }
      return;
    }
    if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {
      this._beforeError(new HTTPError(typedResponse));
      return;
    }
    response.on("readable", () => {
      if (this._triggerRead) {
        this._read();
      }
    });
    this.on("resume", () => {
      response.resume();
    });
    this.on("pause", () => {
      response.pause();
    });
    response.once("end", () => {
      this.push(null);
    });
    if (this._noPipe) {
      const success = await this._setRawBody();
      if (success) {
        this.emit("response", response);
      }
      return;
    }
    this.emit("response", response);
    for (const destination of this._pipedServerResponses) {
      if (destination.headersSent) {
        continue;
      }
      for (const key in response.headers) {
        const isAllowed = options.decompress ? key !== "content-encoding" : true;
        const value = response.headers[key];
        if (isAllowed) {
          destination.setHeader(key, value);
        }
      }
      destination.statusCode = statusCode;
    }
  }
  async _setRawBody(from = this) {
    if (from.readableEnded) {
      return false;
    }
    try {
      const rawBody = await (0, import_get_stream3.buffer)(from);
      if (!this.isAborted) {
        this.response.rawBody = rawBody;
        return true;
      }
    } catch {
    }
    return false;
  }
  async _onResponse(response) {
    try {
      await this._onResponseBase(response);
    } catch (error2) {
      this._beforeError(error2);
    }
  }
  _onRequest(request2) {
    const { options } = this;
    const { timeout, url: url2 } = options;
    source_default(request2);
    if (this.options.http2) {
      request2.setTimeout(0);
    }
    this._cancelTimeouts = timedOut(request2, timeout, url2);
    const responseEventName = options.cache ? "cacheableResponse" : "response";
    request2.once(responseEventName, (response) => {
      void this._onResponse(response);
    });
    request2.once("error", (error2) => {
      this._aborted = true;
      request2.destroy();
      error2 = error2 instanceof TimeoutError2 ? new TimeoutError(error2, this.timings, this) : new RequestError2(error2.message, error2, this);
      this._beforeError(error2);
    });
    this._unproxyEvents = proxyEvents(request2, this, proxiedRequestEvents);
    this._request = request2;
    this.emit("uploadProgress", this.uploadProgress);
    this._sendBody();
    this.emit("request", request2);
  }
  async _asyncWrite(chunk) {
    return new Promise((resolve, reject) => {
      super.write(chunk, (error2) => {
        if (error2) {
          reject(error2);
          return;
        }
        resolve();
      });
    });
  }
  _sendBody() {
    const { body } = this.options;
    const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
    if (dist_default.nodeStream(body)) {
      body.pipe(currentRequest);
    } else if (dist_default.generator(body) || dist_default.asyncGenerator(body)) {
      (async () => {
        try {
          for await (const chunk of body) {
            await this._asyncWrite(chunk);
          }
          super.end();
        } catch (error2) {
          this._beforeError(error2);
        }
      })();
    } else if (!dist_default.undefined(body)) {
      this._writeRequest(body, void 0, () => {
      });
      currentRequest.end();
    } else if (this._cannotHaveBody || this._noPipe) {
      currentRequest.end();
    }
  }
  _prepareCache(cache) {
    if (!cacheableStore.has(cache)) {
      const cacheableRequest = new dist_default2((requestOptions, handler) => {
        const result = requestOptions._request(requestOptions, handler);
        if (dist_default.promise(result)) {
          result.once = (event, handler2) => {
            if (event === "error") {
              (async () => {
                try {
                  await result;
                } catch (error2) {
                  handler2(error2);
                }
              })();
            } else if (event === "abort") {
              (async () => {
                try {
                  const request2 = await result;
                  request2.once("abort", handler2);
                } catch {
                }
              })();
            } else {
              throw new Error(`Unknown HTTP2 promise event: ${event}`);
            }
            return result;
          };
        }
        return result;
      }, cache);
      cacheableStore.set(cache, cacheableRequest.request());
    }
  }
  async _createCacheableRequest(url2, options) {
    return new Promise((resolve, reject) => {
      Object.assign(options, urlToOptions(url2));
      let request2;
      const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
        response._readableState.autoDestroy = false;
        if (request2) {
          const fix = () => {
            if (response.req) {
              response.complete = response.req.res.complete;
            }
          };
          response.prependOnceListener("end", fix);
          fix();
          (await request2).emit("cacheableResponse", response);
        }
        resolve(response);
      });
      cacheRequest.once("error", reject);
      cacheRequest.once("request", async (requestOrPromise) => {
        request2 = requestOrPromise;
        resolve(request2);
      });
    });
  }
  async _makeRequest() {
    const { options } = this;
    const { headers, username, password } = options;
    const cookieJar = options.cookieJar;
    for (const key in headers) {
      if (dist_default.undefined(headers[key])) {
        delete headers[key];
      } else if (dist_default.null_(headers[key])) {
        throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
      }
    }
    if (options.decompress && dist_default.undefined(headers["accept-encoding"])) {
      headers["accept-encoding"] = supportsBrotli ? "gzip, deflate, br" : "gzip, deflate";
    }
    if (username || password) {
      const credentials = import_node_buffer2.Buffer.from(`${username}:${password}`).toString("base64");
      headers.authorization = `Basic ${credentials}`;
    }
    if (cookieJar) {
      const cookieString = await cookieJar.getCookieString(options.url.toString());
      if (dist_default.nonEmptyString(cookieString)) {
        headers.cookie = cookieString;
      }
    }
    options.prefixUrl = "";
    let request2;
    for (const hook of options.hooks.beforeRequest) {
      const result = await hook(options);
      if (!dist_default.undefined(result)) {
        request2 = () => result;
        break;
      }
    }
    if (!request2) {
      request2 = options.getRequestFunction();
    }
    const url2 = options.url;
    this._requestOptions = options.createNativeRequestOptions();
    if (options.cache) {
      this._requestOptions._request = request2;
      this._requestOptions.cache = options.cache;
      this._requestOptions.body = options.body;
      this._prepareCache(options.cache);
    }
    const fn = options.cache ? this._createCacheableRequest : request2;
    try {
      let requestOrResponse = fn(url2, this._requestOptions);
      if (dist_default.promise(requestOrResponse)) {
        requestOrResponse = await requestOrResponse;
      }
      if (dist_default.undefined(requestOrResponse)) {
        requestOrResponse = options.getFallbackRequestFunction()(url2, this._requestOptions);
        if (dist_default.promise(requestOrResponse)) {
          requestOrResponse = await requestOrResponse;
        }
      }
      if (is_client_request_default(requestOrResponse)) {
        this._onRequest(requestOrResponse);
      } else if (this.writable) {
        this.once("finish", () => {
          void this._onResponse(requestOrResponse);
        });
        this._sendBody();
      } else {
        void this._onResponse(requestOrResponse);
      }
    } catch (error2) {
      if (error2 instanceof CacheError2) {
        throw new CacheError(error2, this);
      }
      throw error2;
    }
  }
  async _error(error2) {
    try {
      if (error2 instanceof HTTPError && !this.options.throwHttpErrors) {
      } else {
        for (const hook of this.options.hooks.beforeError) {
          error2 = await hook(error2);
        }
      }
    } catch (error_) {
      error2 = new RequestError2(error_.message, error_, this);
    }
    this.destroy(error2);
  }
  _writeRequest(chunk, encoding, callback) {
    if (!this._request || this._request.destroyed) {
      return;
    }
    this._request.write(chunk, encoding, (error2) => {
      if (!error2 && !this._request.destroyed) {
        this._uploadedSize += import_node_buffer2.Buffer.byteLength(chunk, encoding);
        const progress = this.uploadProgress;
        if (progress.percent < 1) {
          this.emit("uploadProgress", progress);
        }
      }
      callback(error2);
    });
  }
  /**
  The remote IP address.
  */
  get ip() {
    return this.socket?.remoteAddress;
  }
  /**
  Indicates whether the request has been aborted or not.
  */
  get isAborted() {
    return this._aborted;
  }
  get socket() {
    return this._request?.socket ?? void 0;
  }
  /**
  Progress event for downloading (receiving a response).
  */
  get downloadProgress() {
    let percent;
    if (this._responseSize) {
      percent = this._downloadedSize / this._responseSize;
    } else if (this._responseSize === this._downloadedSize) {
      percent = 1;
    } else {
      percent = 0;
    }
    return {
      percent,
      transferred: this._downloadedSize,
      total: this._responseSize
    };
  }
  /**
  Progress event for uploading (sending a request).
  */
  get uploadProgress() {
    let percent;
    if (this._bodySize) {
      percent = this._uploadedSize / this._bodySize;
    } else if (this._bodySize === this._uploadedSize) {
      percent = 1;
    } else {
      percent = 0;
    }
    return {
      percent,
      transferred: this._uploadedSize,
      total: this._bodySize
    };
  }
  /**
      The object contains the following properties:
  
      - `start` - Time when the request started.
      - `socket` - Time when a socket was assigned to the request.
      - `lookup` - Time when the DNS lookup finished.
      - `connect` - Time when the socket successfully connected.
      - `secureConnect` - Time when the socket securely connected.
      - `upload` - Time when the request finished uploading.
      - `response` - Time when the request fired `response` event.
      - `end` - Time when the response fired `end` event.
      - `error` - Time when the request fired `error` event.
      - `abort` - Time when the request fired `abort` event.
      - `phases`
          - `wait` - `timings.socket - timings.start`
          - `dns` - `timings.lookup - timings.socket`
          - `tcp` - `timings.connect - timings.lookup`
          - `tls` - `timings.secureConnect - timings.connect`
          - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
          - `firstByte` - `timings.response - timings.upload`
          - `download` - `timings.end - timings.response`
          - `total` - `(timings.end || timings.error || timings.abort) - timings.start`
  
      If something has not been measured yet, it will be `undefined`.
  
      __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
      */
  get timings() {
    return this._request?.timings;
  }
  /**
  Whether the response was retrieved from the cache.
  */
  get isFromCache() {
    return this._isFromCache;
  }
  get reusedSocket() {
    return this._request?.reusedSocket;
  }
};

// node_modules/got/dist/source/as-promise/types.js
var CancelError2 = class extends RequestError2 {
  constructor(request2) {
    super("Promise was canceled", {}, request2);
    this.name = "CancelError";
    this.code = "ERR_CANCELED";
  }
  /**
  Whether the promise is canceled.
  */
  get isCanceled() {
    return true;
  }
};

// node_modules/got/dist/source/as-promise/index.js
var proxiedRequestEvents2 = [
  "request",
  "response",
  "redirect",
  "uploadProgress",
  "downloadProgress"
];
function asPromise(firstRequest) {
  let globalRequest;
  let globalResponse;
  let normalizedOptions;
  const emitter = new import_node_events2.EventEmitter();
  const promise = new PCancelable((resolve, reject, onCancel) => {
    onCancel(() => {
      globalRequest.destroy();
    });
    onCancel.shouldReject = false;
    onCancel(() => {
      reject(new CancelError2(globalRequest));
    });
    const makeRequest = (retryCount) => {
      onCancel(() => {
      });
      const request2 = firstRequest ?? new Request(void 0, void 0, normalizedOptions);
      request2.retryCount = retryCount;
      request2._noPipe = true;
      globalRequest = request2;
      request2.once("response", async (response) => {
        const contentEncoding = (response.headers["content-encoding"] ?? "").toLowerCase();
        const isCompressed = contentEncoding === "gzip" || contentEncoding === "deflate" || contentEncoding === "br";
        const { options } = request2;
        if (isCompressed && !options.decompress) {
          response.body = response.rawBody;
        } else {
          try {
            response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);
          } catch (error2) {
            response.body = response.rawBody.toString();
            if (isResponseOk(response)) {
              request2._beforeError(error2);
              return;
            }
          }
        }
        try {
          const hooks = options.hooks.afterResponse;
          for (const [index, hook] of hooks.entries()) {
            response = await hook(response, async (updatedOptions) => {
              options.merge(updatedOptions);
              options.prefixUrl = "";
              if (updatedOptions.url) {
                options.url = updatedOptions.url;
              }
              options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);
              throw new RetryError(request2);
            });
            if (!(dist_default.object(response) && dist_default.number(response.statusCode) && !dist_default.nullOrUndefined(response.body))) {
              throw new TypeError("The `afterResponse` hook returned an invalid value");
            }
          }
        } catch (error2) {
          request2._beforeError(error2);
          return;
        }
        globalResponse = response;
        if (!isResponseOk(response)) {
          request2._beforeError(new HTTPError(response));
          return;
        }
        request2.destroy();
        resolve(request2.options.resolveBodyOnly ? response.body : response);
      });
      const onError = (error2) => {
        if (promise.isCanceled) {
          return;
        }
        const { options } = request2;
        if (error2 instanceof HTTPError && !options.throwHttpErrors) {
          const { response } = error2;
          request2.destroy();
          resolve(request2.options.resolveBodyOnly ? response.body : response);
          return;
        }
        reject(error2);
      };
      request2.once("error", onError);
      const previousBody = request2.options?.body;
      request2.once("retry", (newRetryCount, error2) => {
        firstRequest = void 0;
        const newBody = request2.options.body;
        if (previousBody === newBody && dist_default.nodeStream(newBody)) {
          error2.message = "Cannot retry with consumed body stream";
          onError(error2);
          return;
        }
        normalizedOptions = request2.options;
        makeRequest(newRetryCount);
      });
      proxyEvents(request2, emitter, proxiedRequestEvents2);
      if (dist_default.undefined(firstRequest)) {
        void request2.flush();
      }
    };
    makeRequest(0);
  });
  promise.on = (event, fn) => {
    emitter.on(event, fn);
    return promise;
  };
  promise.off = (event, fn) => {
    emitter.off(event, fn);
    return promise;
  };
  const shortcut = (responseType) => {
    const newPromise = (async () => {
      await promise;
      const { options } = globalResponse.request;
      return parseBody(globalResponse, responseType, options.parseJson, options.encoding);
    })();
    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
    return newPromise;
  };
  promise.json = () => {
    if (globalRequest.options) {
      const { headers } = globalRequest.options;
      if (!globalRequest.writableFinished && !("accept" in headers)) {
        headers.accept = "application/json";
      }
    }
    return shortcut("json");
  };
  promise.buffer = () => shortcut("buffer");
  promise.text = () => shortcut("text");
  return promise;
}

// node_modules/got/dist/source/create.js
var delay = async (ms) => new Promise((resolve) => {
  setTimeout(resolve, ms);
});
var isGotInstance = (value) => dist_default.function_(value);
var aliases = [
  "get",
  "post",
  "put",
  "patch",
  "head",
  "delete"
];
var create = (defaults3) => {
  defaults3 = {
    options: new Options(void 0, void 0, defaults3.options),
    handlers: [...defaults3.handlers],
    mutableDefaults: defaults3.mutableDefaults
  };
  Object.defineProperty(defaults3, "mutableDefaults", {
    enumerable: true,
    configurable: false,
    writable: false
  });
  const got2 = (url2, options, defaultOptions2 = defaults3.options) => {
    const request2 = new Request(url2, options, defaultOptions2);
    let promise;
    const lastHandler = (normalized) => {
      request2.options = normalized;
      request2._noPipe = !normalized.isStream;
      void request2.flush();
      if (normalized.isStream) {
        return request2;
      }
      if (!promise) {
        promise = asPromise(request2);
      }
      return promise;
    };
    let iteration = 0;
    const iterateHandlers = (newOptions) => {
      const handler = defaults3.handlers[iteration++] ?? lastHandler;
      const result = handler(newOptions, iterateHandlers);
      if (dist_default.promise(result) && !request2.options.isStream) {
        if (!promise) {
          promise = asPromise(request2);
        }
        if (result !== promise) {
          const descriptors2 = Object.getOwnPropertyDescriptors(promise);
          for (const key in descriptors2) {
            if (key in result) {
              delete descriptors2[key];
            }
          }
          Object.defineProperties(result, descriptors2);
          result.cancel = promise.cancel;
        }
      }
      return result;
    };
    return iterateHandlers(request2.options);
  };
  got2.extend = (...instancesOrOptions) => {
    const options = new Options(void 0, void 0, defaults3.options);
    const handlers = [...defaults3.handlers];
    let mutableDefaults;
    for (const value of instancesOrOptions) {
      if (isGotInstance(value)) {
        options.merge(value.defaults.options);
        handlers.push(...value.defaults.handlers);
        mutableDefaults = value.defaults.mutableDefaults;
      } else {
        options.merge(value);
        if (value.handlers) {
          handlers.push(...value.handlers);
        }
        mutableDefaults = value.mutableDefaults;
      }
    }
    return create({
      options,
      handlers,
      mutableDefaults: Boolean(mutableDefaults)
    });
  };
  const paginateEach = async function* (url2, options) {
    let normalizedOptions = new Options(url2, options, defaults3.options);
    normalizedOptions.resolveBodyOnly = false;
    const { pagination } = normalizedOptions;
    assert.function_(pagination.transform);
    assert.function_(pagination.shouldContinue);
    assert.function_(pagination.filter);
    assert.function_(pagination.paginate);
    assert.number(pagination.countLimit);
    assert.number(pagination.requestLimit);
    assert.number(pagination.backoff);
    const allItems = [];
    let { countLimit } = pagination;
    let numberOfRequests = 0;
    while (numberOfRequests < pagination.requestLimit) {
      if (numberOfRequests !== 0) {
        await delay(pagination.backoff);
      }
      const response = await got2(void 0, void 0, normalizedOptions);
      const parsed = await pagination.transform(response);
      const currentItems = [];
      assert.array(parsed);
      for (const item of parsed) {
        if (pagination.filter({ item, currentItems, allItems })) {
          if (!pagination.shouldContinue({ item, currentItems, allItems })) {
            return;
          }
          yield item;
          if (pagination.stackAllItems) {
            allItems.push(item);
          }
          currentItems.push(item);
          if (--countLimit <= 0) {
            return;
          }
        }
      }
      const optionsToMerge = pagination.paginate({
        response,
        currentItems,
        allItems
      });
      if (optionsToMerge === false) {
        return;
      }
      if (optionsToMerge === response.request.options) {
        normalizedOptions = response.request.options;
      } else {
        normalizedOptions.merge(optionsToMerge);
        assert.any([dist_default.urlInstance, dist_default.undefined], optionsToMerge.url);
        if (optionsToMerge.url !== void 0) {
          normalizedOptions.prefixUrl = "";
          normalizedOptions.url = optionsToMerge.url;
        }
      }
      numberOfRequests++;
    }
  };
  got2.paginate = paginateEach;
  got2.paginate.all = async (url2, options) => {
    const results = [];
    for await (const item of paginateEach(url2, options)) {
      results.push(item);
    }
    return results;
  };
  got2.paginate.each = paginateEach;
  got2.stream = (url2, options) => got2(url2, { ...options, isStream: true });
  for (const method of aliases) {
    got2[method] = (url2, options) => got2(url2, { ...options, method });
    got2.stream[method] = (url2, options) => got2(url2, { ...options, method, isStream: true });
  }
  if (!defaults3.mutableDefaults) {
    Object.freeze(defaults3.handlers);
    defaults3.options.freeze();
  }
  Object.defineProperty(got2, "defaults", {
    value: defaults3,
    writable: false,
    configurable: false,
    enumerable: true
  });
  return got2;
};
var create_default = create;

// node_modules/got/dist/source/index.js
var defaults2 = {
  options: new Options(),
  handlers: [],
  mutableDefaults: false
};
var got = create_default(defaults2);
var source_default2 = got;

// src/$server/services/NodeX/index.ts
var import_path7 = __toESM2(require("path"));
var import_os4 = __toESM2(require("os"));
var DID = class {
  // NOTE: VC 
  static generateVC(params) {
    return __async(this, null, function* () {
      const base = `unix:${import_path7.default.join(import_os4.default.homedir(), ".unid/run/unid.sock")}`;
      const text = yield source_default2.post([base, "/internal/verifiable-credentials"].join(":"), {
        enableUnixSockets: true,
        json: {
          message: JSON.parse(params.message)
        }
      }).text();
      return text;
    });
  }
  // NOTE: VC 
  static verifyVC(params) {
    return __async(this, null, function* () {
      const base = `unix:${import_path7.default.join(import_os4.default.homedir(), ".unid/run/unid.sock")}`;
      const text = yield source_default2.post([base, "/internal/verifiable-credentials/verify"].join(":"), {
        enableUnixSockets: true,
        json: {
          message: JSON.parse(params.message)
        }
      }).text();
      return text;
    });
  }
};
var DIDComm = class {
  // NOTE: DIDComm Plain 
  static generatePlaintextMessage(params) {
    return __async(this, null, function* () {
      const base = `unix:${import_path7.default.join(import_os4.default.homedir(), ".unid/run/unid.sock")}`;
      const text = yield source_default2.post([base, "/internal/didcomm/plaintext-messages"].join(":"), {
        enableUnixSockets: true,
        json: {
          destinations: params.destinations,
          message: JSON.parse(params.message)
        }
      }).text();
      return text;
    });
  }
  // NOTE: DIDComm Plain 
  static verifyPlaintextMessage(params) {
    return __async(this, null, function* () {
      const base = `unix:${import_path7.default.join(import_os4.default.homedir(), ".unid/run/unid.sock")}`;
      const text = yield source_default2.post([base, "/internal/didcomm/plaintext-messages/verify"].join(":"), {
        enableUnixSockets: true,
        json: {
          message: JSON.parse(params.message)
        }
      }).text();
      return text;
    });
  }
  // NOTE: DIDComm Sign 
  static generateSignedMessage(params) {
    return __async(this, null, function* () {
      const base = `unix:${import_path7.default.join(import_os4.default.homedir(), ".unid/run/unid.sock")}`;
      const text = yield source_default2.post([base, "/internal/didcomm/signed-messages"].join(":"), {
        enableUnixSockets: true,
        json: {
          destinations: params.destinations,
          message: JSON.parse(params.message)
        }
      }).text();
      return text;
    });
  }
  // NOTE: DIDComm Sign 
  static verifySignedMessage(params) {
    return __async(this, null, function* () {
      const base = `unix:${import_path7.default.join(import_os4.default.homedir(), ".unid/run/unid.sock")}`;
      const text = yield source_default2.post([base, "/internal/didcomm/signed-messages/verify"].join(":"), {
        enableUnixSockets: true,
        json: {
          message: JSON.parse(params.message)
        }
      }).text();
      return text;
    });
  }
  // NOTE: DIDComm Enc 
  static generateEncryptedMessage(params) {
    return __async(this, null, function* () {
      const base = `unix:${import_path7.default.join(import_os4.default.homedir(), ".unid/run/unid.sock")}`;
      const text = yield source_default2.post([base, "/internal/didcomm/encrypted-messages"].join(":"), {
        enableUnixSockets: true,
        json: {
          destinations: params.destinations,
          message: JSON.parse(params.message)
        }
      }).text();
      return text;
    });
  }
  // NOTE: DIDComm Enc 
  static verifyEncryptedMessage(params) {
    return __async(this, null, function* () {
      const base = `unix:${import_path7.default.join(import_os4.default.homedir(), ".unid/run/unid.sock")}`;
      const text = yield source_default2.post([base, "/internal/didcomm/encrypted-messages/verify"].join(":"), {
        enableUnixSockets: true,
        json: {
          message: JSON.parse(params.message)
        }
      }).text();
      return text;
    });
  }
};
var NodeXService = class {
  static get DIDComm() {
    return DIDComm;
  }
  static get DID() {
    return DID;
  }
};

// prisma/client.ts
var import_client = __toESM2(require_client3());

// src/config.ts
var AppConfig = class {
  fetch(value, defaultValue) {
    if (value === "" || value === void 0) {
      if (defaultValue !== void 0) {
        return defaultValue;
      } else {
        return void 0;
      }
    }
    return value;
  }
  get NODE_ENV() {
    const v = this.fetch(process.env.NODE_ENV);
    const d = "development";
    if (v === void 0) {
      return d;
    }
    return v.toLowerCase();
  }
  get IN_PRODUCTION() {
    return this.NODE_ENV === "production";
  }
  get REDIS_URL() {
    const v = this.fetch(process.env.REDIS_URL);
    if (v === void 0) {
      throw new Error();
    }
    return v;
  }
  get DATABASE_URL() {
    return this.fetch(process.env.DATABASE_URL);
  }
  get PRISMA_FIELD_ENCRYPTION_KEY() {
    const v = this.fetch(process.env.PRISMA_FIELD_ENCRYPTION_KEY);
    if (v === void 0) {
      throw new Error();
    }
    return v;
  }
  get BASIC_AUTH_USERNAME() {
    return this.fetch(process.env.BASIC_AUTH_USERNAME);
  }
  get BASIC_AUTH_PASSWORD() {
    return this.fetch(process.env.BASIC_AUTH_PASSWORD);
  }
};
var Config = new AppConfig();

// prisma/client.ts
var import_prisma_field_encryption = __toESM2(require_dist4());
var client = void 0;
var prisma = (() => {
  if (!client) {
    client = new import_client.PrismaClient({
      log: ["query", "info", "warn", "error"],
      datasources: { db: { url: Config.DATABASE_URL } }
    });
  }
  return client;
})();
prisma.$use(
  (0, import_prisma_field_encryption.fieldEncryptionMiddleware)({
    encryptionKey: Config.PRISMA_FIELD_ENCRYPTION_KEY
  })
);

// jobs/import-records.ts
(() => __async(exports, null, function* () {
  const records = yield axios_default.get("http://localhost:3001/records");
  console.log(records.data);
  const verified = yield Promise.all(records.data.map((r) => {
    return NodeXService.DIDComm.verifyEncryptedMessage({
      message: r.data
    });
  }));
  yield Promise.all(verified.map((vc) => {
    const json = JSON.parse(vc);
    const did = json.issuer.id || "";
    return prisma.document.create({
      data: {
        did,
        location: "<UNDEFINED>",
        username: "<UNDEFINED>",
        vc
      }
    });
  }));
}))();
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@prisma/client/runtime/index.js:
  (*!
   *  decimal.js v10.4.2
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
  (*!
   * @description Recursive object extending
   * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
   * @license MIT
   *
   * The MIT License (MIT)
   *
   * Copyright (c) 2013-2018 Viacheslav Lotsmanov
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *)
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
*/
